`
        Zy is an Object oriented language which allows both static and dynamic
    type checking.  Each line of zy code is a statement ending in a newline
    character.  Expressions such as 3 * (4 + 5) may be part of a statement,
    but are not valid alone.
`

`
    The following is an example of an import statement.  It is importing The
    modules math, io, str, op, and c_ffi which are some of the currently planned modules.
`
import "math", "io", "string", "op", "c_ffi"

~This is an example of a single line comment

`
        Variables
    Variables are declared with any modifiers (such as dyn to indicate a
    dynamic typing) followed by the variable's type and identifier in the 
    following syntax:
    
    [modifiers] [type] [identifier]
    
    Below is the declaration of a variable, myVar, with a dynamic typing,
    meaning it can be set to any value and its type will change accordingly.
    By default, dynamic variables are set to the int type.
`
dyn myVar
print typeof(myVar) ~output: dynamic int

`
    types can also be assigned to variables, below are the primitive types
    initialized to their default values
`

int myInt = 0
num myNum = 0.0
str myString = ""
bool myBool = false

`
    Any primitive value can also be typecasted to any other primitive type, or
    even completely redefined to that type.
`

print int 4.99  ~output: 4
num n = 43.876
int n

~NOTE: the .. below is the string concat operator
print typeof(n) .. " " .. n  ~output: int 43

`
        Arrays

    The syntax for declaring arrays is type|size> identifier.  The array arr
    declared below is an array of 30 integers, each initialized to 1

    The syntax for declaring an array is: 
        
        [type]\[size\] name

    Where size is an integer expression.
    NOTE: if size does not evaluate to an integer, the program will halt
          with a TypeMismatchError.  To avoid this, it is best to only use
          integer variables and constants in this expression.
`
int[30] arr = 1

~Each element of an array can also be initialized individually
num[5] assortedNums = 9, -76, 3.14159265, 2^8, 1 + 2*(6-3)

`
    Each element of an array can be accessed individually by index.  Negative
    indexes work backwards from the end of the array, so arr[-1] will always
    yield the last element of arr.
`
assortedNums[0] += assortedNums[1]
print assortedNums[0] .. ", " .. assortedNums[-2]

~output: -67, 256

`
    The size of an array can also be dynamically edited.  The following syntax
    should always be used when expanding or restricting an array.
`
arr += 2
arr -= 3 ~Note: this will throw an exception if the array's size becomes < 0

`
        Tuples
    In addition to arrays, there are also tuples.  Unlike arrays, tuples can
    be mixed and matched with several types, but each must be stated beforehand.
`
int, num, str tup = 44, 44.0, "Fourty-four"

int[30], str[2] anotherTuple = arr, ["This tuple contains", "two arrays"]

`
    This restriction does not apply when making a dynamic variable of course
`
dyn dynTuple = 46, "Fourty-six", 46.0

`
    When printed, tuples are by default printed with the following syntax:
        Tuple([size]: [values])
`
print dynTuple
~output: Tuple(3: 46, Fourty-six, 46)

`
        Functions

    Functions in zy each have their own scope in addition to the scopes they
    inherit (in this case, only the global scope).  Variables created in
    functions are all local variables by default, however they can be
    exported into the global scope with the export keyword.

    Below is the declaration of a function, printMsg.  It takes no parameters
    and returns no value.  It is important to note that unlike many c based
    languages, blocks are denoted by changes in indentation rather than
    opening and closing brackets.
`
void printMsg:
    print "Hello World!"

`
    This add function takes in two parameters, augend and addend, and returns
    a num value.
`
num add: num augend, num addend
    return augend + addend

`
    Zy also has several reserved variables.  Variables with identifiers starting
    with an underscore are reserved and should not be manually assigned values.
    The function below takes in a variable amount of parameters, as denoted by
    the elipses.  Since _params always contains a tuple of each parameter of
    the function, all the params are passed to the print keyword, with an
    additional newline passed at the end.
`

void println: ...
    print _params, '\n'

`
    Here is the syntax for calling functions:
`
println("Test #", add(3, 43))
~output: Tuple(2: Test #, 43)

`
        C FFI
    The c foreign function interface is implemented within the c_ffi module.
`
import c_ffi("path/to/file.h", ["functions", "to", "import"])

~Or, every function can be imported using * as the filename.
import c_ffi("some/other/file.h", "*")

import c_ffi("stdio.h", "putchar")
putchar(90)
putchar(121)
putchar(10)
~output: Zy

`
        Loops

    Zy has four kinds of loops: while, do while, for, and foreach.
    The while loop runs while the following expression is true.  The do while
    loop runs once then runs while its following expression is true.  The for
    loop initializes a variable, runs while the expression surrounded by semicolons
    is true, then assigns a new value to a variable.  The foreach loop loops
    through each element of an array.
`
while true
    print "I loop forever"


do
    print "I only loop once"
while false

~prints 1-10
for int i = 1; i <= 10; i += 1
    print i .. " "

num total
foreach num n in arr
    total += n

`
        The -> Symbol
    The -> symbol can be optionaly used at the end of statements expecting
    an indent to be replaced with an indent.  This is useful for compressing
    short statements into a single line.
`
if 5 > 2 -> print "5 is greater than 2"
else     -> print "Invalid laws of mathematics, please try again in an alternate universe"

foreach num n in arr -> print n

int subtract: int a, int b -> return a - b

~While these can be nested, too many on the same line can lead to clutter
class Integer -> pub int i   void _init: int a -> i = a

~compared to
class Integer
    pub int i

    void _init: int a
        i = a

`
        Embedded Statements
    Zy's normal syntax is <statement> [expression], but this can lead
    to some needlessly long functions.  One way to condense these
    functions is to use embedded statements.  Embedded statements are
    named as such becuase they are statements embedded within an
    expression.

    An embedded statement is always preceeded with an open bracket and 
    terminated with a matching closing bracket.  Unlike statements, 
    embedded statements need to return a value to be used in the expression,
    so the dynamic variable _ is used to modify this value.  If a return
    statement is encountered, it returns that value instead.  If _ is never
    assigned to within the embedded statement, _ = 0 by default.
`

`
    The following example uses an embedded statement to find the sum
    of each element of data array, and divide it by the number of
    elements in the array to find the mean on a single line.
`
num mean1: num[] data
    return {foreach num n in data -> _ += n} / size(data)

`
    Without embedded statements, the above function would have
    taken up 3 additional lines of code.
`
num mean2: num[] data
    num sum
    foreach num n in data
        sum += n
    return sum / size(data)

`
    Embedded statements can also be used as a shortcut for
    assigning variables within an expression.

    In the following example, an integer i is incremented at
    each iteration of the loop. The conditional is evaluated 
    before each iteration of the loop, the numbers 1-100 are 
    printed, and the loop closes when i == 101
`
int i
while {i += 1; return i} <= 100
    print i


`
        Structs
    Structs are a compound structure of data where a struct can contain multiple
    variables including arrays or objects.
`
struct Coord
    num x, y, z

~To create a struct, typecast a tuple containing the struct's members to the
~corresponding struct type.
Coord coord = Struct(100, -50, 66.7)
print coord  ~output: 100, -50, 66.7


`
        Classes
    Classes can be declared with the class keyword.  They each have their own
    namespace, and can have functions and variables declared within them.
    By default, variables declared within classes are private.
`

class Animal
    int age
    str species
    str name
`
    The _init function is a function that is automatically called when a class
    is initialized and the givin values match _init's parameters.  It can be
    thought of as the constructor for the class.
`
    void _init: int, str, str
        age = _params[0]
        species = _params[1]
        name = _params[2]

    void printInfo:
        print name .. " is a/an " .. species .. " and is " .. age .. " year(s) old.\n"

`
    To create an instance of the class, use the class name as the type of the
    variable, and the keyword new followed by the classname to be initialized 
    with the parameters of the _init function declared within the class.
`
Animal clifford = new Animal(7, "magnum rubrum canis", "Clifford")


`
    Classes can also inherit from other classes with the : token.
`
class Person : Animal
    str job

    void _init: int age, str j, str name
        job = j
        super(age, "Homo sapien", name) ~super() calls the _init function from the parent class

`
    This function obscures the printInfo declared in the Animal super class.
`
    void printInfo:
        print name .. " is " .. age .. " years old and is a(n) " .. job


Person john = new Person(44, "electrician", "John")
john.printInfo() ~output: John is 44 years old and is a(n) electrician

`
        Modifiers
    With classes comes the necessity for modifiers, such as the visibility
    modifiers pub, pro, and pri.  These are short for public, protected,
    and private respectively.  Another common modifier is const to declare
    a constant variable.

    Modifiers can be placed before a variable or function, or alternatively
    can be placed before a new block to modify everything within the block
`
class Statistics
    ~declare secretData as a private variable, only able to be accessed
    ~from within the class
    pri num secretData

    pri const num pi = 3.14159265
    
    pub int varCount

    ~Alternatively, you can also use modifiers before a block:
    pub
        num getData:
            return secretData ~not so secret anymore

        str getStatus:
            if secretData > 10
                return "Good"
            else
                return "Not so good"

    ~NOTE: by default, variables and methods are private so there is really 
    ~      no need to declare this function private explicitly.
    pri num doCalculations: num data
            return data * secretData / varCount

    ~NOTE: reserved functions such as _init and _mul do not need to be public
    ~      to be automatically called.
    void _init: int[] data
        foreach int i in data
            secretData += data / pi
            varCount += 1

`
        Type Specifications and Operator Overloading
    Type specifications in zy are a powerful way to specialize a class or function
    to a specific usage.  In its most general case, it can be used in much the same
    way as generics or templates in other object oriented languages.  To declare a type
    specification for a class, parenthesis are used after the class name.  Within the
    parenthesis a type is binded to a name, and an optional boolean expression which
    must be able to be evaluated at compile time.  For functions, the keyword where is
    used followed by the name of the type in question and a boolean statment validating
    that the type is valid for the function.
`
~In this example, O is any type which has the operators > and < available or overloaded.
~For functions, the where keyword always comes at the end of the list of parameters.
pub int cmp: O o2  where O has_ops(O, ['>', '<'])
    if self < o2
        return -1
    return self > o2

~The syntax for type specifications in a class is somewhat similar.
~In the Angle class, each time it is initialized, a bool is specified as true if the
~angle is in radians, false otherwise.  This determines how Angle is compiled and
~cannot be changed after initialization.
class Angle(bool isRadians)
    num angle

    void _init: num a
        angle = a

    if isRadians
        int getQuadrant:
            return angle / (3.14159265 / 4) % 4 + 1
    else
        int getQuadrant:
            return angle / 90 % 4 + 1

`
        Operator Overloading
    Note that the cmp example above requires that the operator < is implemented for
    the two objects.  To do this we must implement operator overloading.  In the
    following example, the class Point is created and overloads the > and < operators,
    and creates the new operator <=> for comparisons.
`
class Point
    pub int x, y

    void _init: int x, int y
        self.x = x
        self.y = y

    `
        Now to implement the < operator. Each operator is declared as a function 
        with the name generated by the function op_overLoad which is imported from the 
        op module. This function requires the operator in question in string form.  Invalid
        operators will throw a compile-time error.
    `
    bool op_overLoad('<'): Point rVal
        if x < rVal.x
            return 1
        return y < rVal.y

    bool op_overLoad('>'): Point rVal
        if x > rVal.x
            return 1
        return y > rVal.y

    `
        It is also possible to create a completely new operator.  To do this, use 
        the op_new function from the op module to register the operator.  This 
        function takes 4 parameters, the first being the operator in string form 
        (no longer than 3 characters). Next, two bools are used to indicate the 
        presence of an lvalue and rvalue (ie the op ! would be false, true), if 
        both of these are false, it will fail to compile. Lastly, an int specifies 
        the precedence of the operator. To get the desired precedence, the function 
        prec should be called which gets the precedence of an existing operator.

        NOTE: There are certain operators which cannot be created such as ->, which is reserved as an
              indent token.
    `
    int op_new('<=>', true, true, prec('>')): Point rVal
        if this > rVal -> return 1
        if this < rVal -> return -1
        return 0

Point origin = new Point(0, 0)
Point topRight = new Point(5, 5)

print origin < topRight
print origin > topRight
print origin <=> topRight
`output:
true
false
-1
`

`
        Pattern Matching
    Pattern matching can be accomplished with the match keyword
`

int testInt = 3
match testInt
    1 -> print "Yup, its one"
    2 -> print "It's actually two"
    3 -> print "Nope, it's three"
    _ -> print "It's not one, two, or three"
~output: Nope, it's three

~In this example, match is used to determine Joe's class
Person joe = new Person(32, "Programmer", "Joe")
match joe
    Point  -> print "Joe is a point"
    Animal -> print "Joe is an Animal"
    Person -> print "Joe is a Person"
    _      -> print "I don't know what Joe is" 
~output: Joe is an Animal
~This is because the Person class inherits from the Animal
~class, so the Animal cast to joe was the first valid cast

struct String
    str s
    int len

String testStr = "Test", 4

match testStr
    String("Test", 3)
        print "This will not be matched"
    String("Testing", 4)
        print "This will not be matched either"
    String("Test", 4")
        print "This will be matched"



`
        Enums
    Declaring an enum declares a set of named constants. They are declared
    like normal variables with the type enum. Ints typecasted to an enum
    will become the constant that corresponds to the n-1 index of the enum where
    n is the value of the integer. Conversely, typecasting an enum to an int
    yields that enums placement in its declaration starting from 0. Typecasting 
    an enum to a string yields the name of the value.
`
~NOTE: -> is used for single-line statements that would normally require an indent.
enum Suit -> Diamonds, Hearts, Spades, Clubs

Suit spades = Suit.Spades
print spades, " ", string spades  ~output: 2 Spades

struct Card
    int number
    Suit suit

Card fourOfHearts = 4, Suit.Hearts

`
        Keywords
primitive datatypes:
    num 
    int 
    str 
    bool 
    void

constants:
    true 
    false

statements:
    if 
    elif 
    else 
    import 
    print
    match
    
loops: 
    for
    foreach 
    in 
    do 
    while
    continue 
    break

modifiers:
    pub 
    pri 
    pro 
    const 
    ext
    dyn

datatypes:
    class 
    struct 
    enum

other:
    where
`

`
        Unused Symbols
@
#
$
\
|

`


`
        Reserved Variables

_args
    stores the command line arguments of the program

_argc
    contains the amount of command line arguments given

_params
    tuple containing each parameter of the current function

_paramc
    amount of parameters in the current function

_precision
    int containing the amount of decimal places to print 
    when printing a num
    
    default: 10
    min: 0
    max: 21

_G
    The global variable/function table.  Could be used to
    call a function name given the name as astring
    
    example:
        _G["myFunc"](var1, var2, ...)

_
    a dynamic variable that represents the return value of an
    embedded statement.  Gets reset to 0 at the start of each
    embedded statement.

    default: 0
    dynamic: true

`

`
        Reserved Functions
_init
    Can be declared within a class to be automatically called
    when creating a new instance of the class.

_add
    Can be declared within a class to be automatically called
    when adding two instances of the class.

_sub
    Can be declared within a class to be automatically called
    when subtracting two instances of the class.

_mul
    Can be declared within a class to be automatically called
    when multiplying two instances of the class.

_div
    Can be declared within a class to be automatically called
    when dividing two instances of the class.

_mod
    Can be declared within a class to be automatically called
    when getting the remainder of two instances of the class.

_pow
    Can be declared within a class to be automatically called
    when getting the power of two instances of the class.

_cnct
    Can be declared within a class to be automatically called
    when contatenating two instances of the class.

`
