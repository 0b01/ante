`
        Zy is an Object oriented language which allows both static and dynamic
    type checking.  Each line of zy code is a statement ending in a newline
    character.  Expressions such as 3 * (4 + 5) may be part of a statement,
    but are not valid alone.
`

`
    The following is an example of an import statement.  It is importing The
    modules math, io, str, op, and c_ffi which are some of the currently planned modules.
`
import "math", "io", "string", "op", "c_ffi"

~This is an example of a single line comment

`
        Variables
    Variables are declared with any modifiers (such as dyn to indicate a
    dynamic typing) followed by the variable's type and identifier in the 
    following syntax:
    
    [modifiers] [type] [identifier]
    
    Below is the declaration of a variable, myVar, with a dynamic typing,
    meaning it can be set to any value and its type will change accordingly.
    By default, dynamic variables are set to the int type.
`
dyn myVar
print typeof(myVar) ~output: dynamic i8

`
    types can also be assigned to variables, below are the primitive types
    initialized to their default values
`

i8  myI8  = 0
i16 myI16 = 0
i32 myI32 = 0
i64 myI64 = 0
u8  myU8  = 0
u16 myU16 = 0
u32 myU32 = 0
u64 myU64 = 0
f32 myF32 = 0.0
f64 myF64 = 0.0
str myStr = ""
bool myBool = false

`
    Any primitive value can also be typecasted to any other primitive type, or
    even completely redefined to that type.
`

print i32 4.99  ~output: 4
f32 n = 43.876
i32 n

~NOTE: the .. below is the string concat operator
print typeof(n) .. " " .. n  ~output: i32 43

`
        Arrays

    The syntax for declaring arrays is shown below.  The array arr
    declared below is an array of 30 integers, each initialized to 1

    The syntax for declaring an array is: 
        
        [type]\[size\] name

    NOTE: if size does not evaluate to an integer, the program will halt
          with a TypeMismatchError.  To avoid this, it is best to only use
          integer variables and constants in this expression.
`
i32[30] arr = 1

~Each element of an array can also be initialized individually
f32[5] assortedNums = 9, -76, 3.14159265, 2^8, 1 + 2*(6-3)

`
    Each element of an array can be accessed individually by index.  Negative
    indexes work backwards from the end of the array, so arr[-1] will always
    yield the last element of arr.
`
assortedNums[0] += assortedNums[1]
print assortedNums[0] .. ", " .. assortedNums[-2]

~output: -67, 256

`
    The size of an array can also be dynamically edited.  The following syntax
    should always be used when expanding or restricting an array.
`
arr += 2
arr -= 3 ~Note: this will throw an exception if the array's size becomes < 0

`
        Tuples
    In addition to arrays, there are also tuples.  Unlike arrays, tuples can
    be mixed and matched with several types, but each must be stated beforehand.
`
i8, f32, str tup = 44, 44.0, "Fourty-four"

i8[30], str[2] anotherTuple = arr, ["This tuple contains", "two arrays"]

`
    This restriction does not apply when making a dynamic variable of course
`
dyn dynTuple = 46, "Fourty-six", 46.0

`
    When printed, tuples are by default printed with the following syntax:
        Tuple([size]: [values])
`
print dynTuple
~output: Tuple(3: 46, Fourty-six, 46)

`
        Functions

    Functions in zy each have their own scope in addition to the scopes they
    inherit (in this case, only the global scope).  Variables created in
    functions are all local variables by default, however they can be
    exported into the global scope with the export keyword.

    Below is the declaration of a function, printMsg.  It takes no parameters
    and returns no value.  It is important to note that unlike many c based
    languages, blocks are denoted by changes in indentation rather than
    opening and closing brackets.
`
void printMsg:
    print "Hello World!"

`
    This add function takes in two parameters, augend and addend, and returns
    a num value.
`
f64 add: f64 augend, f64 addend
    return augend + addend

`
    Zy also has several reserved variables.  Variables with identifiers starting
    with an underscore are reserved and should not be manually assigned values.
    The function below takes in a variable amount of parameters, as denoted by
    the elipses.  Since _params always contains a tuple of each parameter of
    the function, all the params are passed to the print keyword, with an
    additional newline passed at the end.
`

void println: ...
    print _params, '\n'

`
    Here is the syntax for calling functions:
`
println("Test #", add(3, 43))
~output: Tuple(2: Test #, 46)

`
        C FFI
    The c foreign function interface is implemented within the c_ffi module.
`
import c_ffi("path/to/file.h", ["functions", "to", "import"])

~Or, every function can be imported using * as the filename.
import c_ffi("some/other/file.h", "*")

import c_ffi("stdio.h", "putchar")

putchar(90)
putchar(121)
putchar(10)
~output: Zy

`
        Loops

    Zy has four kinds of loops: while, do while, for, and foreach.
    The while loop runs while the following expression is true.  The do while
    loop runs once then runs while its following expression is true.  The for
    loop initializes a variable, runs while the expression surrounded by semicolons
    is true, then assigns a new value to a variable.  The foreach loop loops
    through each element of an array.
`
while true
    print "I loop forever"


do
    print "I only loop once"
while false

~prints 1-10
for i8 i = 1; i <= 10; i += 1
    print i .. " "

f32 total
foreach f32 n in arr
    total += n

`
        The -> Symbol
    The -> symbol can be optionaly used at the end of statements expecting
    an indent to be replaced with an indent.  This is useful for compressing
    short statements into a single line.
`
if 5 > 2 -> print "5 is greater than 2"
else     -> print "Invalid laws of mathematics, please try again in an alternate universe"

foreach f32 f in arr -> print f

f32 subtract: f32 a, f32 b -> return a - b

~While these can be nested, too many on the same line can lead to clutter
class Integer -> pub i32 i   void _init: i32 a -> i = a

~compared to
class Integer
    pub i32 i

    void _init: i32 a
        i = a

`
        Embedded Statements
    Zy's normal syntax is <statement> [expression], but this can lead
    to some needlessly long functions.  One way to condense these
    functions is to use embedded statements.  Embedded statements are
    named as such becuase they are statements embedded within an
    expression.

    An embedded statement is always preceeded with an open bracket and 
    terminated with a matching closing bracket.  Unlike statements, 
    embedded statements need to return a value to be used in the expression,
    so the dynamic variable _ is used to modify this value.  If a return
    statement is encountered, it returns that value instead.  If _ is never
    assigned to within the embedded statement, _ = 0 by default.
`

`
    The following example uses an embedded statement to find the sum
    of each element of data array, and divide it by the number of
    elements in the array to find the mean on a single line.
`
f32 mean1: f32[] data
    return {foreach f32 n in data -> _ += n} / size(data)

`
    Without embedded statements, the above function would have
    taken up 3 additional lines of code.
`
f32 mean2: f32[] data
    f32 sum = 0
    foreach f32 n in data
        sum += n
    return sum / size(data)

`
    Embedded statements can also be used as a shortcut for
    assigning variables within an expression.

    In the following example, an integer i is incremented at
    each iteration of the loop. The conditional is evaluated 
    before each iteration of the loop, the numbers 1-100 are 
    printed, and the loop closes when i == 101
`
i8 i = 0
while {i += 1; return i} <= 100
    print i


`
        Structs
    Structs are a compound structure of data where a struct can contain multiple
    variables including arrays or objects.
`
struct Coord
    f64 x, y, z

~To create a struct, typecast a tuple containing the struct's members to the
~corresponding struct type.
Coord coord = Coord(100, -50, 66.7)
print coord  ~output: 100, -50, 66.7


`
        Classes
    Classes can be declared with the class keyword.  They each have their own
    namespace, and can have functions and variables declared within them.
    By default, variables declared within classes are private, while functions
    are public by default.
`

class Animal
    u16 age
    str species
    str name
`
    The _init function is a function that is automatically called when a class
    is initialized and the givin values match _init's parameters.  It can be
    thought of as the constructor for the class.
`
    void _init: u16, str, str
        age = _params[0]
        species = _params[1]
        name = _params[2]

    void printInfo:
        print name .. " is a/an " .. species .. " and is " .. age .. " year(s) old.\n"

`
    To create an instance of the class, use the class name as the type of the
    variable, and the keyword new followed by the classname to be initialized 
    with the parameters of the _init function declared within the class.
`
Animal clifford = new Animal(7, "magnum rubrum canis", "Clifford")


`
    Classes can also inherit from other classes with the : token.
`
class Person : Animal
    str job

    void _init: u16 age, str j, str name
        job = j
        super(age, "Homo sapien", name) ~super() calls the _init function from the parent class

`
    This function obscures the printInfo declared in the Animal super class.
`
    void printInfo:
        print name .. " is " .. age .. " years old and is a(n) " .. job


Person john = Person(44, "electrician", "John")
john.printInfo() ~output: John is 44 years old and is a(n) electrician

`
        Modifiers
    With classes comes the necessity for modifiers, such as the visibility
    modifiers pub, pro, and pri.  These are short for public, protected,
    and private respectively.  Another common modifier is const to declare
    a constant variable.

    Modifiers can be placed before a variable or function, or alternatively
    can be placed before a new block to modify everything within the block
`
class Statistics
    ~declare secretData as a private variable, only able to be accessed
    ~from within the class
    pri f64 secretData

    pro const num pi = 3.14159265
    
    pub i32 varCount

    ~Alternatively, you can also use modifiers before a block:
    pub
        f64 getData:
            return secretData ~not so secret anymore

        str getStatus:
            if secretData > 10
                return "Good"
            else
                return "Not so good"

    ~NOTE: by default, variables and methods are private so there is really 
    ~      no need to declare this function private explicitly.
    pri f64 doCalculations: f64 data
            return data * secretData / varCount

    ~NOTE: reserved functions such as _init and _mul do not need to be public
    ~      to be automatically called.
    void _init: i32[] data
        foreach i32 i in data
            secretData += data / pi
            varCount += 1

`
        Type Specifications and Operator Overloading
    Type specifications in zy are a powerful way to specialize a class or function
    to a specific usage.  In its most general case, it can be used in much the same
    way as generics or templates in other object oriented languages.  To declare a type
    specification for a class, parenthesis are used after the class name.  Within the
    parenthesis a type is binded to a name, and an optional boolean expression which
    must be able to be evaluated at compile time.  For functions, the keyword where is
    used followed by the name of the type in question and a boolean statment validating
    that the type is valid for the function.
`
~In this example, T is any type which has the operators > and < available or overloaded.
~For functions, the where keyword always comes at the end of the list of parameters.
~NOTE: hasOps is an infix function, these will be shown later.
pub i32 cmp: T t2  where T hasOps ['>', '<']
    if self < t2 -> return -1
    return self > t2

~The syntax for type specifications in a class is somewhat similar.
~In the Angle class, each time it is initialized, a bool is specified as true if the
~angle is in radians, false otherwise.  This determines how Angle is compiled and
~cannot be changed after initialization.
class Angle<bool isRadians>
    f32 angle

    void _init: f32 a
        angle = a

    if isRadians
        u8 getQuadrant:
            return angle / (3.14159265 / 4) % 4 + 1
    else
        u8 getQuadrant:
            return angle / 90 % 4 + 1
~usage:
Angle<true> a1 = Angle(3.14159265 * 2 / 3)
Angle<false> a2 = Angle(120)
print a1.getQuadrent() == a2.getQuadrent()

`
    The use of type specifications eliminates the need to store excess metadata about
    the object to be checked each time a function runs as well as encouraging classes
    to be more specialized without having several copies of otherwise very similar
    classes, eg. having a AngleDegrees and AngleRadians class seperate then having
    to worry about them interacting properly.
`


`
        Operator Overloading and Infix Functions
    Note that the cmp example above requires that the operator < is implemented for
    the two objects.  To do this we must implement operator overloading.  In the
    following example, the class Point is created and overloads the > and < operators,
    and creates the new operator <=> for comparisons.
`
class Point
    pub i32 x, y

    void _init: i32 x, i32 y
        self.x = x
        self.y = y

    `
        Now to implement the < operator. Each operator is declared as a function 
        with the name generated by the function op which is imported from the 
        op module. This function requires the operator in question in string form.  Invalid
        operators will throw a compile-time error.
    `
    bool op('<'): Point rVal
        if x < rVal.x
            return 1
        return y < rVal.y

    bool op('>'): Point rVal
        if x > rVal.x
            return 1
        return y > rVal.y

    `
            Infix functions
    
        Infix functions are declared by calling the 'infix' function.  This
        function takes two parameters, the name of your function, and the
        precedence for use in expressions.  While precedence can be specified
        manually, it may be best to use the prec function to get the precedence
        of an existing operator to use.
    `

    ~An example of a generic comparison function
    ~Note that this function uses the > and < operators
    ~declared earlier in this class.
    i8 infix('cmp', prec('>')): Point rVal
        if this < rVal -> return -1
        return this > rVal

Point origin = Point(0, 0)
Point topRight = Point(3, 4)

print origin < topRight
print origin > topRight

print origin cmp topRight
`output
true
false
-1
5
`

`
        Pattern Matching
    Pattern matching can be accomplished with the match keyword.
    This attempts to match the input value to any valid type or
    value it comes across.  Each candidate is indented relative
    to the match keyword, and their associated statements are
    indented relative to themselves.  To save space for short
    statements, it is reccomended to use the -> token.
`

i8 testInt = 3
match testInt
    1 -> print "Yup, its one"
    2 -> print "It's actually two"
    3 -> print "Nope, it's three"
    4 .. 10 -> print "It's between 4 and 10 inclusive"
    _ -> print "It's not one, two, or three, or in the range 4-10"
~output: Nope, it's three

~In this example, match is used to determine Joe's class
Person joe = Person(32, "Programmer", "Joe")
match joe
    Point  -> print "Joe is a point"
    Animal -> print "Joe is an Animal"
    Person -> print "Joe is a Person"
    _      -> print "I don't know what Joe is" 
~output: Joe is an Animal
~This is because the Person class inherits from the Animal
~class, so the Animal cast to joe was the first valid cast

struct String
    str s
    u32 len

String testStr = String("Test", 4)

match testStr
    String("Test", 3)
        print "This will not be matched"
    String("Testing", 4)
        print "This will not be matched either"
    String("Test", 4")
        print "This will be matched"

`
        Enums
    Declaring an enum declares a set of named constants. They are declared
    like normal variables with the type enum. Ints typecasted to an enum
    will become the constant that corresponds to the n-1 index of the enum where
    n is the value of the integer. Conversely, typecasting an enum to an int
    yields that enums placement in its declaration starting from 0. Typecasting 
    an enum to a string yields the name of the value.
`
~NOTE: -> is used for single-line statements that would normally require an indent.
enum Suit -> Diamonds, Hearts, Spades, Clubs

Suit spades = Suit.Spades
print spades, " ", string spades  ~output: 2 Spades

struct Card
    u8 number
    Suit suit

Card fourOfHearts = Card(4, Suit.Hearts)


`
        Pointers
    Pointers are created by adding an * after the datatype.
    Since pointers are considered part of the datatype, the
    syntax:
    
    type *name
    
    is not valid.
`


i32 five = 5
i32* ptrToFive = &five
~The unary & operator gets the location of the value 5

~The new keyword automatically allocates data for a class or struct
Card* tod = new Card(3, Suit.Diamonds)

~alternatively, data can be manually allocated.  The following is equivilent
~to the statement above
Card* tod = alloc(sizeof(Card))
*tod = Card(3, Suit.Diamonds)

~Raw pointers must be manually freed with the free function
free(ptrToFive)
free(tod)

~For this reason, it is reccomended to instead use the ptr class which
~Has every relevant operator properly overloaded.
u8 byte = 255

~The ptr class is automatically freed when it goes out of scope, and
~keeps track of the amount of references with little overhead.
ptr<i32> pByte = ptr(byte)

ptr<i32> pByte2 = ptr(pByte)
*pByte2 = &128

print *pByte
~output: 128



`
        Experimental
`
str fnptr(str, str) = add

macro pstr: ident i
    pub const str* i = "p"

pstr(i)
print *i
~output: p


`
        Keywords
primitive datatypes:
    i8
    i16
    i32
    i64
    u8
    u16
    u32
    u64
    f32
    f64
    str 
    bool 
    void

constants:
    true 
    false

statements:
    if 
    elif 
    else 
    import 
    print
    match
    
loops: 
    for
    foreach 
    in 
    do 
    while
    continue 
    break

modifiers:
    pub 
    pri 
    pro 
    const 
    ext
    dyn

datatypes:
    class 
    struct 
    enum

other:
    where
`

`
        Unused Symbols
@
#
$
\
|

`


`
        Reserved Variables

_args
    stores the command line arguments of the program

_argc
    contains the amount of command line arguments given

_params
    tuple containing each parameter of the current function

_paramc
    amount of parameters in the current function

_precision
    int containing the amount of decimal places to print 
    when printing a num
    
    default: 10
    min: 0
    max: 21

_G
    The global variable/function table.  Could be used to
    call a function name given the name as astring
    
    example:
        _G["myFunc"](var1, var2, ...)

_
    a dynamic variable that represents the return value of an
    embedded statement.  Gets reset to 0 at the start of each
    embedded statement.

    default: 0
    dynamic: true

`

`
        Reserved Functions
_init
    Can be declared within a class to be automatically called
    when creating a new instance of the class.

_add
    Can be declared within a class to be automatically called
    when adding two instances of the class.

_sub
    Can be declared within a class to be automatically called
    when subtracting two instances of the class.

_mul
    Can be declared within a class to be automatically called
    when multiplying two instances of the class.

_div
    Can be declared within a class to be automatically called
    when dividing two instances of the class.

_mod
    Can be declared within a class to be automatically called
    when getting the remainder of two instances of the class.

_pow
    Can be declared within a class to be automatically called
    when getting the power of two instances of the class.

_cnct
    Can be declared within a class to be automatically called
    when contatenating two instances of the class.

`
