`
        Zy is an Object oriented language which allows both static and dynamic
    type checking.  Each line of zy code is a statement ending in a newline
    character.  Expressions such as 3 * (4 + 5) may be part of a statement,
    but are not valid alone.
`


`
    The following is an example of an import statement.  It is importing The
    modules math, io, and str, which are the only currently planned modules.
`
import math, io, str

~This is an example of a single line comment

`
        Variables

    Below is the declaration of a variable, myVar, with a dynamic typing,
    meaning it can be set to any value and its type will change accordingly.

    Variables are declared with the > token seperating the variable's type
    and identifier in the following syntax:
    [modifiers] type [modifiers]> identifier
`
>myVar

`
    types can also be assigned to variables, below are the primitive types
    initialized to their default values
`

int> myInt = 0
num> myNum = 0.0
string> myString = ""
bool> myBool = false

`
    Any primitive value can also be typecasted to any other primitive type, or
    even changed to that type completely.  The syntax for this is similar to
    that of a declaration, but without the > token.
`

print int 4.99  ~output: 4
num>n = 43.876
int n
print typeof(n), " ", n  ~output: int 43

`
        Arrays

    The syntax for declaring arrays is type|size> identifier.  The array arr
    declared below is an array of 30 integers, each initialized to 1

    The syntax for declaring an array is: 
        
        type|size|> name

    Where size is an integer expression.
    NOTE: if size does not evaluate to an integer, the program will halt
          with a TypeMismatchError.  To avoid this, it is best to only use
          integer variables and constants in this expression.
`
int|30|> arr = 1

~Each element of an array can also be initialized individually
num|5|> assortedNums = 9, -76, 3.14159265, 2^8, 1 + 2*(6-3)

`
    Each element of an array can be accessed individually by index.  Negative
    indexes work backwards from the end of the array, so arr[-1] will always
    yield the last element of arr.
`
assortedNums[0] += assortedNums[1]
print assortedNums[0], ", ", assortedNums[-2]

~output: -67, 256

`
    The size of an array can also be dynamically edited.  The following syntax
    should always be used when expanding or restricting an array.
`
arr += 2
arr -= 3

`
        Tuples
    In addition to arrays, there are also tuples.  Unlike arrays, tuples can
    be mixed and matched with several types, but each must be stated beforehand.
`
int, num, string> tup = 44, 44.0, "Fourty-four"

int|30|, string|2|> anotherTuple = arr, "This tuple contains", "two arrays"

`
    This restriction does not apply when making a dynamic variable of course
`
>dynTuple = 46, "Fourty-six", 46.0

`
        Functions

    Functions in zy each have their own scope in addition to the scopes they
    inherit (in this case, only the global scope).  Variables created in
    functions are all local variables by default, however they can be changed
    exported into the global scope with the export keyword.

    Below is the declaration of a function, printMsg.  It takes no parameters
    and returns no value.  It is important to note that unlike many c based
    languages, blocks are denoted by changes in indentation rather than
    opening and closing brackets.
`
void> printMsg:
    print "Hello World!"

`
    This add function takes in two parameters, augend and addend, and returns
    a num value.
`
num> add: num augend, num addend
    return augend + addend

`
    Zy also has several reserved variables.  Variables with identifiers starting
    with an underscore are reserved and should not be manually assigned values.
    The below function takes in a variable amount of parameters, as denoted by
    the elipses.  Since _params always contains a tuple of each parameter of
    the function, all the params are passed to the print keyword, with an
    additional newline passed at the end.
`

void> println: ...
    print _params, '\n'

`
    Here is the syntax for calling functions:
`
void> println("Test #", add(3, 43))

`
    You may have noticed that the syntax for function parameters looks somewhat
    familiar.  That is because all functions take a tuple as their input, where
    each member is assigned a name (augend and addend in the add function's case).
    
    Because of this, we can instead pass a tuple containing several or all the
    parameters to a function as is the case with the following examples.
`
num, num> numbers = 4.3, 5.7
num>sum = add(numbers)
print sum
~output: 10.0000000000

`
        Loops

    Zy has four kinds of loops: while, do while, for, and foreach.
    The while loop runs while the following expression is true.  The do while
    loop runs once then runs while its following expression is true.  The for
    loop initializes a variable, runs while the expression surrounded by commas
    is true, then assigns a new value to a variable.  The foreach loop loops
    through each element of an array.
`
while true
    print "I loop forever\n"


do
    print "I only loop once\n"
while false

~prints 1-10
for int>i = 1, i <= 10, i += 1
    print i .. " "

num> total
foreach num>n in arr
    total += n


`
        Classes
    Classes can be declared with the -> token.  They each have their own
    namespace, and can have functions and variables declared within them.
    By default, variables declared within classes are private.
`

->Animal
    int> age
    string> species
    string> name
`
    The _init function is a function that is automatically called when a class
    is initialized and the givin values match _init's parameters.
`
    void>_init: int, string, string
        age = _params[0]
        species = _params[1]
        name = _params[2]

    void> printInfo:
        print name .. " is a/an " .. species .. " and is " .. age .. " year(s) old.\n"

`
    To create an instance of the class, use the class name as the type of the
    variable and it can be initialized with the parameters of the _init
    function declared within the class.
`
Animal> clifford = 52, "magnum rubrum canis", "Clifford"

`
    Classes without any functions work similarly to structures in c or c++.
    Variables within these classes are public by default since there is no other
    way to access them.  The class can be initialized with a list of each value.
`
->Coord
    num> x, y, z

Coord> coord = 100, -50, 66.7
print coord  ~output: 100, -50, 66.7

`
    Classes can also inherit from other classes with the : token.
`
->Person : Animal
    string> job

    void>_init: int age, string j, string name
        job = j
        super(age, "Homo sapien", name)

`
    This function obscures the printInfo declared in the Animal super class.
`
    void> printInfo:
        print name .. " is " .. age .. " years old and is a(n) " .. job


Person> john = 44, "Electrician", "John"
john.printInfo() ~output: John is a 44-year-old Electrician

`
        Modifiers
    With classes comes the necessity for modifiers, such as the visibility
    modifiers pub, pro, and pri.  These are short for public, protected,
    and private respectively.  Another common modifier is const to declare
    a constant variable.

    Modifiers can be placed before a variable or function, or alternatively
    can be placed before a new block to modify everything within the block
`
->Statistics
    ~declare secretData as a private variable, only able to be accessed
    ~from within the class
    pri int> secretData

    pub int> varCount

    ~Alternatively, you can also use modifiers before a block:
    pub
        int> getData:
            return secretData ~not so secret anymore

        ~This method is simplified for demonstration purposes
        string> getStatus:
            if secretData > 10
                return "Good"
            else
                return "Not so good"

    pri void> doCalculations: int data
            return data * secretData

    ~NOTE: reserved functions such as _init and _mul do not need to be public
    ~      to be automatically called.
    void>_init: int|data
        secretData = data
        varCount = 2

`
        Enums
    Declaring an enum declares a set of named constants.  They are declared
    like normal variables with the type enum.  Unlike normal types, other
    variables cannot be typecasted to an enum type, but enums can be
    typecasted to any primitive type.  Typecasting them to a string
    yields the name of the value.
`
enum> Suit = Diamonds, Hearts, Spades, Clubs

Suit> spades = Suit.Spades
print spades, " ", string spades  ~output: 2 Spades

->Card
    int> number
    Suit> suit

Card> fourOfHearts = 4, Suit.Hearts

`
        Keywords

num
int
string
bool

primitive

enum

true
false

print
typeof
type

do
while
for
foreach
in

delete
export
`

`
        Reserved Variables

_args
    stores the command line arguments of the program

_argc
    contains the amount of command line arguments given

_params
    tuple containing each parameter of the current function

_paramc
    amount of parameters in the current function

_precision
    int containing the amount of decimal places to print 
    when printing a num
    
    default: 10
    min: 0
    max: 21

_G
    The global variable/function table.  Could be used to
    call a function name given the name as astring
    
    example:
        _G["myFunc"](var1, var2, ...)

`

`
        Reserved Functions
_init
    Can be declared within a class to be automatically called
    when creating a new instance of the class.

_add
    Can be declared within a class to be automatically called
    when adding two instances of the class.

_sub
    Can be declared within a class to be automatically called
    when subtracting two instances of the class.

_mul
    Can be declared within a class to be automatically called
    when multiplying two instances of the class.

_div
    Can be declared within a class to be automatically called
    when dividing two instances of the class.

_mod
    Can be declared within a class to be automatically called
    when getting the remainder of two instances of the class.

_pow
    Can be declared within a class to be automatically called
    when getting the power of two instances of the class.

_cnct
    Can be declared within a class to be automatically called
    when contatenating two instances of the class.

`
