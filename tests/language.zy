`
        Zy is an multi paradigm language which includes various elements from
    functional, imperative, and object oriented paradigms.  Each 
    line of zy code is a statement ending in a newline character.  Expressions 
    such as 3 * (4 + 5) may be part of a statement, but are not valid alone.
    Whitespace is also significant if it is at the beginning of a line.  Blocks
    are marked by an increase in indentation, and ended by an unindentation.
    An indentation is always either four spaces, or a single tab.

        Philosophy
    If something can be done compile time, then it should be.  In other words, 
    constant folding should be employed whenever possible.  If a 1500 line 
    program only produces the output "Hello World" then that will be the only 
    thing compiled into the binary.
`

`
    The following is an example of an import statement.  It is importing The
    modules math, io, str, op, and c_ffi which are some of the currently planned modules.
`
import "math", "io", "string", "op", "c_ffi"
`
    Arbitrary strings or string arrays, or even functions returning these values can be 
    imported as long as they can be resolved compile time.
`
import stuff()


~This is an example of a single line comment

`
        Variables
    Variables are declared with any modifiers (such as dyn to indicate a
    dynamic typing) followed by the variable's type and identifier in the 
    following syntax:
    
    [modifiers] [type] [identifier]
    
    Below is the declaration of a variable, myVar, with a dynamic typing,
    meaning it can be set to any value and its type will change accordingly.
    By default, dynamic variables are set to the int type.
`
dyn myVar
print(typeof(myVar)) ~output: dynamic i8

`
    types can also be assigned to variables, below are the primitive types
    initialized to their default values
`

i8  myI8  = 0
i16 myI16 = 0
i32 myI32 = 0
i64 myI64 = 0
u8  myU8  = 0
u16 myU16 = 0
u32 myU32 = 0
u64 myU64 = 0
f32 myF32 = 0.0
f64 myF64 = 0.0
str myStr = ""
bool myBool = false

`
    Any primitive value can also be typecasted to any other primitive type, or
    even completely redefined to that type.
`

print(i32 4.99)  ~output: 4
f32 n = 43.876
i32 n

~NOTE: the .. below is the string concat operator
print(typeof(n) .. " " .. n)  ~output: i32 43

`
        Operators
    Zy includes the following operators:

    binary:
        +  addition
        -  subtraction
        *  multiplication
        /  division
        %  remainder
        <  less than
        >  greater than
        <= less than or equal to
        >= greater than or equal to
        == equal to 
        != not equal to
        && logical and
        || logical or

    unary:
        -  negative
        !  not
        #  array length
        *  pointer dereference
        &  address of
`

`
        Arrays

    The syntax for declaring arrays is shown below.  The array arr
    declared below is an array of 30 integers, each initialized to 1

    The syntax for declaring an array is: 
        
        [type]\[size\] name

    NOTE: if size does not evaluate to an integer, the program will halt
          with a TypeMismatchError.  To avoid this, it is best to only use
          integer variables and constants in this expression.
`
i32[30] arr = 1

~Each element of an array can also be initialized individually
f32[5] assortedNums = 9, -76, 3.14159265, 2^8, 1 + 2*(6-3)

`
    Each element of an array can be accessed individually by index.  Negative
    indexes work backwards from the end of the array, so arr[-1] will always
    yield the last element of arr.
`
assortedNums[0] += assortedNums[1]
print(assortedNums[0] .. ", " .. assortedNums[-2])

~output: -67, 256

`
    The size of an array can also be dynamically edited.  The following syntax
    should always be used when expanding or restricting an array.
`
arr += 2
arr -= 3 ~Note: this will throw an exception if the array's size becomes < 0

`
        Tuples
    In addition to arrays, there are also tuples.  Unlike arrays, tuples can
    be mixed and matched with several types, but each must be stated beforehand.
`
i8, f32, str tup = 44, 44.0, "Fourty-four"

i8[30], str[2] anotherTuple = arr, ["This tuple contains", "two arrays"]

`
    This restriction does not apply when making a dynamic variable of course
`
dyn dynTuple = 46, "Fourty-six", 46.0

`
    When a tuple is printed, each of its values are individually printed, with
    parenthesis enclosing them all.
`
print(dynTuple)
~output: (46, Fourty-six, 46)

`
        Functions

    Functions in zy each have their own scope in addition to the scopes they
    inherit (in this case, only the global scope).  Variables created in
    functions are all local variables by default, however they can be
    exported into the global scope with the export keyword.

    Below is the declaration of a function, printMsg.  It takes no parameters
    and returns no value.  It is important to note that unlike many c based
    languages, blocks are denoted by changes in indentation rather than
    opening and closing brackets.
`
void printMsg:
    print("Hello World!")

`
    This add function takes in two parameters, augend and addend, and returns
    a num value.
`
f64 add: f64 augend, f64 addend
    return augend + addend

`
    Zy also has several reserved variables.  Variables with identifiers starting
    with an underscore are reserved and should not be manually assigned values.
    The function below takes in a variable amount of parameters, as denoted by
    the elipses.  Since _params always contains a tuple of each parameter of
    the function, all the params are passed to the print keyword, with an
    additional newline passed at the end.
`

void println: ...
    print(params, '\n')

`
    Here is the syntax for calling functions:
`
println("Test #", add(3, 43))
~output: Tuple(2: Test #, 46)

`
        Pathogen infections and Cleanse
    Pathogen is a modifier given to a function which can never be evaluated
    compile time.  Examples include io functions such as print and read.  When
    called within another function, the pathogen function infects that function
    as well, making it a pathogen function without the need to explicitely
    declare it as such.  The implicit pathogen function is said to be infected.
    The pathogen modifier is usually only used in rare cases such as defining your 
    own print function without utilizing the std api, or using an external c api.  
    While less common, the pathogen modifier may be used for variables, classes, enums, etc.
`
pathogen void myPrint: str msg
    i32 i = 4 + 2
    system("echo '" .. msg .. "'") ~note: system is already a pathogen function

pathogen void c_ffi("putchar"): u8

~Because the following function uses the pathogen myPrint, it cannot be
~eliminated from the final binary, it is said to be infected.
void printMsg:
    myPrint("Hello World!")

~To use a pathogen function without the host becoming infected, the keyword cleanse
~is used when calling a pathogen or infected function.  This compile time evaluation
~of pathogen functions can be useful in several applications, such as loading an image
~into a variable or class representing it without the need to search for it during runtime,
~and eliminating the need to include the raw image as an asset in production.
Image* compileTimeLoadImg:
    File *f = new File("path/to/image.png")
    u8[] data
    cleanse f.readAll(data) ~Reads all of the image data into data at compile time
    return new Image(data)

~Conversely, to infect a non-pathogen function, the infect keyword may be used.
~Note that only the infected instance of the function is evaluated during runtime.
Image* runTimeLoadImg:
    return infect compileTimeLoadImg()

`
        Ct
    The keyword ct is used to indicate control flow which is only to be
    evaluated at compile time, and should never be compiled.  Ct can be used
    for many things, including printing out a message during compile time,
    assuring a function argument is valid, checking for possible integer
    overflow, etc.  Additionaly, they have the power to throw a possible
    exception, stopping compilation immediately.
`

`
    The following function takes two parameters, and if m is negative, prints
    a hint to the programmer using the api during compilation.
    ~NOTE: a better method of ensuring m is positive is using the where
           statement discussed later.
`
f64 calculateForce: f64 m, f64 a
    ct
        if m < 0
            myPrint("calculateForce: mass cannot be negative!")
    return m*a

i8 add: i8 a, i8 b
    ct ~Only check for a possible overflow during compilation, otherwise just run with it
        i16 c = a
        i16 d = b
        if c + d > 255 or c + d < -256
            print("Likely integer overflow in add function.")
    return a + b

`
        C FFI
    The c foreign function interface is implemented within the c_ffi module.
`
import c_ffi("path/to/file.h", ["functions", "to", "import"])


~Or, every function can be imported using * as the filename.
import c_ffi("some/other/file.h", "*")

import c_ffi("stdio.h", "putchar")

putchar(90)
putchar(121)
putchar(10)
~output: Zy

`
        Loops

    Zy has four kinds of loops: while, do while, for, and foreach.
    The while loop runs while the following expression is true.  The do while
    loop runs once then runs while its following expression is true.  The for
    loop initializes a variable, runs while the expression surrounded by semicolons
    is true, then assigns a new value to a variable.  The foreach loop loops
    through each element of an array.
`
while true
    print("I loop forever")


do
    print("I only loop once")
while false

~prints 1-10
for i8 i = 1; i <= 10; i += 1
    print(i .. " ")

f32 total
foreach f32 n in arr
    total += n

`
        Ranges
    Ranges are created by the .. operator and are lazily evaluated by default.
    Since they can be used in expressions, they are often very useful, especially
    for foreach loops.
`

~Print 1 - 10 inclusive
foreach i32 i in 1..10
    print(i)

~print all odd numbers in the range of 1-19
foreach i32 i in 2*(1..10)-1
    print(i)
`
        The -> Symbol
    The -> symbol can be optionaly used at the end of statements expecting
    an indent to be replaced with an indent.  This is useful for compressing
    short statements into a single line.
`
if 5 > 2 -> print("5 is greater than 2")
else     -> print("Invalid laws of mathematics, please try again in an alternate universe")

foreach f32 f in arr -> print(f)

f32 subtract: f32 a, f32 b -> return a - b

~While these can be nested, too many on the same line can lead to clutter
class Integer -> pub i32 i   void _init: i32 a -> i = a

~compared to
class Integer
    pub i32 i

    void _init: i32 a
        i = a

`
        Embedded Statements
    Zy's normal syntax is <statement> [expression], but this can lead
    to some needlessly long functions.  One way to condense these
    functions is to use embedded statements.  Embedded statements are
    named as such becuase they are statements embedded within an
    expression.

    An embedded statement is always preceeded with an open bracket and 
    terminated with a matching closing bracket.  Unlike statements, 
    embedded statements need to return a value to be used in the expression,
    so the dynamic variable _ is used to modify this value.  If a return
    statement is encountered, it returns that value instead.  If _ is never
    assigned to within the embedded statement, _ = 0 by default.
`

`
    The following example uses an embedded statement to find the sum
    of each element of data array, and divide it by the number of
    elements in the array to find the mean on a single line.
`
f32 mean1: f32[] data
    return {foreach f32 n in data -> _ += n} / size(data)

`
    Without embedded statements, the above function would have
    taken up 3 additional lines of code.
`
f32 mean2: f32[] data
    f32 sum = 0
    foreach f32 n in data
        sum += n
    return sum / size(data)

`
    Embedded statements can also be used as a shortcut for
    assigning variables within an expression.

    In the following example, an integer i is incremented at
    each iteration of the loop. The conditional is evaluated 
    before each iteration of the loop, the numbers 1-100 are 
    printed, and the loop closes when i == 101
`
i8 i = 0
while {i += 1; return i} <= 100
    print(i)


`
        Structs
    Structs are a compound structure of data where a struct can contain multiple
    variables including arrays or objects.
`
struct Coord
    f64 x, y, z

~To create a struct, typecast a tuple containing the struct's members to the
~corresponding struct type.
Coord coord = Coord(100, -50, 66.7)
print(coord)  ~output: 100, -50, 66.7


`
        Classes
    Classes can be declared with the class keyword.  They each have their own
    namespace, and can have functions and variables declared within them.
    By default, variables declared within classes are private, while functions
    are public by default.
`

class Animal
    u16 age
    str species
    str name
`
    The _init function is a function that is automatically called when a class
    is initialized and the givin values match _init's parameters.  It can be
    thought of as the constructor for the class.
`
    void _init: u16, str, str
        age = _params[0]
        species = _params[1]
        name = _params[2]

    void printInfo:
        print(name .. " is a/an " .. species .. " and is " .. age .. " year(s) old.\n")

`
    To create an instance of the class, use the class name as the type of the
    variable, and the keyword new followed by the classname to be initialized 
    with the parameters of the _init function declared within the class.
`
Animal* clifford = new Animal(7, "magnum rubrum canis", "Clifford")


`
    Classes can also inherit from other classes with the : token.
`
class Person : Animal
    str job

    void _init: u16 age, str j, str name
        job = j
        super(age, "Homo sapien", name) ~super() calls the _init function from the parent class

`
    This function obscures the printInfo declared in the Animal super class.
`
    void printInfo:
        print(name .. " is " .. age .. " years old and is a(n) " .. job)


Person john = Person(44, "electrician", "John")
john.printInfo() ~output: John is 44 years old and is a(n) electrician

`
        Modifiers
    With classes comes the necessity for modifiers, such as the visibility
    modifiers pub, pro, and pri.  These are short for public, protected,
    and private respectively.  Another common modifier is const to declare
    a constant variable.

    Modifiers can be placed before a variable or function, or alternatively
    can be placed before a new block to modify everything within the block
`
class Statistics
    ~declare secretData as a private variable, only able to be accessed
    ~from within the class
    pri f64 secretData

    pro const f32 pi = 3.14159265
    
    pub i32 varCount

    ~Alternatively, you can also use modifiers before a block:
    pub
        f64 getData:
            return secretData ~not so secret anymore

        str getStatus:
            if secretData > 10
                return "Good"
            else
                return "Not so good"

    ~NOTE: by default, variables and methods are private so there is really 
    ~      no need to declare this function private explicitly.
    pri f64 doCalculations: f64 data
            return data * secretData / varCount

    ~NOTE: reserved functions such as _init and _mul do not need to be public
    ~      to be automatically called.
    void _init: i32[] data
        foreach i32 i in data
            secretData += data / pi
            varCount += 1

`
        Type Specifications, Where, and Operator Overloading
    Type specifications in zy are a powerful way to specialize a class or function
    to a specific usage.  In its most general case, it can be used in much the same
    way as generics or templates in other object oriented languages.  To declare a type
    specification for a class, parenthesis are used after the class name.  Within the
    parenthesis a type is binded to a name, and an optional boolean expression which
    must be able to be evaluated at compile time.  For functions, the keyword where is
    used followed by the name of the type in question and a boolean statment validating
    that the type is valid for the function.
`
~In this example, T is any type which has the operators > and < available or overloaded.
~For functions, the where keyword always comes at the end of the list of parameters.
~where statements are evaluated at compile time whenever possible.  If the expression after
~where evaluates to false, an error is thrown.
~NOTE: hasOps is an infix function, these will be shown later.
pub i32 cmp: T t2  where t2 hasOps ['>', '<']
    if self < t2 -> return -1
    return self > t2


~Here is the calculateForce function from earlier
f64 calculateForce: f64 m, f64 a
    ct
        if m < 0
            myPrint("calculateForce: mass cannot be negative!")

    return m*a

~and this is its equivilent using where
f64 calculateForce: f64 m, f64 a  where m >= 0
    return m*a

calculateForce(-54, 2)
`
Exception thrown when the where condition is not met:

function calculateForce: f64 m, f64 a requires the condition
m >= 0
which was not met for input value m = -54

`

~The syntax for type specifications in a class is somewhat similar.
~In the Angle class, each time it is initialized, a bool is specified as true if the
~angle is in radians, false otherwise.  This determines how Angle is compiled and
~cannot be changed after initialization.
class Angle<bool isRadians>
    f32 angle

    `
        If the _init function contains parameters with the same names as instance
        data for the class, then the instance data is automatically set equal
        to the parameter of the same name.
    `
    void _init: f32 angle

    if isRadians
        u8 getQuadrant:
            return angle / (3.14159265 / 4) % 4 + 1
    else
        u8 getQuadrant:
            return angle / 90 % 4 + 1
~usage:
Angle<true> a1 = Angle(3.14159265 * 2 / 3)
Angle<false> a2 = Angle(120)
assert(a1.getQuadrent() == a2.getQuadrent())

`
    The use of type specifications eliminates the need to store excess metadata about
    the object to be checked each time a function runs as well as encouraging classes
    to be more specialized without having several copies of otherwise very similar
    classes, eg. having a AngleDegrees and AngleRadians class seperate then having
    to worry about them interacting properly.  In this usage, type specifications
    act by creating a parent class Angle, and two child classes, Angle<true>, and
    Angle<False>, which correspond to AngleRadians and AngleDegrees.
`


`
    To use type specifications as generics, simply specify a type as a specification.
`
class MySmartPtr<type T>
    T* rawPtr

    void _init: T val
        rawPtr = alloc(val)
   
    void _init: T* rawPtr
    
    void _deinit:
        free(rawPtr)

    ~Note that to avoid ambiguity when overloading the unary * operator,
    ~deref can be used as the parameter for the op function.  If "*" is
    ~used, the only factor differentiating it from the binary * is that
    ~the unary * function does not take any parameters.
    T op("deref"):
        return *rawPtr

    T** op("&"):
        return &rawPtr

`
        Operator Overloading and Infix Functions
    Note that the cmp example above requires that the operator < is implemented for
    the two objects.  To do this we must implement operator overloading.  In the
    following example, the class Point is created and overloads the > and < operators,
    and creates the new infix function cmp for comparisons.
`
class Point
    pub i32 x, y

    void _init: i32 x, i32 y
        self.x = x
        self.y = y

    `
        Now to implement the < operator. Each operator is declared as a function 
        with the name generated by the function op which is imported from the 
        op module. This function requires the operator in question in string form.  Invalid
        operators will throw a compile-time error.  Note that since operators are declared
        within classes, operators for primitive datatypes cannot be redefined.
    `
    bool op('<'): Point rVal
        if x < rVal.x
            return 1
        return y < rVal.y

    bool op('>'): Point rVal
        if x > rVal.x
            return 1
        return y > rVal.y

    `
            Infix functions
    
        Infix functions are declared by calling the 'infix' function.  This
        function takes two parameters, the name of your function, and the
        precedence for use in expressions.  While precedence can be specified
        manually, it may be best to use the prec function to get the precedence
        of an existing operator to use.
    `

    ~An example of a generic comparison function
    ~Note that this function uses the > and < operators
    ~declared earlier in this class.
    i8 infix('cmp', prec('>')): Point rVal
        if this < rVal -> return -1
        return this > rVal


Point origin = Point(0, 0)
Point topRight = Point(3, 4)

print(origin < topRight)
print(origin > topRight)

print(origin cmp topRight)
`output
true
false
-1
5
`

`
        Class Extensions
    The ext keyword can be used to extend an already declared
    class with new methods, but no new instance data can be
    added.  A common usage of this would be extending an API
    to implement a function or inherent from your own parent
    class to better fit in with your class hierarchy.
`
ext Point : SomeAdditionalParentClass
    ~implement new methods
    bool op("=="): Point p2
        return this.x == p2.x && this.y == p2.y

`
        Pattern Matching
    Pattern matching can be accomplished with the match keyword.
    This attempts to match the input value to any valid type or
    value it comes across.  Each candidate is indented relative
    to the match keyword, and their associated statements are
    indented relative to themselves.  To save space for short
    statements, it is reccomended to use the -> token.
`

i8 testInt = 3
match testInt
    1 -> print("Yup, its one")
    2 -> print("It's actually two")
    3 -> print("Nope, it's three")
    4 .. 10 -> print("It's between 4 and 10 inclusive")
    _ -> print("It's not one, two, or three, or in the range 4-10")
~output: Nope, it's three

~In this example, match is used to determine Joe's class
Person joe = Person(32, "Programmer", "Joe")
match joe
    Point  -> print("Joe is a point")
    Animal -> print("Joe is an Animal")
    Person -> print("Joe is a Person")
    _      -> print("I don't know what Joe is")
~output: Joe is an Animal
~This is because the Person class inherits from the Animal
~class, so the Animal cast to joe was the first valid cast

struct String
    str s
    u32 len

String testStr = String("Test", 4)

match testStr
    String("Test", 3)
        print("This will not be matched")
    String("Testing", 4)
        print("This will not be matched either")
    String("Test", 4")
        print("This will be matched")

`
        Enums
    Declaring an enum declares a set of named constants. They are declared
    like normal variables with the type enum. Ints typecasted to an enum
    will become the constant that corresponds to the n-1 index of the enum where
    n is the value of the integer. Conversely, typecasting an enum to an int
    yields that enums placement in its declaration starting from 0. Typecasting 
    an enum to a string yields the name of the value.
`
~NOTE: -> is used for single-line statements that would normally require an indent.
enum Suit -> Diamonds, Hearts, Spades, Clubs

Suit spades = Suit.Spades
print(spades, " ", str spades)  ~output: 2 Spades

struct Card
    u8 number
    Suit suit

Card fourOfHearts = Card(4, Suit.Hearts)



`
        Pointers
    Pointers are created by adding an * after the datatype.
    Since pointers are considered part of the datatype, the
    syntax:
    
    type *name
    
    is not valid.
`


i32 five = 5
i32* ptrToFive = &five
~The unary & operator gets the location of the value 5

~The new keyword automatically allocates data for a class or struct
Card* tod = new Card(3, Suit.Diamonds)

~alternatively, data can be manually allocated.  The following is equivilent
~to the statement above
Card* tod = malloc(sizeof(Card))
*tod = Card(3, Suit.Diamonds)

~In addition to the malloc function from the c library, there is the alloc
~function which can fully allocate a pointer, and set it equal to a value.
Card* foh = alloc(Card(5, Suit.Hearts))

~Allocate example with size sizeof(5) and initialize it to the value 5
u8* example = alloc(5)

~Raw pointers must be manually freed with the free function
free(ptrToFive)
free(tod)
free(foh)

~For this reason, it is reccomended to instead use the ptr class which
~Has every relevant operator properly overloaded.
~The ptr class is automatically freed when it goes out of scope, and
~keeps track of the amount of references with little overhead.

u8 byte = 255
ptr<i32> pByte = ptr(byte)

ptr<i32> pByte2 = ptr(pByte)
pByte2 = 128

print(*pByte)

`
        Automatic dereferencing.
    When accessing a member function through a pointer to an object,
    dereferences are automatically added, eliminating the need for a
    seperate member accessor operator for pointers (-> in c like
    languages).
`
class PtrExample
    void printMsg:
        print("Hello World!")

PtrExample ex1 = PtrExample()
PtrExample* ex2 = new PtrExample()
PtrExample** ex3 = alloc(ex2)

ex1.printMsg() ~No pointer, so no dereferencing is necessary
ex2.printMsg() ~(*ex2).printMsg()
ex3.printMsg() ~(**ex3).printMsg()




~output: 128

`
        Function pointers
    To declare a function pointer, the following syntax is used:

    returnType(paramType1, paramType2, ...) name

    Notice the absence of the *, which is implied since it is not
    possible to store a function without a pointer to it.
`
~Some functions to point to:
f32 mul: f32 a, f32 b -> return a * b
f32 div: f32 a, f32 b -> return a / b

~This function takes one parameter, a function pointer 
~that takes two f32s and returns one as well.
f32 doOperation: f32 num, f32(f32, f32) opFunc
    return opFunc(6, 4)

~our function pointer
f32(f32, f32) fnPtr = mul

assert(doOperation(fnPtr) == 24)

fnPtr = div
assert(doOperation(fnPtr) == 1.5)



`
        Experimental
`
macro pstr: ident i
    pub const str i = "p"
    print(i)

macro or:  -> ||
macro and: -> &&

pstr(g)
~output: p

~possible new c_ffi syntax
pathogen void c_ffi("putchar"): u8

~lambda functions
lambda: i32 x -> return x + 50

~alternate c_ffi declaration
pathogen void* c_ffi("malloc"): u64 size

~possibly shorten pathogen to pgen
pgen void* c_ffi("malloc"): u64 size

~syntax change for type casts to distinguish them from declarations
f32 f = 7 as f32
f32 f = (f32)7
f32 f = f32 cast 7
f32 f = 7 cast f32

~threading and concurrency support
async void printMsg: str msg
    print(msg)

sync foreach i32 i in arr
    print(i)

f32 f = await someFunction()

~expanded usage of where as ternary operator
f32 f = x+2 where x > 0 else x-2

~alternate, more pythonic way
f32 f = x+2 if x > 0 else x-2


~Smart pointers by default, raw pointers made with raw modifier
raw i32* rawPtr = &3

~Is keyword/operator for matching types or values
assert(3 is i32)
assert(5 is 5)

~Type system for creating new types as a combination
~of others, as well as evaluating types as values.
type Coord = Coord2D || Coord3D
type Coord = Coord2D or Coord3D


`
        Keywords
primitive datatypes:
    i8
    i16
    i32
    i64
    u8
    u16
    u32
    u64
    f32
    f64
    str 
    bool 
    void

constants:
    true 
    false

statements:
    if 
    elif 
    else 
    import 
    match
    
loops: 
    for
    foreach 
    in 
    do 
    while
    continue 
    break

modifiers:
    pub 
    pri 
    pro 
    const 
    ext
    dyn

datatypes:
    class 
    struct 
    enum

other:
    where
`

`
        Unused Symbols
@
#
$
\
|
?

`


`
        Reserved Variables

_args
    stores the command line arguments of the program

_argc
    contains the amount of command line arguments given

_params
    tuple containing each parameter of the current function

_paramc
    amount of parameters in the current function
`

`
        Reserved Functions
_init
    Can be declared within a class to be automatically called
    when creating a new instance of the class.

_deinit
    Can be declared within a class to be automatically called
    when the class goes out of scope.
`
