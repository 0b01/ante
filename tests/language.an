`
        Ante is an multi paradigm language which includes various elements from
    functional, imperative, and object oriented paradigms.  Each 
    line of code is a statement ending in a newline character.  Expressions 
    such as 3 * (4 + 5) may be part of a statement, but are not valid alone.
    Whitespace is also significant if it is at the beginning of a line.  Blocks
    are marked by an increase in indentation, and ended by an unindentation.
    An indentation is always either four spaces, or a single tab.

        Philosophy
    If something can be done compile time, then it should be.  In other words, 
    constant folding should be employed whenever possible.  If a 1500 line 
    program only produces the output "Hello World" then that will be the only 
    thing compiled into the binary.
`

`
    The following is an example of an import statement.  It is importing The
    modules math, io, str, op, and c_ffi which are some of the currently planned modules.
`
import "math", "io", "string", "op", "c_ffi"
`
    Arbitrary strings, string arrays, or even functions returning these values can be 
    imported as long as they can be resolved compile time.
`
import stuff()


~This is an example of a single line comment

`
        Variables
    Variables are declared with any modifiers (such as dyn to indicate a
    dynamic typing) followed by the keyword let and the variables name as
    an identifier.  It is important to note that identifiers must begin
    with a lowercase letter, but can contain any amount of capital and lowercase
    letters or numbers afterwards.  The type is inferred from the expression in
    most cases.  This form can be expressed as the following:

    let [modifiers] [identifier] = [expr]

    Alternatively, if the variable is mutable, the type must be specified.  Note
    that since it is not immutable, its initial value does not have to be
    specified.  All variables by default have their memory set to 0.  In
    cases where speed is more of a concern, the modifier noinit may be
    specified to avoid this.

    [modifiers] [type] [identifier]

    In the rare cases when a constant variable's type cannot be inferenced,
    the following form is used:

    let [modifiers] [type] [identifier] = [expr]

    or:

    const [modifiers] [type] [identifier] = [expr]
`

~Declare i, an i8 since integer constants take the smallest type by default.
let ex1 = 1

~There are several ways to specify a type if it is needed
~The type can be stated before the variables name:
let i32 ex2 = 2

~Or the type of the constant can be specified:
let ex3 = 3i32

~Or the constant can be typecasted to an i32:
let ex4 = i32 4

`
    Types can also be assigned to variables manually.  Variable's declared
    without let are mutable by default and must have their type explicitely
    stated.  Below are mutable variables of every primitive type initialized 
    to their default values.
`

i8  myI8  = 0    ~8bit integer
i16 myI16 = 0
i32 myI32 = 0
i64 myI64 = 0

u8  myU8  = 0    ~8bit unsigned integer
u16 myU16 = 0
u32 myU32 = 0
u64 myU64 = 0

isz myIsz = 0    ~Signed pointer size integer
usz myUsz = 0    ~Unsigned pointer size integer

f32 myF32 = 0.0  ~32bit float
f64 myF64 = 0.0

c8  myC8  = ''   ~ASCII char 0x00
c32 myC32 = ''   ~UTF-32 char 0x00

bool myBool = false

`
    Any primitive value can also be typecasted to any other primitive type, or
    even completely redefined to that type.
`

print(i32 4.99)  ~output: 4
f32 n = 43.876
i32 n = i32 n

print(typeof(n) ++ " " ++ n)  ~output: i32 43

`
        Modifiers
    Modifiers are optionally included in a variable or function
    definition.  The available modifiers are:

    pub        Most inclusive visibility modifier
    
    pro        Visibility modifier
    
    pri        Least inclusive visibility modifier
    
    const      Declares a constant variable.  Unlike
               a let statement, this assures a space
               is allocated in memory rather than
               using expression substitution.
    
    pathogen   Specifies a variable or function can
               never be evaluated at compile time.
    
    dyn        Specifies a variable which can change type.
    
    noinit     Specifies a variable should not have
               its memory cleared.
`
noinit c32[13] myMsg
myMsg = "Hello World!" ~Char 13 is \0

dyn dynVar = "Test Number"
dynVar = 32

pub dyn noinit u8[] buf = 3, 4, 5


`
        Constants
    Ante includes integer constants, float
    constants, char constants and string
    constants.  Integer and float constants
    assume the type of the smallest type they
    can fit in.  Integer and float constants
    can alternatively have their type specified
    with a suffix.
`
print(typeof(0))      ~output: i8
print(typeof(0u8))    ~output: u8
print(typeof(0i64))   ~output: i64
print(typeof(255))    ~output: u8
print(typeof("test")) ~output: c8[]
print(typeof('A'))    ~output: c8


`
        Operators
    Ante includes the following operators:

    binary:
        +  addition
        -  subtraction
        *  multiplication
        /  division
        %  remainder

        .. inclusive range
        ^. exclusive startpoint range
        .^ exclusive endpoint range
        ^^ exclusive range

        ++ append

        <  less than
        >  greater than
        <= less than or equal to
        >= greater than or equal to
        == equal to 
        != not equal to
        && logical and
        || logical or

    unary:
        -  negative
        !  logical not
        *  pointer dereference
        &  address of
        $  type of
`

`
        Arrays

    The syntax for declaring arrays is shown below.  The array arr
    declared below is an array of 30 integers, each initialized to 1

    The syntax for declaring an array is: 
        
        [type]\[size\] name

    NOTE: if size does not evaluate to an integer, the program will halt
          with a TypeMismatchError.  To avoid this, it is best to only use
          integer variables and constants in this expression.
`
i32[30] arr = 1

~Each element of an array can also be initialized individually
f32[5] assortedNums = 9, -76, 3.14159265, 2^8, 1 + 2*(6-3)

`
    Each element of an array can be accessed individually by index.  Negative
    indexes work backwards from the end of the array, so arr[-1] will always
    yield the last element of arr.
`
assortedNums[0] += assortedNums[1]
print(assortedNums[0] ++ ", " ++ assortedNums[-2])
~output: -67, 256

`
    Array initializer lists can also be surrounded by [ and ].  This is preferable
    when dealing with multidimensional arrays or tuples.
`
i32[2][2] box = [1, 2], [3, 4]


`
    The size of an array can also be dynamically edited.  The following syntax
    should always be used when expanding or restricting an array.
`
arr += 2
arr -= 3 ~Note: this will throw an exception if the array's size becomes < 0

`
        Tuples
    In addition to arrays, there are also tuples.  Unlike arrays, tuples can
    be mixed and matched with several types, but each must be stated beforehand.
`
i8, f32 tup = 44, 44.0

~NOTE: c32*[2] is an array of two strings, each having a char size of 32.
i8[30], c32*[2] anotherTuple = arr, ["This tuple contains", "two arrays"]

`
    This restriction does not apply when making a dynamic variable of course
`
dyn dynTuple = 46, "Fourty-six", 46.0

~A pointer to a tuple
(i32, i32)* tupPtr = &(0, 0)

`
    When a tuple is printed, each of its values are individually printed, with
    parenthesis enclosing them all.
`
print(dynTuple)
~output: (46, Fourty-six, 46)

`
        Functions

    Functions in ante each have their own scope in addition to the scopes they
    inherit (in this case, only the global scope).  Variables created in
    functions are all local variables by default, however they can be
    exported into the global scope with the export keyword.

    Below is the declaration of a function, printMsg.  It takes no parameters
    and returns no value.  It is important to note that unlike many c based
    languages, blocks are denoted by changes in indentation rather than
    opening and closing brackets.
`
void printMsg:
    print("Hello World!")

`
    This add function takes in two parameters, augend and addend, and returns
    a num value.
`
f64 add_floats: f64 augend, f64 addend
    return augend + addend

~Multiple variables of the same type can be declared by omitting the , and repeated type
f64 add_floats_2: f64 augend addend
    return augend + addend

`
    Ellipses can be used in place of or after a type to indicate that the
    function takes a variable amount of arguments.  The variable it is assigned
    to is a tuple by default, but if a type is specified before the ellipses, it
    becomes an array of that type.  If a function takes a variable amount of
    parameters, ... can only be the last parameter.  In the lnprint function below, 
    params is passed to the print function, with an additional newline passed at 
    the beginning.
`
void lnprint: ... params
    print('\n', params)


~In most cases, an array should be used if the specific type is known
i64 sum: i32... nums
    i64 ret = 0
    for i32 i in nums
        ret += i
    return ret

`
    The syntax for calling functions is the same as in C based languages:
`
lnprint("Test #", add(3, 43), sum(3, 4, 5))
~output: 
~Test #, 46, 12

`
        Pathogen infections and Cleanse
    Pathogen is a modifier given to a function which can never be evaluated
    compile time.  Examples include io functions such as print and read.  When
    called within another function, the pathogen function infects that function
    as well, making it a pathogen function without the need to explicitely
    declare it as such.  The implicit pathogen function is said to be infected.
    The pathogen modifier is usually only used in rare cases such as defining your 
    own print function without utilizing the std api, or using an external c api.  
    While less common, the pathogen modifier may be used for variables, classes, enums, etc.
`
pathogen void myPrint: c32* msg
    i32 i = 4 + 2
    system("echo '" ++ msg ++ "'") ~note: system is already a pathogen function

~Because the following function uses the pathogen myPrint, it cannot be
~eliminated from the final binary, and is said to be infected.
void printMsg:
    myPrint("Hello World!")

~To use a pathogen function without the host becoming infected, the keyword cleanse
~is used when calling a pathogen or infected function.  This compile time evaluation
~of pathogen functions can be useful in several applications, such as loading an image
~into a variable or class representing it without the need to search for it during runtime,
~and eliminating the need to include the raw image as an asset in production.
Image* compileTimeLoadImg:
    File *f = new File("path/to/image.png")
    u8[] imgData
    cleanse f.readAll(imgData) ~Reads all of the image data into data at compile time
    return new Image(imgData)

~Conversely, to infect a non-pathogen function, the infect keyword may be used.
~Note that only the infected instance of the function is evaluated during runtime.
Image* runTimeLoadImg:
    return infect compileTimeLoadImg()

~Values can also be infected if set equal to the return value of a pathogen function
Image* myImg = runTimeLoadImg()
someFunction(myImg) ~This instance of someFunction is infected since an infected parameter is used.


`
        Ct
    The keyword ct is used to indicate control flow which is only to be
    evaluated at compile time, and should never be compiled.  Ct can be used
    for many things, including printing out a message during compile time,
    assuring a function argument is valid, checking for possible integer
    overflow, etc.  Additionaly, they have the power to throw a possible
    exception, stopping compilation immediately.
`

`
    The following function takes two parameters, and if m is negative, prints
    a hint to the programmer during compilation.
    ~NOTE: a better method of ensuring m is positive is using the where
           statement discussed later.
`
f64 calculateForce: f64 m, f64 a
    ct
        if m < 0
            myPrint("calculateForce: mass cannot be negative!")
    return m*a

i8 add: i8 a, i8 b
    ct ~Only check for a possible overflow during compilation, otherwise just run with it
        i16 c = a
        i16 d = b
        if c + d > 255 or c + d < -256
            print("Likely integer overflow in add function.")
    return a + b


`
        C FFI
    The c foreign function interface is implemented within the c_ffi module.
`
import c_ffi("path/to/file.h", ["functions", "to", "import"])


~Or, every function can be imported using * as the filename.
import c_ffi("some/other/file.h", "*")

import c_ffi("stdio.h", "putchar")

putchar(72)
putchar(105)
putchar(10)
~output: Hi

`
        Loops

    Ante has three kinds of loops: while, do while, and for.
    The while loop runs while the following expression is true.  The do while
    loop runs once then runs while its following expression is true.  The for 
    loop loops through each element of an array or range.
`
while true
    print("I loop forever")


do
    print("I only loop once")
while false

f32 total
for f32 n in arr
    total += n

`
        Ranges
    Ranges are created by any of the four range operators: .. ^. .^ and ^^
    Each of these operators differ in their exclusivity.  Since they can be 
    used in expressions, they are often very useful, particularly in for loops.
`

~Print 1 to 10 inclusive
for i32 i in 1..10
    print(i)

~print all odd numbers in the range of 1-19
for i32 i in 2*(1..10)-1
    print(i)

~To double the range without also doubling the step, just double the endpoint
~print all numbers from 1-20 inclusive
for i32 i in 1 .. 2*10 
    print(i)

~Loop through each index in the array
for i32 i in 0 .^ size(array)
    print(array[i])

`
    .. inclusive range
    .^ exclusive endpoint
    ^. exclusive startpoint
    ^^ exclusive range
`

i32[10] naturalNums

range r = 0 .^ 10

for i32 i in r
    naturalNums[i] = i+1


`
        -> and ;;
    -> and ;; can be used to manually insert indent and unindent tokens
    respectively.  -> is commonly used in single line blocks, but ;; is much
    more rare, being added to simplify the declaration of enums within a data
    declaration with multiple fields.  Both -> and ;; change the indentation level
    in addition to issuing the token.  Doing so with -> ensures an unindent token
    is automatically issued once a statement is encountered on the same line as
    the one containing the ->.  With a ;; an Unindent is introduced followed by
    an Indent if the next statement returns to the normal level.
`
if 5 > 2 -> print("5 is greater than 2")
else     -> print("Invalid laws of mathematics, please try again in an alternate universe")

for f32 f in arr -> print(f)

f32 subtract: f32 a, f32 b -> return a - b

~While these can be nested, overnesting should be avoided as it leads to clutter.
data Integer -> i32 i, void _init: i32 a -> i = a;; u8 byte

~compared to
data Integer
    i32 i

    void _init: i32 a
        i = a

    u8 byte

`
        Data declarations
    In ante, all datatypes are declared through the data keyword by mixing and matching
    previously declared types.  The data keyword expects the name of the datatype afterwards 
    followed by a block of type expressions and an optional name for each field.  Without 
    naming each field, that field can be indexed like a tuple.
`

~Declare coord, a datatype consisting of three f64s named x, y, and z.
~NOTE: multiple variables of the same type can be declared by seperating the names with spaces.
~      if an = is encountered afterwards, each of the variables will be set to that value.
data Coord
    f64 x y z

~Declare char, a datatype that can contain an ASCII or UTF-32 char
data char
    c8|c32 c

char ch = 'a'
assert(ch.c is c32)

~Each newline is equivilent to a , and signals a tuple type.
data Coord2D
    f32 x
    f32 y

~Anonymous fields can be declared simply by neglecting to give each field a name.  Anonymous
~fields can only be accessed with [], and are essentially aliased tuples.
data Q1Coord
    u32
    u32

Q1Coord myQ1C = 2, 3
print(myQ1C[1]) ~output: 3

~Each datatype containing more than one field is internally represented by a tuple, so they
~Can be created in a similar fashion.
Coord coord = 100, -50, 66.7
print(coord.y)  ~output: -50

~To access a specific field of an anonymous datatype in an expression, it must be casted to
~the desired type.
f64 y = Coord(100, -50, 66.7).y

~Set p1 p2 and p3 to 0, 0
i32,i32 p1 p2 p3 = 0, 0

`
        Classes
    Class-like data structures can be declared by simply including methods within the
    data declaration.  These methods are associated methods and do not add to the size of
    the datatype, but are linked to it at compile-time.  These methods are each within a namespace
    that is the name of the datatype, but cannot be accessed without an initialization of the
    datatype if they take self as a parameter.
`
data Animal
    u16 age
    c8* species
    c8* name

`
    Create a static function init that creates a new instance of an animal.
`
    Animal init: u16 age, c8* species name
        return Animal(age, species, name)
        
`
    Create a non-static method taking self as a parameter.  This function cannot be used as 
    Animal.printInfo, it must be called on a previously initialized Animal.
`
    void printInfo: self
        print(self.name .. " is a/an " .. self.species .. " and is " .. self.age .. " year(s) old.\n")

`
    The new keyword can be used to allocate and initialize memory to be stored in a
    pointer type.
`
Animal* clifford = new Animal.init(7, "magnum rubrum canis", "Clifford")


`
    Datatypes can also inherit from other datatypes with the : operator.
`
data Person : Animal
    c8* job

    Person init: u16 age, c8* job name
        Person ret = Animal.init(age, "Homo sapien", name)
        ret.job = job
        return ret

`
    This function obscures the printInfo declared in the Animal type.
`
    void printInfo: self*
        print(self.name .. " is " .. self.age .. " years old and is a(n) " .. self.job)


`
    Methods of the same name can also be overloaded if they take different amounts or types of variables.
`
    void printInfo: self*, bool showAge
        if showAge
            print(self.name .. " is " .. self.age .. " years old and is a(n) " .. self.job)
        else
            print(self.name .. " is a(n) " .. self.job)


Person john = Person.init(44, "electrician", "John")
john.printInfo() ~output: John is 44 years old and is a(n) electrician

`
        Modifiers
    Modifiers modify the behaviour of a particular instance of a variable, and 
    are listed before its type.  The visibility modifiers pub, pro, and pri are 
    short for public, protected, and private respectively.  Pri variables can only
    be accessed by associated methods within the data declaration or impls.  Pub 
    variables are the default and can be accessed from anywhere.  Pro variables can
    be accessed by the datatype and any inheriting datatypes.  Another common modifier 
    is const to declare a constant variable.

    Modifiers can be placed before a variable or function, or alternatively
    can be placed before a new block to modify everything within the block
`
data Statistics
    ~declare secretData as a private variable, only able to be accessed
    ~from within member functions (methods).
    pri f64 secretData

    pro const f32 pi = 3.14159265
    
    pub i32 varCount

    ~Alternatively, you can also use modifiers before a block:
    pub
        f64 getData: self*
            return self.secretData ~not so secret anymore

        c8* getStatus: self*
            if self.secretData > 10
                return "Good"
            else
                return "Not so good"

    pri f64 doCalculations: self*, f64 mData
            return mData * self.secretData / self.varCount

    ~Because the init function is declared within the datatype, it can access private members.
    Statistics init: i32[] mData
        Statistics ret = `secretData =`0, `varCount =`0
        for i32 i in mData
            ret.secretData += mData / ret.pi
            ret.varCount += 1
        return ret

`
        Type Specifications, Generics, Where, and Operator Overloading
    Type specifications in ante are a powerful way to specialize a class or function
    to a specific usage.  In its most general case, it can be used in much the same
    way as generics or templates in other object oriented languages.  To declare a type
    specification for a class, parenthesis are used after the class name.  Within the
    parenthesis a type is binded to a name, and an optional boolean expression which
    must be able to be evaluated at compile time.  For functions, the keyword where is
    used followed by the name of the type in question and a boolean statment validating
    that the type is valid for the function.
`
~For functions, the where keyword always comes at the end of the list of parameters.
~where statements are evaluated at compile time whenever possible.  If the expression after
~where evaluates to false, an error is thrown.
const c32[][] actions = "walk", "talk", "stand"

c32[] getAction: u8 action  where action >= 0 && action <= 3
    return actions[action]


~Here is the calculateForce function from earlier
f64 calculateForce: f64 m, f64 a
    ct
        if m < 0
            myPrint("calculateForce: mass cannot be negative!")

    return m*a

~and this is its equivilent using where
f64 calculateForce: f64 m, f64 a  where m >= 0
    return m*a

calculateForce(-54, 2)
`
Exception thrown when the where condition is not met:

function calculateForce: f64 m, f64 a requires the condition
m >= 0
which was not met for input value m = -54
`

`
        Generic Functions
    Generic Functions can be a powerfull tool to recompile a function for a given
    argument (usually a type) during compile time.  Generic parameters are specified
    between < and > after the function's name.
`
~Generics can be explicit
bool greater<type T>: T t1, T t2
    return t1 > t2

~Or implicit and raise an error if the given parameter is not valid.
bool cmp<T>: T t1, T t2
    if t1 < t2 -> return -1
    return t1 > t2

cmp(3, 4) ~valid
cmp((1, 2, 3), (4, 5, 6)) ~invalid: tuple i32[3] type is not valid for operator <
cmp(3, "three") ~invalid: types must be the same for function cmp


~The syntax for type specifications in a class is somewhat similar.
~In the Angle class, each time it is initialized, a bool is specified as true if the
~angle is in radians, false otherwise.  This determines how Angle is compiled and
~cannot be changed after initialization.
data Angle<bool isRadians>
    f32 angle

    if isRadians
        u8 getQuadrant: self
            return angle / (3.14159265 / 4) % 4 + 1
    else
        u8 getQuadrant: self
            return angle / 90 % 4 + 1
~usage:
Angle<true> a1 = 3.14159265 * 2 / 3
Angle<false> a2 = 120
assert(a1.getQuadrent() == a2.getQuadrent())

`
    The use of type specifications eliminates the need to store excess metadata about
    the object to be checked each time a function runs as well as encouraging classes
    to be more specialized without having several copies of otherwise very similar
    classes, eg. having a AngleDegrees and AngleRadians class seperate then having
    to worry about them interacting properly.  In this usage, type specifications
    act by creating a parent class Angle, and two child classes, Angle<true>, and
    Angle<False>, which correspond to AngleRadians and AngleDegrees.
`


`
    To use type specifications as generics, simply specify a type as a specification.
`
data MySmartPtr<type T>
    T* rawPtr
    bool owner

    void op("new"): T val
        rawPtr = alloc(val)
        owner = true

    void op("drop"):
        if owner
            free(rawPtr)

    MySmartPtr<T> trait("clone"): self
        MySmartPtr<T> clone = self
        clone.owner = false
        return clone

    ~Note that to avoid ambiguity when overloading the unary * operator,
    ~deref can be used as the parameter for the op function.  If "*" is
    ~used, the only factor differentiating it from the binary * is that
    ~the unary * function does not take any parameters.
    T op("deref"):
        return *rawPtr

    T** op("&"):
        return &rawPtr

~where can also be used to check the type specification
data ChessPiece<String piece> where searchFor(piece, ["pawn", "knight", "king"]) != -1
    u8 x
    u8 y
    
    ChessPiece<piece> init: u8 x, u8 y
        return ChessPiece<piece>(x, y)
    
    if piece == "pawn" 
        bool validateMove: u8 x2, u8 y2
            return x == x2 && abs(y - y2) == 1

    elif piece == "knight"
        bool validateMove: u8 x2, u8 y2
            if abs(x - x2) == 1
                return abs(y - y2) == 2
            return abs(x - x2) == 2 && abs(y - y2) == 1
    
    elif piece == "king"
        bool validateMove: u8 x2, u8 y2
            return abs(x - x2) <= 1 && abs(y - y2) <= 1


ChessPiece<"knight"> knight = ChessPiece(2, 3)
assert(validateMove(3, 5))

`
        Operator Overloading and Infix Functions
    Note that the cmp example above requires that the operator < is implemented for
    the two objects.  To do this we must implement operator overloading.  In the
    following example, the class Point is created and overloads the > and < operators,
    and creates the new infix function cmp for comparisons.
`
data Point
    pub i32 x, y

    `
        Now to implement the < operator. Each operator is declared as a function 
        with the name generated by the function op which is imported from the 
        op module. This function requires the operator in question in string form.  Invalid
        operators will throw a compile-time error.  Note that since operators are declared
        within classes, operators for primitive datatypes cannot be redefined.
    `
    bool op('<'): self, Point rVal
        if self.x < rVal.x
            return 1
        return self.y < rVal.y

    bool op('>'): self, Point rVal
        if x > rVal.x
            return 1
        return y > rVal.y

    `
            Infix functions
    
        Infix functions are declared by calling the 'infix' function.  This
        function takes one parameter, the name of your function.  The precedence
        of an infix function is extremely high, as if both parametrs were surrounded
        by parenthesis.  The example  4^6 plus 3%9 would be parsed as (4^(6 plus 3))%9
    `

    ~An example of a generic comparison function
    ~Note that this function uses the > and < operators
    ~declared earlier in this class.
    i8 infix('cmp'): self, Point rVal
        if self < rVal -> return -1
        return self > rVal


Point origin = 0, 0
Point topRight = 3, 4

print(origin < topRight)
print(origin > topRight)

print(origin cmp topRight)
`output
true
false
-1
5
`

`
        Implementations
    The impl keyword can be used to extend any type with additional methods, 
    but no new instance data can be added for congregate datatypes.  A common 
    usage of this would be extending an API to implement a function or even inherit
    from an additional parent class as long as it has no instance data.
`
impl Point : SomeAdditionalTrait
    ~implement new methods
    bool op("=="): self, Point p2
        return self.x == p2.x && self.y == p2.y

impl thing : Drawable<S>

~Implementations can also be used for primitive types
impl i32, i32
    void swap: self
        i32 tmp = self[0]
        self[0] = self[1]
        self[1] = tmp

trait Drawable<S>
    void draw: self*, S surface
    
    void clear: self*

    void useColor: u32 r g b

    void useSurface: self*, S surface
        self.surface = surface

    S getSurface: self*
        return self.surface

i32, i32 point = (3, 4).swap()
assert(point[0] == 4 && point[1] == 3)

~The only limitation on implementations is that it cannot be used for pointer types.
~Pointers will be automatically dereferenced if their dereferenced type has a valid
~implementation, otherwise a compilation error will result.

impl c32* ~invalid
    c32* addInitials: self
        return self .. " -JF"

impl c32[] ~valid
    c32[] addInitials: self
        return self .. " -JF"


c32* ptrQuote = "implementations cannot be used for pointer types"
 
~Compilation error since c32 has no function addInitials:
ptrQuote = ptrQuote.addInitials()

c32[] ptrQuote ~convert to array
ptrQuote.addInitials() ~valid

`
    NOTE: because string literals have the type c32[], the following is valid:

    c32* ptrQuote = "implementations cannot be used for pointer types".addInitials()
`


`
        Pattern Matching
    Pattern matching can be accomplished with the match keyword.
    This attempts to match the input value to any valid type or
    value it comes across.  Each candidate is indented relative
    to the match keyword, and their associated statements are
    indented relative to themselves.  To save space for short
    statements, it is reccomended to use the -> token.
`

i8 testInt = 3
match testInt
    1 -> print("Yup, its one")
    2 -> print("It's actually two")
    3 -> print("Nope, it's three")
    4 .. 10 -> print("It's between 4 and 10 inclusive")
    _ -> print("It's not one, two, or three, or in the range 4-10")
~output: Nope, it's three

~In this example, match is used to determine Joe's class
Person joe = Person(32, "Programmer", "Joe")
match joe
    Point  -> print("Joe is a point")
    Animal -> print("Joe is an Animal")
    Person -> print("Joe is a Person")
    _      -> print("I don't know what Joe is")
~output: Joe is an Animal
~This is because the Person class inherits from the Animal
~class, so the Animal cast to joe was the first valid cast

data MyString
    c32* s
    u32 len

MyString testStr = "Test", 4

match testStr
    MyString("Test", 3)
        print("This will not be matched")
    MyString("Testing", 4)
        print("This will not be matched either")
    MyString("Test", 4")
        print("This will be matched")


~Match can also be used in expressions
c32* s = match 2
    0 -> "zero"
    1 -> "one"
    2 -> "two"
    _ -> "other"
`
        Enums
    Where data declares a named type, enums declare named
    values.  The values declared are represented by integers
    internally.  The specific integer for each value can also
    be manually set using the assignment operator.
    
    The values within an anonymous enum are exported into the global
    namespace.  Values within a named enum are exported under
    the namespace of the same name.

    Note that since enums only declare named values, they do
    not yet have an associated type, but can still be used
    as integers.  To declare a type, use a data declaration
    in combination with an enum.

    Indentation is required after the enum keyword in an anonymous enum,
    or after its name in a named enum.
`

~Export each suit into the namespace Suit
~NOTE: since Suit is not declared as data, it is not its own type.
enum Suit -> Diamonds, Hearts, Spades, Clubs

print(Suit.Spades)  ~output: 2

data Card
    u8 number
    i32 suit

Card fourOfHearts = 4, Suit.Hearts
i32 suit = (Card(3, Suit.Hearts)).suit
~Enums are automatically assigned values, but can also be manually assigned with the
~ = operator after the first operand.  Each consecutive member will have a value equal
~ to its distance from the fist + the first's value.
enum Numbers
    One   = 1
    Two~  = 2 (inferred)
    Three~= 3
    Four~ = 4
    Five~ = 5

~   number = 3
i32 number = Three

~Alternatively, if the first and second's value are given then each consecutive member
~Is incremented by their difference instead of 1.
~Note the double indentation after enum.  The -> after EvenNumbers increments the
~indentation level by 1, and enum requires another.
data EvenNumbers -> enum
        Two = 2
        Four = 4
        Six~ = 6
        Eight~ = 8, and so on
        Ten, Twelve, Fourteen

~           evenNumber = 12
EvenNumbers evenNumber = EvenNumbers.Twelve

`
        Pointers
    Pointers are created by adding an * after the datatype.
    Since pointers are considered part of the datatype, the
    syntax [type] *[name] is not valid.
`


i32 five = 5
i32* ptrToFive = &five
~The unary & operator gets the location of the value 5

~The new keyword automatically allocates data for a class or struct and calls its
~constructor if it has one.
Card* tod = new Card(3, Suit.Diamonds)

~alternatively, data can be manually allocated.  The following is equivilent
~to the statement above
Card* tod = malloc(sizeof(Card))
*tod = Card(3, Suit.Diamonds)

~In addition to the malloc function from the c library, there is the alloc
~function which can fully allocate a pointer, and set it equal to a value.
Card* foh = alloc(Card(5, Suit.Hearts))

~Allocate example with size sizeof(5) and initialize it to the value 5
u8* example = alloc(5)

~Raw pointers must be manually freed with the free function
free(ptrToFive)
free(tod)
free(foh)

~For this reason, it is reccomended to instead use the ptr class which
~Has every relevant operator properly overloaded.
~The ptr class is automatically freed when it goes out of scope, and
~keeps track of the amount of references with little overhead.

u8 byte = 255
ptr<i32> pByte = ptr(new byte)

ptr<i32> pByte2 = ptr(new pByte)
pByte2 = 128

print(*pByte)

~Pointers are also used to create strings as char arrays
~Since there are multiple sizes of chars, the dfeault
~encoding (from single byte to 4 byte UTF-8) can be specified.
~The default encoding for string literals is 4 byte UTF-8
c32* str = "Hello World!"
c8[] msg = "Condensed String"

`
        Automatic dereferencing.
    When accessing a member function through a pointer to an object,
    dereferences are automatically added, eliminating the need for a
    seperate member accessor operator for pointers (-> in c like
    languages).
`
data PtrExample
    c8[] msg

    void printMsg:
        print(msg)

PtrExample ex1 = msg
PtrExample* ex2 = new ex1
PtrExample** ex3 = new ex2

ex1.printMsg() ~No pointer, so no dereferencing is necessary
ex2.printMsg() ~(*ex2).printMsg()
ex3.printMsg() ~(**ex3).printMsg()

`
        Pointers and Arrays
    Internally, pointers are stored the same way as arrays.
    They only differ based on the operators used on them.  Conversions
    between array and pointer are zero cost, they simply change how they
    interact with operators or impls.
`

~Both of these strings are stored as pointers to the first c32.
c32*  ptrStr = "str"
c32[] arrStr = "str"

`
    += operator
    
    Pointers:
        increments the address pointed to by b bytes, where b
        is the integer result of the evaluated expression.  
    Arrays:
        expands the array by b additional indexes.  Each index is
        uninitialized and will contain garbage data.
`
ptrStr += 1
arrStr += 1

`
    [] operator

    Same behaviour in pointers and arrays.  Fetches the element 
    at address pointer + b*sizeof(element), where b is the integer
    expression evaluated between [ and ].  Bounds checking is
    not employed at runtime for either.
`
assert(ptrStr[0] == arrStr[0])

`
    Implementations

    Pointers:
        In order to preserve auto dereferencing, impls cannot be declared
        for arbitrary pointer types.

    Arrays:
        Impls are perfectly valid for array types, including arrays of
        pointer types, despite sharing the same structure in memory.  
        To use array impls with a pointer, the pointer should be casted 
        to an array type.
`
impl c32[]
    void reverse: self, u32 len
        c32[] rev = malloc((len+1) * 4)
        for u32 i in len ^. 0
            rev[i] = this[len-i-1]
        self = rev

arrStr.reverse() ~valid

`
ptrStr.reverse()  <- compilation error.  To make this work, a cast should be added

c32[] ptrStr
ptrStr.reverse

`

`
        Function pointers
    To declare a function pointer, the following syntax is used:

    returnType(paramType1, paramType2, ...) name

    Notice the absence of the *, which is implied since it is not
    possible in ante to store a function on the stack.
`
~Some functions to point to:
f32 mul: f32 a, f32 b -> return a * b
f32 div: f32 a, f32 b -> return a / b

~This function takes one parameter, a function pointer 
~that takes two f32s as parameters and returns one as well.
f32 doOperation: f32(f32, f32) opFunc
    return opFunc(6, 4)

~our function pointer
f32(f32, f32) fnPtr = mul

assert(doOperation(fnPtr) == 24)

fnPtr = div
assert(doOperation(fnPtr) == 1.5)


`
        Algebraic datatypes
    Algebraic datatypes can be declared with the type keyword.
    Any other type can be combined to form an algebraic types.
    The | operator indicates that the type can be either the
    preceeding or the proceeding type.  To combine types in
    an and fashion, tuples can be used.

`

~declare a type str that can be a char pointer of any size
data str -> c8* | c32*

~declare a type coord that can be an integer or float tuple
~NOTE: the precedence of | is greater than that of ,
data coord -> (i32, i32) | (f64, f64)

data Maybe<T>
    T | enum -> None

~declare a list type that is a tuple with two indices, the first
~being the value type, and the second being the next List node.
data tList<type T> -> T, Maybe<List<T>*>

~alternatively, type declarations can name each member of the
~tuple, mimicking a struct.
data List<type T>
    T val
    Maybe<List<T>*> next

data Vec<T>
    T[] mem
    u32 len
    u32 cap

List<u8> numsList = 1, &(2, &(3, None)))

`
        Multiline expressions/statements
    Expressions are normally terminated by a newline
    character, but can be extended by adding a backslash
    right before the newline as the final character.  The
    backslash can be used in any expression or statement
    to tell the lexer to ignore the newline.
`
data num -> i8  | i16 | i32 | i64 \
          | u8  | u16 | u32 | u64 \
          | f32 | f64


data int -> i8  \
          | i16 \
          | i32 \
          | i64

`
        Error Handling
    Functions that can return an error can declare their
    return type as the desired type | error type.  When
    Checking for errors, the operator ? can be used.  This
    operator checks if the value implements the Error trait.
    If so, it returns from the method, otherwise, the value
    is not changed.
`
data MyErr : Error
    c32* desc
    c32* detail
    E* cause

    ~required by Error trait
    MyErr fromErr: Error err
        return err.desc, err.detail, err.cause

    ~required by Error trait
    c32* desc: self*
        return self.desc

    ~required by Error trait
    E* cause: self*
        return self.cause

    ~required by Error trait
    c32* detail: self*
        return self.detail


~This function takes three parameters: two i32s and
~a function that can return a String or StrErr
i32|MyErr errFunc: i32 a b, (String|StrErr)(i32) fn
    ~Try to open a file, and if no FileErr is found
    ~Then write Just a test, otherwise wrap the error
    ~In type MyErr (using fromErr()), and return it.
    openFile("test")?.write("Just a test")

    ~ ? can also be chained
    Parser.init()?.parseInt("32")?.map(fn)?.show()


`
        Experimental
    These features are being proposed or considered
    but are not yet known to be of enough value to
    include in the language.
`
macro pstr: ident i
    pub const c32* $i = "p"
    print($i)

pstr!(g)
~output: p

macro double: expr e
    (($e) * 2)

print(double!(2 + 3))

macro or:  -> ||
macro and: -> &&

~possible scoped macros
c32* getTokenType: c32 t
    macro isLetter: c32 i
        (i >= 65 && i <= 90 || i >= 97 && i <= 122)

    if isLetter(t)
        return "ident"
    else
        return "not an ident"

~the macro below would not be valid since isLetter would have gone out of scope.
if isLetter('a')
    print("a is a letter")


~possible new c_ffi syntax
pathogen void c_ffi("putchar"): u8

~lambda functions
lambda: i32 x -> return x + 50
|i32 x| -> return x + 50

i32(i32, i32) addFn = |i32 x, i32 y| -> return x + y
i32(i32, i32) addFn = |x, y| -> return x + y

~alternate c_ffi declaration
pathogen void* c_ffi("malloc"): u32 size

~syntax change for type casts to distinguish them from declarations
f32 f = 7 as f32
f32 f = (f32)7
f32 f = f32 cast 7
f32 f = 7 cast f32

~threading and concurrency support
async void printMsg: str msg
    print(msg)

sync for i32 i in arr
    print(i)

f32 f = await someFunction()

~pssible ternary operator
f32 f = x+2 if x > 0 else x-2

f32 f = if x > 0
    x + 2
else
    x - 2

f32 f = x > 0 ? x + 2 : x - 2

~Smart pointers by default, raw pointers made with raw modifier
raw i32* rawPtr = &3

~Is keyword/operator for matching types or values
assert(3 is i32)
assert(5 is 5)
~Could be called as the comparison for match statements

~Allow/force names in data declarations to precede types
data Vec<T>
    mem: T[]
    len: u32
    cap: u32

data List<type T>
    val: T
    next: List<T> | enum -> end

~vs
data List<type T>
    T val
    List<T> | enum -> end
    next

~or
data List<type T>
    T val
    List<T> | enum -> end;; next

~New enum syntax to simplify named enums in data
data Numbers -> enum(One, Two, Three)

data Numbers -> enum{One, Two, Three} num

~Original for comparison:
data Numbers -> enum -> One, Two, Three;; num


~Possible syntax change for comments and multiline comments

~ STYLE 1
#single line comment or pre-proc statement

#[
    multi-line comment1
]

#[
#   stylish multi-line comment
#]
 
~ STYLE 2
{ comment }

{
    multi-line comment
}

{
|   stylish multi-line comment    
}

`
        Keywords
primitive datatypes:
    i8
    i16
    i32
    i64
    u8
    u16
    u32
    u64
    isz
    usz
    f32
    f64
    c8
    c16
    c32
    c64
    bool 
    void

constants:
    true 
    false

statements:
    if 
    elif 
    else 
    import 
    match
    
loops: 
    for
    in 
    do 
    while
    continue 
    break

modifiers:
    pub 
    pri 
    pro 
    const 
    impl
    dyn
    pathogen

datatypes:
    data
    enum

other:
    where
    infect
    cleanse
    ct
`

`
        Unused Symbols
@
#
$
\
|
?

`


`
        Reserved Variables

_args
    stores the command line arguments of the program

_argc
    contains the amount of command line arguments given

_params
    tuple containing each parameter of the current function

_paramc
    amount of parameters in the current function
`

`
        Reserved Functions
_init
    Can be declared within a class to be automatically called
    when creating a new instance of the class.

_deinit
    Can be declared within a class to be automatically called
    when the class goes out of scope.
`
