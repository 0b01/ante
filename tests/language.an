`
        Ante is an multi paradigm language which includes various elements from
    functional, imperative, and object oriented paradigms.  Each 
    line of code is a statement ending in a newline character.  Expressions 
    such as 3 * (4 + 5) may be part of a statement, but are not valid alone.
    Whitespace is significant if and only if is at the beginning of a line and
    precedes a statement.  Blocks are marked by an increase in indentation, 
    and terminated by a return to the original level (unindent).  An indent is 
    always at least one space more than the previous indentation level.  To avoid
    confusion and misalignments in indentation for different tab sizes, tabs
    are invalid, and cannot constitute any significant whitespace.

        Philosophy
    If something can be done compile time, then it should be.  In other words, 
    constant folding should be employed whenever possible.  If a 1500 line 
    program only produces the output "Hello World" every time then that should 
    be the only thing compiled into the binary.
`

`
    The following is an example of an import statement.  It is importing The
    modules math, io, str, op, and c_ffi which are some of the currently planned modules.
`
import "math", "io", "string", "op", "c_ffi"
`
    Arbitrary strings, string arrays, or even functions returning these values can be 
    imported as long as they can be resolved compile time.
`
import stuff()


~This is an example of a single line comment

`
        Variables
    Variables are declared with any modifiers (such as pub to indicate a
    public visibility) followed by the keyword let and the variables name as
    an identifier.  It is important to note that identifiers must begin
    with a lowercase letter, but can contain any amount of capital and lowercase
    letters, underscores, or numbers afterwards.  The type is inferred from the 
    expression in all cases.  This form can be expressed as the following:

    let [modifiers] [identifier] = [expr]

    Alternatively, if the variable is mutable, the type must be specified, or the
    keyword var must be used in place of let.  Note that since it is not immutable,
    its initial value does not have to be specified (Unless it was declared with var).
    All variables by default have their memory set to 0.  In cases where speed is 
    more of a concern, the modifier noinit may be specified to avoid this.

    [modifiers] [type] [identifier]

    In the rare cases when a constant variable's type cannot be inferenced,
    the following form is used:

    let [modifiers] [type] [identifier] = [expr]

    or:

    const [modifiers] [type] [identifier] = [expr]
`

~Declare i, an i8 since integer constants take the smallest type by default.
let ex1 = 1

~There are several ways to specify a type if it is needed
~The type can be stated before the variables name:
let i32 ex2 = 2

~Or the type of the constant can be specified:
let ex3 = 3i32

~Or the constant can be typecasted to an i32:
let ex4 = i32 4

`
    Mutable variables can be declared with the var keyword.  Like
    immutable variables, these are implicitly typed by default, but
    can be optionally given a type before the identifier.  All variables
    must be given an initial value, as they are not initialized by default.
`

var myI8  = 0i8    ~8bit integer
var myI16 = 0i16
var myI32 = 0i32
var myI64 = 0i64

var myU8  = 0u8    ~8bit unsigned integer
var myU16 = 0u16
var myU32 = 0u32
var myU64 = 0u64

var myIsz = 0isz    ~Signed pointer size integer
var myUsz = 0usz    ~Unsigned pointer size integer

var myF16 = 0.0f16
var myF32 = 0.0f32  ~32bit IEEE single precision floating point
var myF64 = 0.0f64

var myC8  = ''   ~ASCII char 0x00

var myBool = false

`
    Any primitive value can also be typecasted to any other primitive type, and
    immutable variables may also be shadowed by another immutable variable of 
    the same name, but with an optionally different type.
`

print(i32 4.99)  ~output: 4
let n = 43.876
let n = i32 n

print(typeof(n) ++ " " ++ n)  ~output: i32 43

`
        Modifiers
    Modifiers are optionally included in a variable or function
    definition.  The available modifiers are:

    pub        Most inclusive visibility modifier
    
    pro        Visibility modifier
    
    pri        Least inclusive visibility modifier
    
    const      Declares a constant variable.  Unlike
               a let binding, this assures a space
               is allocated in memory rather than
               using expression substitution.
   
    raw        Declares a pointer or array that is not
               automatically freed by the compiler.

    pathogen   Specifies a variable or function can
               never be evaluated at compile time.
    
    noinit     Specifies a variable should not have
               its memory cleared.  This modifier has
               no function in a let binding.
`

~Declare a public u8 array buf that is not automatically freed.
let pub raw buf = [3, 4, 5]

~Declare an array of 100 integers called naturalNumbers and do not
~initialize it since it is manually initialized in the following loop.
noinit var i32[100] naturalNumbers

for i in 1 .. 100
    naturalNumbers[i-1] = i


~The preferred way of doing the above is either using an expression block,
~Or using a range inside [] to expand it into an array, as shown below.
let naturalNums = [1..100]


~Modifiers in let bindings are declared after the let keyword
let raw mem = 0x23, 0x32, 0x00


~Modifiers can also apply to a block of variables or functions:
pub
    let globalConst = 3

    let sum = reduce(+)

    fun printMsg:
        print("Msg")


`
        Constants
    Ante includes integer constants, float constants, char constants
    and string constants.  Integer and float constants can have their
    types chosen by the compiler or alternatively can have their type 
    specified with a suffix.
`
print(typeof(0))      ~output: i32
print(typeof(0u8))    ~output: u8
print(typeof(0i64))   ~output: i64
print(typeof(255))    ~output: u8

print(typeof(3.2))    ~output: f32
print(typeof(3.2f64)) ~output: f64

~Unlike integer literals which leave their type up to the compiler,
~All char and string literals have the type c32 and c32[] by default.
print(typeof("test")) ~output: c32[]
print(typeof('A'))    ~output: c32

~c32[] and c32 literals need to be explicitly casted.
let myC8Str = c32[] "test"

~Integer constants can also be expressed in different bases with the 
~prefixes 0x 0o and 0b for hexadecimal, octal, and binary respectively.
assert(0b110 == 6)
assert(0xFFFF == 65535)
assert(0o31 == 25)

~Integer and float constants in base 10 can also be expressed in
~scientific notatation.
assert(1e-3 == 0.001)
assert(4.5e+2 == 450)
assert(314159265E-8 == 3.14159265)
assert(8.92e2 == 892)

~Underscores are ignored within integer and float literals
assert(1_000_000 == 1000000)
let double = 25.0_f64

`
        Operators
    Ante includes the following binary operators:

        +    addition
        -    subtraction
        *    multiplication
        /    division
        %    remainder

        <    less than
        >    greater than
        <=   less than or equal to
        >=   greater than or equal to
        ==   equal to 
        !=   not equal to
        and  logical and
        or   logical or

        ++   append
        ..   range
        ;    sequencing operator

        |    bitwise or (or a type-expr or)
        ^    bitwise xor
        <<   bitwise left-shift
        >>   bitwise right-shift

    In addition to binary operators, Ante also defines the following
    unary operators.  Note that to avoid ambiguities in parsing, every 
    unary operator is a prefix to the value it acts upon.
        
        -    negative
        not  logical not
        @    pointer dereference
        &    address of
`

`
        Casting
    Casts are accomplished by preceeding a value with a type, similar
    to a variable declaration.  When casting a value, the value is directly
    changed to the corresponding type unless the type specified is a
    userdata type which overloads the op("cast") function with the same
    parameters.  Casts are never performed implicitly.
`

~When casting integer types to one of a larger size, the value is sign
~extended unless it is an unsigned integer, in which case it is zero extended.
let five = i32 5.0

let thirteen = i16(7i8 + 6i8)

fun add: i32 x y => i32
    x + y

~thirteen must be explicitely casted to an i32, no automatic widening is performed.
add(five, i32 thirteen)


`
        Arrays

    The syntax for declaring arrays is shown below.  The array arr
    declared below is an array of 30 integers, each initialized to 1

    NOTE: The size must be a non-pathogen integer expression.
`
var i32[30] arr = 1

~Each element of an array can also be initialized individually
var assortedNums = [9, -76, 3.14159265, 2^8, 1 + 2*(6-3)]

`
    Each element of an array can be accessed individually by index.  Negative
    indexes work backwards from the end of the array, so arr[-1] will always
    yield the last element of arr.
`
assortedNums[0] += assortedNums[1]
print(assortedNums[0] ++ ", " ++ assortedNums[-2])
~output: -67, 256

`
    Multidimensional arrays have n pairs of square brackets in their type where
    n is the number of dimensions they contain.  For example, the array below
    has type i32[1][2], or more generally, i32[][]
`
let box = [[1, 2], [3, 4]]


`
    The size of an array can also be dynamically edited.  The following syntax
    should always be used when expanding or restricting an array.
`
arr += 2
arr -= 3 ~Note: this will throw an exception if the array's size becomes < 0

~The append operator can also add a single element to an array or list
arr = arr ++ 5

box ++= [5, 6]

`
        Tuples
    In addition to arrays, there are also tuples.  Unlike arrays, tuples can
    be mixed and matched with several types, but each must be stated beforehand.
    A tuples type is each constituent type seperated by a comma.
`
~This tuples type is i32,f64
let tup = (44, 44.0) 

~A tuple literal must be surrounded with parenthesis.
let anotherTuple = (arr, ["This tuple contains", "two arrays"])

~Like any other value, tuples can be mutated if declared as such.
var yetAnoterTuple = (1, "two", 3.0)
yetAnotherTuple[1] = "Two"


~In Ante, tuples are essentially anonymous structs
let immutTuple = (46, "Fourty-six", 46.0)

~A pointer to a tuple
let tupPtr = &(0, 0)

`
        Strings
    Strings in Ante have a len field, and are null terminated.  This can often
    simplify code by removing the need to check if the next character is out of bounds.
`
~A simple declaration of a string datatype
data Str
    c8[] cStr
    u32 len

fun Str.cast(): c8[] str => Str
    (cStr, cStr.len())

let msg = Str "Hello World!"


fun longestStreak: Str s => i32
    var maxStreak = 0
    var curStreak = 0

    ~No need to check if i+1 >= s.len since Strings are both null terminated and have a length field
    for i in s.indices()
        if s[i] == s[i+1]
            curStreak += 1
        else
            if curStreak > maxStreak
                maxStreak = curStreak

            curStreak = 0

    return maxStreak


~Alternatively, one can rewrite the above method using a more functional approach
~With the functions map and reduce.
fun longestStreak_alt: Str s => i32
    s.indices().map(
    ~In Ante, even function declarations are expressions, so we can pass this
    ~Recursive function to map to return a list of each letter's streak.
    ~Also note that this function, while named, has both an inferred return type
    ~And inferred parameter types.
        fun streak: i, curStreak=0
            if s[i] == s[i+1] then streak(i+1, curStreak+1)
            else curStreak

    ~Finally, return the largest streak.
    ).reduce(max)


print(longestStreak(msg))
~output: 2
`
        Functions

    Functions in ante each have their own scope in addition to the scopes they
    inherit (in this case, only the global scope).  Variables created in
    functions are all local variables.

    Below is the declaration of a function, printMsg.  It takes no parameters
    and returns no value.  It is important to note that unlike many c based
    languages, functions take a single block-expression as their body.  Blocks 
    are denoted by an Indent and a terminating Unindent (or Dedent).  Since Ante
    is only optionally whitespace-sensitive, these Indents and Unindents may be
    replaced with { and } respectively, and all whitespace is ignored inside these
    curly brackets, meaning all declarations requiring block-exprs inside brackets
    must also use brackets.  For this reason, most code uses the more intuitive
    whitespace-sensitive style, although curly brackets may be usefull for those
    easing into the language.
`
fun printMsg:
    print("Hello World!")

`
    This add function takes in two parameters, augend and addend both with type f64, 
    and returns a f64 value.  Since functions take a single block-expression as their
    body, the return type must match the type of this block-expression.
`
fun add_floats: f64 augend, f64 addend => f64
    augend + addend

~Multiple variables of the same type can be declared by omitting the , and repeated type
fun add_floats_2: f64 augend addend => f64
    augend + addend

`
    Ellipses can be used in place of or after a type to indicate that the
    function takes a variable amount of arguments.  The variable it is assigned
    to is a tuple by default, but if a type is specified before the ellipses, it
    becomes an array of that type.  In either case, the number of arguments is always
    known at compile time, and can be accessed via .count.  If a function takes 
    a variable amount of parameters, ... can only be the last parameter.  In the
    lnprint function below, params is passed to the print function, with an additional
    newline passed at the beginning.  Note that the print function itself is a varargs
    function, and when printing an array or tuple it will by default print each value
    without a seperator.
`
fun lnprint: ... params
    print('\n', params)

~Ante still provides the return keyword for early returns, or code clarity.
fun sum: i32... nums => i64
    var ret = 0_i64
    for i in nums
        ret += i
    return ret


`
    Calling functions is accomplished by specifying the function's name, followed
    by a tuple of its parameter(s).  Function's taking no parameter's need to
    be called with an empty tuple ().
`
lnprint("Test #", add(3, 43), sum(3, 4, 5))
~output: 
~Test #, 46, 12

~Zero-parameter functions need to be called with ()
do_something()

~Functions can also take named parameters
add_floats(addend = 2.5, augend = 5.0)


`
        Type inference
    Type inferencing in functions can be used in both the return type, and the
    parameter types.  Functions with inferred return types replace the => type
    syntax with just an =.  Without the =, the function would be assumed to
    return a void value, as is the case with some functions above.  Parameters
    with inferred types are simply denoted by the absence of a specified type
    for that parameter.

    In general, type inference in functions is only used in either local functions
    which are not to be exported to an API, or general functions where it is
    already obvious what it does and needs to accomplish this.

    Type inference is usually discouraged in cases other than the above because
    if, for instance, a user uses one of these functions with an unintended type and 
    it fails, they will get an odd error such as 'join' is not implemented for 
    types 't and 'b, instead of the more descriptive type-mismatch error the compiler 
    would generate otherwise.
`

~Function that takes the dot product of two vectors represented as arrays
~Although this function was originally written with the intention arrays would
~be used, any type for l and r may be used as long as it implements join and reduce
fun dotProduct: l r =
    (l,r).join(*).reduce(+)

`
        Currying
    In Ante, currying is always explicit, which leads to better error messages rather
    Than an ubiquitous type mismatch error.  To curry a function, specify _ as the desired
    argument to be curried.
`

~As a simple example, an increment function can be created by currying a general add function

~The general add function:
fun add: i32 a b => i32
    a + b

~And the increment function created with currying:
let increment = add(_, 1)

~In this way, currying reduces the need to declare some parameters in certain situations.

~The above definition is equivalent to both of the following functions:
fun increment: i32 x => i32
    add(x, 1)

let increment = fun x -> add(x, 1)



~With some currying, we can reduce the definition of sum even further
let sum2 =
    reduce(_, (+))


~A nice side effect of using _ for currying means any argument can be curried, rather
~than just the first one.


`
        Calling Conventions
    Regular functions use the C calling convention, and as such are compiled without
    any name mangling.  Methods are compiled under the name [datatype]_[method name].
    Since datatypes are always capitalized, and identifiers cannot start with a capital,
    there is no possibility for a name-collision.
`

~Compiled as "printStuff"
fun printStuff:
    print("Stuff")


ext Str
    
    ~Compiled as "Str_reverse"
    fun reverse: Str s => Str
        var rev = ""

        for i in s.len ^.. 0
            rev += s[i]

        return rev

`
        Control-Flow
    Control-Flow can be altered with the keywords if, elif, else, match, while,
    do while, and for.
`
~If statements come in the form of if <expr> then <expr>
if 4 > 3 then
    print("4 is indeed greater than 3")

`
    Multiple elifs can optionally follow an if after the Unindent.  Their syntax is
    the same as an if, except with the keyword elif.  An elif will only be evaluated
    if and only if the first if, and all elifs preceeding the desired case, conditions
    evaluate to false
`
if 3 > 5 then
    print("3 > 5, what??")
elif 3 > 4 then
    print("3 > 4, how??")
elif 3 > 3 then
    print("3 > 3, huh??")
elif 3 > 2 then
    print("3 > 2, yup.")

`
    In addition to elif lists, a single else may optionally terminate the test cases.
    The else clause always follows either the first if clause or an elif clause, and
    like the elif clause, it may not be used on its own without a preceeding if.  Else
    clauses are executed if and only if non of the above test conditions evaluated to
    true.
`
if 3 > 2 then
    print("Hello World!")
else
    print("Invalid laws of mathematics, please try again in an alternate universe.")


if 3 > 5 then
    print("Something is seriously wrong if this prints.")
elif 4 > 5 then
    print("This shouldn't print either.")
else
    print("Phew, dodged a bullet there.")


`
        Loops

    Ante has two kinds of loops: while, and for.
    The while loop runs while the following expression is true, and the for 
    loop loops through each element of an array or range.
`
while true do
    print("I loop forever")


var total = 0
for n in arr do
    total += n

for count in 0..100 do
    print(count)


`
        Expressions
    Expressions are pieces of code that return a value, and in Ante, every
    construct is an expression.  Expressions can be any length from a single value to
    a complex expression containing many operations.  Expressions are expected
    inside several other expressions, namely variable declarations/assignments, let
    bindings, if conditions, and loop conditions.  Expressions are acted upon by operators,
    including the ubiquitous sequencing operator, <Newline>, as well as ;.  Inside
    block-expressions (expressions starting with an Indent and ending with an Unindent), Newlines
    act as a sequencing operator, ignoring the first value and returning the second.  In this
    way, code may be written quite naturally in either a functional, or imperative style.
    If this is not wanted, newlines can instead be ignored with \ before one.
`

~A simple expression consisting of only the I32 0
let zero = 0

~If statements can be used within expressions, along with every other construct.
let stoplight = if light == "green" then "go" else "stop"


~Declare a function inside this expression, and call it.
~Note how in the expression below the function definition is sequenced by the Newline and
~following expression containing getThree().  If the expr-block were to end at line 637,
~then three would be instead set to the value of the function definition (being the function itself)
~Note2: The example below sequences with 2 newlines, any number of newlines will suffice.
let three =
    fun getThree: => i32
        3

    getThree()

`
        Pathogen infections
    Pathogen is a modifier given to a function which can never be evaluated
    compile time.  Examples include io functions such as print and read.  When
    called within another function, the pathogen function infects that function
    as well, making it a pathogen function without the need to explicitly
    declare it as such.  The implicit pathogen function is said to be infected.
    The pathogen modifier is usually only used in rare cases such as defining your 
    own print function without utilizing the standard api, or using an external c api.  
    While less common, the pathogen modifier may be used for variables, classes, enums, etc.
`
pathogen fun myPrint: c32* msg
    let i = 4 + 2
    system("echo '" ++ msg ++ i ++ "'") ~note: system is already a pathogen function

~Because the following function uses the pathogen myPrint, it cannot be
~evaluated compile-time, so the system call to echo 'Hello World' will
~occur during run-time.
fun printMsg:
    myPrint("Hello World!")

~To use a pathogen function without the host becoming infected, the keyword do
~is used when calling a pathogen or infected function.  This compile time evaluation
~of pathogen functions can be useful in several applications, such as loading an image
~into a variable or class representing it without the need to search for it during runtime,
~and eliminating the need to include the raw image as an asset in production.
fun compileTimeLoadImg => Image*
    let = File("path/to/image.png")

    ~Read all of the image data into imgData at compile time.
    let imgData = do f.readAll(imgData)
    
    ~Then return the image
    new Image(imgData)


~Conversely, to infect a non-pathogen function, the infect keyword may be used.
~Note that only the infected instance of the function is evaluated during runtime.
fun runTimeLoadImg => Image*
    return infect compileTimeLoadImg()

~Values can also be infected if set equal to the return value of a pathogen function
let myImg = runTimeLoadImg()
someFunction(myImg) ~This instance of someFunction is infected since an infected parameter is used.


`
        C FFI
    The c foreign function interface is implemented within the c_ffi module.
    Once this module is imported, objects can be created of the C class.
    This class contains the header(s) to parse, and possibly specific
    functions from that header.  Since the object is primarily used for
    its overloading of import, its contents must be known at compile-time.
`

~By default, the file is parsed and every function is added.
import C("path/to/file.h")

~Alternatively, specific functions can be whitelisted with .fn
import C("some/other/file.h").fn("func1", "func2", "func3")

~Multiple files can also stored in one C object
import C("stdio.h", "stdlib.h")

putchar(72)
putchar(105)
putchar(10)
~output: Hi


`
        ->, ;;, {, and }.
    -> and ;; can be used to manually insert indent and unindent tokens
    respectively.  -> is commonly used in single line blocks, but ;; is much
    more rare, being added to simplify the declaration of enums within a data
    declaration with multiple fields.  Both -> and ;; change the indentation level
    in addition to issuing the token.  Doing so with -> ensures an unindent token
    is automatically issued once a statement is encountered on the same line as
    the one containing the ->.  With a ;; an Unindent is introduced followed by
    an Indent if the next statement returns to the normal level.  Both of these 
    constructs are never required, and used only for brevity.

    Unlike -> and ;;, { and } are somewhat more usefull, functioning as complete
    replacements for the whitespace sensitive syntax.  Unlike -> and ;;, curly brackets
    are automatically matched like indentation levels are, but also contain no
    significant whitespace inside them, meaning if any code were to be used with
    { and } that requires indented blocks, like functions, { and } must be
    recursively used.  In this way, { and } closely match their usage in C-like
    languages, and are intended for those who cannot use significant whitespace
    for some reason or another.
`

fun subtract: f32 a b => f32 -> a - b

~While these can be nested, overnesting should be avoided as it leads to clutter.
data Integer -> i32 i, fun init(): i32 a -> i = a;; u8 byte

~compared to
data Integer
    i32 i

    fun init(): i32 a
        i = a

    u8 byte


~NOTE: curly braces are heresy
fun inefficientAdd: i32 a b => i32 {
    if b == 0 then {
        a
    }else if b < 0 then {
        inefficientAdd(a-1, b+1)
    }else if b > 0 then {
        inefficientAdd(a+1, b-1)
    }
}

`
        Data declarations
    In ante, all datatypes are declared through the data keyword which binds a 
    name to a type expression.  This binding must begin with a capital letter 
    and be succeeded by zero or more alphanumeric characters or underscores.
    A data declaration consists of one or more type expressions seperated by 
    the field names for those expressions.
`

~Declare coord, a datatype consisting of three f64s named x, y, and z.
~NOTE: just as in functions, multiple variables of the same type can be declared
~      by seperating the field name with spaces. if an = is encountered 
~      afterwards, each of the variables will be set to that default value.
data Coord
    f64 x y z

~Declare Char, a datatype that can contain a c8 or c32 char
data Char
    c8|c32 c

let ch = 'a'


data Coord2D
    f32 x
    f32 y

~Anonymous fields can be declared simply by neglecting to give each field a name.  Anonymous
~fields can only be accessed with [] as tuple indices.
data Q1Coord
    u32
    u32

let myQ1C = (2, 3)
print(myQ1C[1]) ~output: 3

~Each datatype containing more than one field is internally represented by a tuple, so they
~Can be created in a similar fashion.
Coord coord = (100.0, -50.0, 66.7)
print(coord.y)  ~output: -50


let coord2 = (100.0, -50.0, 66.7)

~Data structures are compared with structural equivalence by default, so the following two
~Coords are equivalent.
assert(coord == coord2)


~To access a specific field of an anonymous datatype in an expression, it must be casted to
~the desired type.
let y = Coord(100, -50, 66.7).y

~Set p1 p2 and p3 to 0, 0
i32,i32 p1 p2 p3 = (0, 0)


`
        Ranges and Type Conditions
    Ranges are denoted by start and end values surrounded by the .. operator.
    Ranges declared in this fashion have an inclusive startpoint and exclusive
    endpoint.  To declare ranges with an exclusive startpoint, use ^.. likewise,
    use ..^ to declare ranges with an exclusive endpoint, or ^..^ to declare an
    exclusive range.
`

~Print 1 to 100 inclusive
for i in 1 .. 100 do
    print(i)


~Iterate through indexes of an array:
let testArr = [0, 3, 5, 6]

~To make a range exclusive, add a ^ to the exclusive end (or ends)
for u in 0 ..^ testArr.len() do
    print(testArr[u])




~To change the step value of ranges, have the first end of the range be an array
~or tuple of two elements.  Their difference will be the step.
for i in [10, 20] .. 100 do
    print(i)

for i in [0, -5] .. -100 do
    print(i)

~Alternatively, the step function can be called to return a new range
~With the specified step
var evens = (0..10).step(2)

~or the step can be changed in place with :
evens:step(4)

for e in evens do print(e)




~To convert ranges into an array or list, surround them with square brackets
let digits = [0..9]

~Create an array of odd numbers from 1 to 19 without using .step
let odds = [(1,3)..19]



~Ranges can also be used in combination with the in keyword to test if a given value
~is within the range
if 3 is in 1..9 then
    print("3 is a single-digit positive number")


~in can also test if a value is in an array or tuple
if "two" is in ["one", "two", "three"] then
    print("Found it!")

~The default action for tuples is to check fields with matching datatypes only, or any
~with op == implemented for the element and target type.
if "test" is in (5, 6.5, "test") then
    print("Got it!")

`
    Type Conditions are signified with the where keyword and provide a concise way to
    verify the value of a variable.  Where is always followed by the boolean expression
    to be checked.
`
data Teen
    u8 age  in 10 .. 19
    Str name  where name.length > 0

let john = Teen(15, "John Brown")

~TypeConditionErr
let sara = Teen(18, "")


~Create a datatype TwoDigits that represents a number that is between
~10 and 99 inclusive.
data TwoDigits
    u8 in 10..99

let td1 = TwoDigits(32) ~Good!
let td2 = TwoDigits(100) ~RangeErr


~Type conditions with anonymous fields:
data LongStr
    Str where this.length > 10

~Type conditions are evaluated whenever the corresponding field is changed.
data Q2Coord
    i32 where this[0] < 0
    i32 where this[1] > 0

var q = Q2Coord(-4, 5)
q[0] = 2 ~where this[0] < 0 is evaluated, and a TypeConditionErr is thrown.

`
        Classes
    Class-like data structures can be declared by simply including methods within the
    data declaration.  These methods are associated methods and do not add to the size of
    the datatype, but are linked to it at compile-time.  These methods are each within a namespace
    that is the name of the datatype, but cannot be accessed without an initialization of the
    datatype if they take self as a parameter.
`
data Animal
    u16 age
    c8* species
    c8* name

`
    Create a static function init that creates a new instance of an animal.
`
    fun init: u16 age, c8* species name => Animal
        return Animal(age, species, name)
        
`
    Create a non-static method taking self as a parameter.  This function cannot be used as 
    Animal.printInfo, it must be called on a previously initialized Animal.
`
    fun printInfo: self
        print(self.name .. " is a/an " .. self.species .. " and is " .. self.age .. " year(s) old.\n")

`
    The new keyword can be used to allocate and initialize memory to be stored in a
    pointer type.
`
let clifford = new Animal.init(7, "magnum rubrum canis", "Clifford")


`
    Datatypes can also inherit from other datatypes with the : operator.
`
data Person : Animal
    c8* job

    fun init: u16 age, c8* job name => Person
        Person ret = Animal.init(age, "Homo sapien", name)
        ret.job = job
        return ret

`
    This function obscures the printInfo declared in the Animal type.
`
    fun printInfo: self*
        print(self.name .. " is " .. self.age .. " years old and is a(n) " .. self.job)


`
    Methods of the same name can also be overloaded if they take different amounts or types of variables.
`
    fun printInfo: self*, bool showAge
        if showAge then
            print(self.name .. " is " .. self.age .. " years old and is a(n) " .. self.job)
        else
            print(self.name .. " is a(n) " .. self.job)


let john = Person.init(44, "electrician", "John")
john.printInfo() ~output: John is 44 years old and is a(n) electrician

var sara = Person.init(27, "Dentist assistant", "Sara")
sara.age = 37
sara.job = "Dentist"
sara.printInfo()


`
        Modifiers in data declarations
    Modifiers modify the behaviour of a particular instance of a variable, and 
    are listed before its type.  The visibility modifiers pub, pro, and pri are 
    short for public, protected, and private respectively.  Pri variables can only
    be accessed by associated methods within the data declaration or extensions.  Pub 
    variables are the default and can be accessed from anywhere.  Pro variables can
    be accessed by the datatype and any inheriting datatypes.  Another common modifier 
    is const to declare a constant variable.

    Modifiers can be placed before a variable or function, or alternatively
    can be placed before a new block to modify everything within the block
`
data Statistics
    ~declare secretData as a private variable, only able to be accessed
    ~from within member functions (methods).
    pri f64 secretData

    pro const f32 pi = 3.14159265

    pub i32 varCount

    ~Alternatively, you can also use modifiers before a block:
    pub
        fun getData: self* => f64
            return self.secretData ~not so secret anymore

        fun getStatus: self* => c8*
            if self.secretData > 10 then
                return "Good"
            else
                return "Not so good"

    pri fun doCalculations: self*, f64 mData => f64
            return mData * self.secretData / self.varCount

    ~Because the init function is declared within the datatype, it can access private members.
    fun init: i32[] mData => Statistics
        var ret = Statistics(0, 0)
        for i in mData do
            ret.secretData += mData / ret.pi
            ret.varCount += 1
        return ret

`
        Type Specifications, Generics, Where, and Operator Overloading
    Type specifications in ante are a powerful way to specialize a class or function
    to a specific usage.  In its most general case, it can be used in much the same
    way as generics or templates in other object oriented languages.  To declare a type
    specification for a class, parenthesis are used after the class name.  Within the
    parenthesis a type is binded to a name, and an optional boolean expression which
    must be able to be evaluated at compile time.  For functions, the keyword where is
    used followed by the name of the type in question and a boolean statment validating
    that the type is valid for the function.
`
~For functions, the where keyword always comes at the end of the list of parameters.
~where statements are evaluated at compile time whenever possible.  If the expression after
~where evaluates to false, an error is thrown.
let actions = "walk", "talk", "stand"

fun getAction: u8 action => c32[]  where action is in 0 ..^ 3
    return actions[action]


fun calculateForce: f64 m a => f64  where m >= 0
    return m*a

calculateForce(-54, 2)
`
Exception thrown when the where condition is not met:

function calculateForce: f64 m, f64 a requires the condition
m >= 0
which was not met for input value m = -54
`

`
        Generic Functions
    Generic Functions can be a powerfull tool to recompile a function for a given
    argument (usually a type) during compile time.  These functions are expressed
    with the use of type variables.  Unlike user types which must begin with an
    uppercase letter, type variables are variables and thus must begin with a
    lowercase letter.  Once declared, a type variable can be used until it
    falls out of scope.
`
~Create a function that takes in two variables, obj1 and obj2, of some type t
~and returns true if the first is greater than the second.
fun greater: 't obj1 obj2 => bool
    obj1 > obj2

~This function will fail to compile if they are called with variables of a type
~That do not have < and > implemented.
fun cmp: 't v1 v2 => i32
    if v1 < v2 then -1
    else i32(v1 > v2)

cmp(3, 4) ~valid
~cmp(3, "three") ~invalid: types must be the same for function cmp


~Each of the above functions assert that the two variables passed have the same type,
~and have > implemented to return a bool.  This may not always be the case if the user
~defines the operator to return a different type or overloads the operator function for
~two different types.  Here is a more general definition that takes this into account.
fun add: 't a, 'u b => 'r
    a + b


~The syntax for type specifications in a class is to surround them in < and >.
~In the Angle class, each time it is initialized, a bool is specified as true if the
~angle is in radians, false otherwise.  This determines how Angle is compiled and
~cannot be changed after initialization.
data Angle<bool isRadians>
    f32 angle

    if isRadians then
        fun getQuadrant: self* => u8
            return self.angle / (3.14159265 / 4) % 4 + 1
    else
        fun getQuadrant: self* => u8
            return self.angle / 90 % 4 + 1
~usage:
let a1 = Angle<true>  (3.14159265 * 2 / 3)
let a2 = Angle<false> 120
assert(a1.getQuadrent() == a2.getQuadrent())

`
    The use of type specifications eliminates the need to store excess metadata about
    the object to be checked each time a function runs as well as encouraging classes
    to be more specialized without having several copies of otherwise very similar
    classes, eg. having a AngleDegrees and AngleRadians class seperate then having
    to worry about them interacting properly.  In this usage, type specifications
    act by creating a parent class Angle, and two child classes, Angle<true>, and
    Angle<False>, which correspond to AngleRadians and AngleDegrees.
`


`
    To have a data structure with a member of variable type, type variables can also
    be used.

    NOTE: Ante implements smart pointers by default, so this class is meant to show
          how one could be implemented without this feature (eg. if it disabled).
`
data MySmartPtr : Clone
    't* rawPtr
    pri u16* refCount

    fun op("new"): 't val
        rawPtr = new val
        refCount = new 0u16

    fun op("drop"):
        if @refCount == 0 then
            free(refCount)
            free(rawPtr)
        else
            @refCount -= 1

    ~Required by Clone trait
    fun clone: self => MySmartPtr
        let clone = (rawPtr, refCount)
        self.@rawPtr += 1

        ~Although clone is an anonymous tuple-type, since Ante uses structural
        ~equivalence, and MySmartPtr can be comprised of the same types, it is accepted.
        return clone


~where can also be used to check the type specification
data ChessPiece<Str piece> where searchFor(piece, ["pawn", "knight", "king"]) != None
    u8 x
    u8 y
    
    fun init: u8 x, u8 y => ChessPiece
        return ChessPiece<piece>(x, y)
    
    if piece == "pawn" then
        fun validateMove: u8 x2, u8 y2 => bool
            x == x2 and abs(y - y2) == 1

    elif piece == "knight" then
        fun validateMove: u8 x2, u8 y2 => bool
            if abs(x - x2) == 1 then
                abs(y - y2) == 2
            else
                abs(x - x2) == 2 and abs(y - y2) == 1
    
    elif piece == "king" then
        fun validateMove: u8 x2, u8 y2 => bool
            abs(x - x2) <= 1 and abs(y - y2) <= 1


let knight = ChessPiece<"knight">(2, 3)
assert(knight.validateMove(3, 5))

`
        Operator Overloading and Infix Functions
    Note that the cmp example above requires that the operator < is implemented for
    the two objects.  To do this we must implement operator overloading.  In the
    following example, the class Point is created and overloads the > and < operators,
    and creates the new infix function cmp for comparisons.
`
data Point
    pub i32 x, y

    `
        Now to implement the < operator. Each operator is declared as a function 
        with the name generated by the function op which is imported from the 
        op module. This function requires the operator in question in string form.  Invalid
        operators will throw a compile-time error.  Note that since operators are declared
        within classes, operators for primitive datatypes cannot be redefined.
    `
    fun op("<"): self, Point rVal => bool
        self.x < rVal.x and self.y < rVal.y

    fun op(">"): self, Point rVal => bool
        self.x > rVal.x and self.y > rVal.y

    `
            Infix functions
    
        Infix functions are declared by calling the 'infix' function.  This
        function takes one parameter, the name of your function.  The precedence
        of an infix function is extremely high, as if both parametrs were surrounded
        by parenthesis.  The example  4^6 plus 3%9 would be parsed as (4^(6 plus 3))%9
    `

    ~An example of a generic comparison function
    ~Note that this function uses the > and < operators
    ~declared earlier in this class.
    fun infix("cmp"): self, Point rVal => i8
        if self < rVal then -1
        else i8(self > rVal)


let origin = Point(0, 0)
let topRight = Point(3, 4)

print(origin < topRight)
print(origin > topRight)

print(origin cmp topRight)
`output
true
false
-1
5
`

`
        Type Extensions
    The ext keyword can be used to extend any type with additional methods, 
    but no new instance data can be added for congregate datatypes.  A common 
    usage of this would be extending an API to implement a function or even inherit
    from an additional parent class as long as it has no instance data.
`
ext Point : SomeAdditionalTrait
    ~implement new methods
    fun op("=="): self, Point p2 => bool
        return self.x == p2.x and self.y == p2.y

ext Drawable
    fun draw: self

    ~Default definitions for traits can also be created.
    ~NOTE: because self.surface is accessed, this requires the implementing object
    ~      to either have a 'surface' field, or override this function.
    fun getSurface: self => 's
        return self.surface

data Rectangle
    u32 height
    Surface surface

ext Rectangle : Drawable
    ~Now Rectangle must implement the methods of Drawable
    fun draw: self
        self.surf.print("___")
        for i in 1 ..^ self.height do
            self.surf.print("| |")
        self.surf.print("|_|")

    fun setHeight: mut self, u32 newHeight
        height = newHeight

    fun cast(): u32 height => Rectangle
        return Rectangle
            height = height,
            surface = Surface()

var r = Rectangle 4

~Mutator functions are differentiated from accessors
r:setHeight(5)


~Mutator functions cannot be used with constant variables
let immutRect = Rectangle 3

~Error here!
immutRect:setHeight(5)


~Extensions can also be used for primitive types
ext i32, i32
    fun swap: self => i32,i32
        print("Swapped i32!")
        (self[1], self[0])


ext't, 't
    fun swap: self => 't,'t
        print("Swapped pair!")
        (self[1], self[0])

~In the case multiple impls apply, the most specific is always chosen
~If there are multiple equally specific impls, a compile-time error is thrown.
let point = (3,4).swap()
~output: Swapped i32!

assert(point[0] == 4 and point[1] == 3)

~The only limitation on implementations is that it cannot be used for pointer types.
~Pointers will be automatically dereferenced if their dereferenced type has a valid
~implementation, otherwise a compilation error will result.

ext c32* ~invalid
    fun addInitials: self => c32*
        self ++ " -JF"

ext c32[] ~valid
    fun addInitials: self => c32[]
        self ++ " -JF"


var ptrQuote = c8* "implementations cannot be used for pointer types"
 
~Compilation error since c32* has no function addInitials:
ptrQuote = ptrQuote.addInitials()

let ptrQuote2 = c8[] ptrQuote ~convert to array
ptrQuote2 = ptrQuote2.addInitials() ~valid

`
    NOTE: because string literals have the type c32[], the following is valid:

    c32* ptrQuote = c32* "implementations cannot be used for pointer types".addInitials()
`


`
        Pattern Matching
    Pattern matching can be accomplished with the match keyword.
    This attempts to match the input value to any valid type or
    value it comes across.  Each candidate is indented relative
    to the match keyword, and their associated statements are
    indented relative to themselves.  To save space for short
    statements, it is reccomended to use the -> token.
`

let testInt = 3
match testInt
    1 -> print("Yup, its one")
    2 -> print("It's actually two")
    3 -> print("Nope, it's three")
    4 .. 10 -> print("It's between 4 and 10 inclusive")
    _ -> print("It's not one, two, or three, or in the range 4-10")
~output: Nope, it's three

~In this example, match is used to determine Joe's class
let joe = Person(32, "Programmer", "Joe")
match joe
    Point  -> print("Joe is a point")
    Animal -> print("Joe is an Animal")
    Person -> print("Joe is a Person")
    _      -> print("I don't know what Joe is")
~output: Joe is an Animal
~This is because the Person class inherits from the Animal
~class, so the Animal cast to joe was the first valid cast

let testStr = "Test", 4

match testStr
    ("Test", x) where x != 4
        print("Found a Test Str with the wrong length!")
    (_, 3)
        print("Found a Str of length 3!")
    ("Test", _)
        print("Found a Test Str!") ~ this will be printed


~Match can also be used in expressions
let s = match 2
    0 -> "zero"
    1 -> "one"
    2 -> "two"
    _ -> "other"
`
        Enums
    Where data declares a named type, enums declare named
    values.  The values declared are represented by integers
    internally.  The specific integer for each value can also
    be manually set using the assignment operator.
    
    The values within an anonymous enum are exported into the global
    namespace.  Values within a named enum are exported under
    the namespace of the same name.

    Note that since enums only declare named values, they do
    not yet have an associated type, but can still be used
    as integers.  To declare a type, use a data declaration
    in combination with an enum.

    Indentation is required after the enum keyword in an anonymous enum,
    or after its name in a named enum.
`

~Export each suit into the namespace Suit
~NOTE: since Suit is not declared as data, it is not its own type.
enum Suit -> Diamonds, Hearts, Spades, Clubs

print(Suit.Spades)  ~output: 2

data Card
    u8 number
    i32 suit

let fourOfHearts = Card(4, Suit.Hearts)
let suit = (Card(3, Suit.Hearts)).suit
~Enums are automatically assigned values, but can also be manually assigned with the
~ = operator after the first operand.  Each consecutive member will have a value equal
~ to its distance from the fist + the first's value.
enum Numbers
    One   = 1
    Two~  = 2 (inferred)
    Three~= 3
    Four~ = 4
    Five~ = 5

~   number = 3
let number = i32 Three

~Alternatively, if the first and second's value are given then each consecutive member
~Is incremented by their difference instead of 1.
~Note the double indentation after enum.  The -> after EvenNumbers increments the
~indentation level by 1, and enum requires another.
data EvenNumbers -> enum
        Two = 2
        Four = 4
        Six~ = 6
        Eight~ = 8, and so on
        Ten, Twelve, Fourteen

~           evenNumber = 12
let evenNumber = EvenNumbers.Twelve

`
        Pointers
    Pointers are created by adding an * directly after the datatype,
    without any whitespace.  Pointers are smart pointers by default and
    will be automatically freed.  If a raw pointer is wanted, it can be
    created with the raw modifier.
`


let five = 5
let ptrToFive = &five
~The unary & operator gets the location of the value 5, which is on the stack in this case.

~The new keyword automatically allocates data for a class or struct and calls its
~constructor if it has one.
let tod1 = new Card(3, Suit.Diamonds)

~alternatively, data can be manually allocated.  The following is equivilent
~to the statement above
let tod2 = malloc(sizeof(Card))
@tod2 = Card(3, Suit.Diamonds)

~Example of a raw pointer to the u8 value 5.
let raw example = new 5u8

~Raw pointers must be manually freed with the free function
free(example)

~Pointers can also be used to create strings from char arrays
let str = "Hello World!"
let msg = c8* "Pointer String"

`
        Automatic dereferencing.
    When accessing a member function through a pointer to an object,
    dereferences are automatically added, eliminating the need for a
    seperate member accessor operator for pointers (-> in c like
    languages).
`
data PtrExample
    c8[] msg

    fun printMsg
        print(msg)

let ex1 = PtrExample "" ~typeof ex1 = PtrExample
let ex2 = new ex1       ~typeof ex2 = PtrExample*
let ex3 = new ex2       ~Typeof ex3 = PtrExample**

ex1.printMsg() ~No pointer, so no dereferencing is necessary
ex2.printMsg() ~(@ex2).printMsg()
ex3.printMsg() ~(@@ex3).printMsg()

`
        Pointers and Arrays
    Internally, pointers are stored the same way as arrays.
    They only differ based on the operators used on them.  Conversions
    between array and pointer are zero cost, they simply change how they
    interact with operators or impls.
`

~Both of these strings are stored as pointers to the first c32.
var arrStr = c8[] "str"
var ptrStr = c8*  "str"

`
    += operator

    Pointers:
        increments the address pointed to by b * e units, where b
        is the size of the value pointed to, and e is the result of
        the evaluated expression.  
    Arrays:
        Allocates additional capacity for e elements to the end
        of the array, and does NOT initialize these elements.

        NOTE: to add a value (or values) to the end of an array,
        ++ or the corresponding ++= are used.
`
ptrStr += 1
arrStr += "element 2"

`
    [] operator

    Same behaviour in pointers and arrays.  Fetches the element 
    at address pointer + b*sizeof(element), where b is the integer
    expression evaluated between [ and ].  Bounds checking is
    not employed at runtime for either.
`
assert(ptrStr[0] == arrStr[0])

`
    Extensions

    Pointers:
        In order to preserve auto dereferencing, extensions cannot be declared
        for arbitrary pointer types.

    Arrays:
        Extensions are perfectly valid for array types, including arrays of
        pointer types, despite sharing the same structure in memory.  
        To use array exts with a pointer, the pointer should be casted 
        to an array type.
`
ext c32[]
    fun reverse: self*, u32 len
        var rev = Str.ofLen(len).cStr
        for i in range(len-1, 0) do
            rev[i] = self[len-i-1]
        rev[len] = '\0'
        self = rev

arrStr:reverse() ~valid

`
ptrStr:reverse()  <- compilation error.  To make this work, a cast should be added

c32[] ptrStr
ptrStr.reverse

`

`
    Comparisons

    Pointers:
        When pointers are checked for equality, their addresses are checked
        for equality.

    Arrays:
        Arrays (unless overloaded) define equality as checking each corresopnding
        element for equality.  Since string literals are character arrays by
        default, the following is always true: "five" == "five"
`
let c32[] strlit = "test"

assert(strlit == "test")


assert("two" is in ["one", "two", "three"])


`
        Function values
    To declare a function pointer, the same syntax as a function
    definition is used, but without the name of the function and
    the : denoting the name.  A function has the type:

    returnType(paramType1, paramType2, ...)
`
~Some functions to point to:
fun mul: f32 a b => f32 -> a * b
fun div: f32 a b => f32 -> a / b

~This function takes one parameter, a function
~that takes two f32s as parameters and returns one as well.
fun doOperation: f32(f32, f32) opFunc => f32
    opFunc(6, 4)

~our function variable
var fnPtr = mul

assert(doOperation(fnPtr) == 24)

fnPtr = div
assert(doOperation(fnPtr) == 1.5)


`
        Algebraic datatypes
    Algebraic datatypes can be declared with the type keyword.
    Any other type can be combined to form an algebraic types.
    The | operator indicates that the type can be either the
    preceeding or the proceeding type.  To combine types in
    an and fashion, tuples can be used.

`

~declare a type str that can be a char array of any size
data Str -> c8[] | c32[]

~declare a type coord that can be an integer or float tuple
~NOTE: the precedence of | is greater than that of ,
data Coord -> (i32, i32) | (f64, f64)

data Maybe
    't | enum -> None

~declare a list type that is a tuple with two indices, the first
~being the value type, and the second being the next List node.
data TList -> 't, Maybe<List<'t>*>

~alternatively, type declarations can name each member of the
~tuple, mimicking a struct.
data List
    't val
    Maybe<List<'t>*> next

data Vec
    't[] mem
    u32 len
    u32 cap

let numsList = List(1u8, &(2u8, &(3u8, None)))



`
        Error Handling
    Functions that can return an error can declare their
    return type as the desired type | error type.  When
    Checking for errors, the operator ? can be used.  This
    operator checks if the value implements the Error trait.
    If so, it returns from the method, otherwise, the value
    is not changed.
`
data MyErr : Err
    const Str msg

    fun op("cast"): Err e => MyErr
        return MyErr(e.desc())

    fun op("cast"): Str msg => MyErr
        return MyErr{msg}

    fun desc: self* => Str
        return "MyErr: " ++ self.msg


~This function takes three parameters: two i32s and
~a function that can return a Str or StrErr
fun errFunc: i32 a b, (Str|Err)(i32) fn => i32|MyErr
    ~Try to open a file, and if no FileErr is found
    ~Then write Just a test, otherwise wrap the error
    ~In type MyErr (using fromErr()), and return it.
    openFile("test")?.write("Just a test")

    ~ ? can also be chained
    Parser()?.parseI32("32")?.map(fn)?.show()
    return 1


~Matches can also be used for error handling in expressions
~In this function, a 0 is returned if a value is divided by 0
fun div: a b =
    a / b with DivideByZeroErr -> 0








`
        Experimental
    These features are being proposed or considered
    but are not yet known to be of enough value to
    include in the language.
`
macro pstr: ident i
    pub const c32* i = "p"
    print(i)

pstr!(g)
~output: p

macro double: expr e
    ((e) * 2)

print(double!(2 + 3))

~possible scoped macros
fun getTokenType: c32 t => Str
    macro isLetter: c32 i
        (i >= 65 and i <= 90 or i >= 97 and i <= 122)

    if isLetter(t)
        return "ident"
    else
        return "not an ident"

~the macro below would not be valid since isLetter would have gone out of scope.
if isLetter('a') then
    print("a is a letter")


~threading and concurrency support
async fun printMsg: Str msg
    print(msg)

sync for i in arr
    print(i)

let f = await someFunction()


~Is keyword/operator for matching types
assert(3 is i32)

~Allow/force names in data declarations to precede types
data Vec
    mem: t
    len: u32
    cap: u32

data List
    val: t
    next: List<t> | End


`
        Keywords
primitive datatypes:
    i8
    i16
    i32
    i64
    u8
    u16
    u32
    u64
    isz
    usz
    f32
    f64
    c8
    c32
    bool 
    void

constants:
    true 
    false

statements:
    if 
    elif 
    else 
    import 
    match
    ext
    
loops: 
    for
    in 
    do 
    while
    continue 
    break

modifiers:
    pub 
    pri 
    pro 
    const
    noinit
    pathogen

datatypes:
    data
    enum

other:
    when
    where
    infect
`

`
        Unused Symbols
@
#
$
|
?

`
