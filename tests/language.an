`
        Ante is an multi paradigm language which includes various elements from
    functional, imperative, and object oriented paradigms.  Each 
    line of code is a statement ending in a newline character.  Expressions 
    such as 3 * (4 + 5) may be part of a statement, but are not valid alone.
    Whitespace is significant if and only if is at the beginning of a line and
    precedes a statement.  Blocks are marked by an increase in indentation, 
    and terminated by a return to the original level (unindent).  An indent is 
    always at least one space more than the previous indentation level.  To avoid
    confusion and misalignments in indentation for different tab sizes, tabs
    are invalid, and cannot constitute any significant whitespace.

        Philosophy
    If something can be done compile time, then it should be.  In other words, 
    constant folding should be employed whenever possible.  If a 1500 line 
    program only produces the output "Hello World" every time then that should 
    be the only thing compiled into the binary.
`

`
    The following is an example of an import statement.  It is importing The
    modules math, io, str, op, and c_ffi which are some of the currently planned modules.
`
import "math", "io", "string", "op", "c_ffi"
`
    Arbitrary strings, string arrays, or even functions returning these values can be 
    imported as long as they can be resolved compile time.
`
import stuff()


~This is an example of a single line comment

`
        Variables
    Variables are declared with any modifiers (such as pub to indicate a
    public visibility) followed by the keyword let and the variables name as
    an identifier.  It is important to note that identifiers must begin
    with a lowercase letter, but can contain any amount of capital and lowercase
    letters or numbers afterwards.  The type is inferred from the expression in
    most cases.  This form can be expressed as the following:

    let [modifiers] [identifier] = [expr]

    Alternatively, if the variable is mutable, the type must be specified.  Note
    that since it is not immutable, its initial value does not have to be
    specified.  All variables by default have their memory set to 0.  In
    cases where speed is more of a concern, the modifier noinit may be
    specified to avoid this.

    [modifiers] [type] [identifier]

    In the rare cases when a constant variable's type cannot be inferenced,
    the following form is used:

    let [modifiers] [type] [identifier] = [expr]

    or:

    const [modifiers] [type] [identifier] = [expr]
`

~Declare i, an i8 since integer constants take the smallest type by default.
let ex1 = 1

~There are several ways to specify a type if it is needed
~The type can be stated before the variables name:
let i32 ex2 = 2

~Or the type of the constant can be specified:
let ex3 = 3i32

~Or the constant can be typecasted to an i32:
let ex4 = i32 4

`
    Types can also be assigned to variables manually.  Variable's declared
    without let are mutable by default and must have their type explicitly
    stated.  Below are mutable variables of every primitive type initialized 
    to their default values.
`

i8  myI8  = 0    ~8bit integer
i16 myI16 = 0
i32 myI32 = 0
i64 myI64 = 0

u8  myU8  = 0    ~8bit unsigned integer
u16 myU16 = 0
u32 myU32 = 0
u64 myU64 = 0

isz myIsz = 0    ~Signed pointer size integer
usz myUsz = 0    ~Unsigned pointer size integer

f16 myF16 = 0.0
f32 myF32 = 0.0  ~32bit IEEE single precision floating point
f64 myF64 = 0.0

c8  myC8  = ''   ~ASCII char 0x00
c32 myC32 = ''   ~UTF-32 char 0x00

bool myBool = false

`
    Any primitive value can also be typecasted to any other primitive type, or
    even completely redefined to that type.
`

print(i32 4.99)  ~output: 4
f32 n = 43.876
i32 n = i32 n

print(typeof(n) ++ " " ++ n)  ~output: i32 43

`
        Modifiers
    Modifiers are optionally included in a variable or function
    definition.  The available modifiers are:

    pub        Most inclusive visibility modifier
    
    pro        Visibility modifier
    
    pri        Least inclusive visibility modifier
    
    const      Declares a constant variable.  Unlike
               a let binding, this assures a space
               is allocated in memory rather than
               using expression substitution.
   
    raw        Declares a pointer or array that is not
               automatically freed by the compiler.

    pathogen   Specifies a variable or function can
               never be evaluated at compile time.
    
    noinit     Specifies a variable should not have
               its memory cleared.  This modifier has
               no function in a let binding.
`

~Declare a public u8 array buf that is not automatically freed.
pub raw u8[] buf = [3, 4, 5]

~Declare an array of 100 integers called naturalNumbers and do not
~initialize it since it is manually initialized in the following loop.
noinit i32[100] naturalNumbers

for i32 i in range(1, 100)
    naturalNumbers[i-1] = i


~Modifiers in let bindings are declared after the let keyword
let raw mem = 0x23, 0x32, 0x00


`
        Constants
    Ante includes integer constants, float constants, char constants
    and string constants.  Integer and float constants can have their
    types chosen by the compiler or alternatively can have their type 
    specified with a suffix.
`
print(typeof(0))      ~output: i32
print(typeof(0u8))    ~output: u8
print(typeof(0i64))   ~output: i64
print(typeof(255))    ~output: u8

print(typeof(3.2))    ~output: f32
print(typeof(3.2f64)) ~output: f64

~Unlike integer literals which leave their type up to the compiler,
~All char and string literals have the type c32 and c32[] by default.
print(typeof("test")) ~output: c32[]
print(typeof('A'))    ~output: c32

~c8[] and c8 literals need to be explicitly casted.
let myC8Str = c8[] "test"

~Integer constants can also be expressed in different bases with the 
~prefixes 0x 0o and 0b for hexadecimal, octal, and binary respectively.
assert(0b110 == 6)
assert(0xFFFF == 65535)
assert(0o31 == 25)

~Integer and float constants in base 10 can also be expressed in
~scientific notatation.
assert(1e-3 == 0.001)
assert(4.5e+2 == 450)
assert(314159265E-8 == 3.14159265)
assert(8.92e2 == 892)

~Underscores are ignored within integer and float literals
assert(1_000_000 == 1000000)
let double = 25.0_f64

`
        Operators
    Ante includes the following binary operators:

        +    addition
        -    subtraction
        *    multiplication
        /    division
        %    remainder

        <    less than
        >    greater than
        <=   less than or equal to
        >=   greater than or equal to
        ==   equal to 
        !=   not equal to
        and  logical and
        or   logical or

        ++   append
        ..   range
        ;    sequencing operator

        |    bitwise or (or a type-expr or)
        ^    bitwise xor
        <<   bitwise left-shift
        >>   bitwise right-shift

    In addition to binary operators, Ante also defines the following
    unary operators.  Note that to avoid ambiguities in parsing, every 
    unary operator is a prefix to the value it acts upon.
        
        -    negative
        not  logical not
        @    pointer dereference
        &    address of
`

`
        Casting
    Casts are accomplished by preceeding a value with a type, similar
    to a variable declaration.  When casting a value, the value is directly
    changed to the corresponding type unless the type specified is a
    userdata type which overloads the op("cast") function with the same
    parameters.  Casts are never performed implicitly.
`

~When casting integer types to one of a larger size, the value is sign
~extended unless it is an unsigned integer, in which case it is zero extended.
let five = i32 5.0

let thirteen = i16(7i8 + 6i8)

i32 add: i32 x y
    return x + y

~thirteen must be explicitely casted to an i32, no automatic widening is performed.
add(five, i32 thirteen)


`
        Arrays

    The syntax for declaring arrays is shown below.  The array arr
    declared below is an array of 30 integers, each initialized to 1

    NOTE: The size must be a non-pathogen integer expression.
`
i32[30] arr = 1

~Each element of an array can also be initialized individually
f32[5] assortedNums = 9, -76, 3.14159265, 2^8, 1 + 2*(6-3)

`
    Each element of an array can be accessed individually by index.  Negative
    indexes work backwards from the end of the array, so arr[-1] will always
    yield the last element of arr.
`
assortedNums[0] += assortedNums[1]
print(assortedNums[0] ++ ", " ++ assortedNums[-2])
~output: -67, 256

`
    Array initializer lists can also be surrounded by [ and ].  This is preferable
    when dealing with multidimensional arrays or tuples.
`
i32[2][2] box = [1, 2], [3, 4]


`
    The size of an array can also be dynamically edited.  The following syntax
    should always be used when expanding or restricting an array.
`
arr += 2
arr -= 3 ~Note: this will throw an exception if the array's size becomes < 0

`
        Tuples
    In addition to arrays, there are also tuples.  Unlike arrays, tuples can
    be mixed and matched with several types, but each must be stated beforehand.
`
i8, f32 tup = 44, 44.0

~NOTE: c32*[2] is an array of two strings, each having a char size of 32.
i8[30], c32*[2] anotherTuple = arr, ["This tuple contains", "two arrays"]

`
    A tuple's type can still be inferred in a let binding:
`
let immutTuple = 46, "Fourty-six", 46.0

~A pointer to a tuple
(i32, i32)* tupPtr = &(0, 0)

`
        Functions

    Functions in ante each have their own scope in addition to the scopes they
    inherit (in this case, only the global scope).  Variables created in
    functions are all local variables.

    Below is the declaration of a function, printMsg.  It takes no parameters
    and returns no value.  It is important to note that unlike many c based
    languages, blocks are denoted by changes in indentation rather than
    opening and closing brackets.
`
void printMsg:
    print("Hello World!")

`
    This add function takes in two parameters, augend and addend, and returns
    a num value.
`
f64 add_floats: f64 augend, f64 addend
    return augend + addend

~Multiple variables of the same type can be declared by omitting the , and repeated type
f64 add_floats_2: f64 augend addend
    return augend + addend

`
    Ellipses can be used in place of or after a type to indicate that the
    function takes a variable amount of arguments.  The variable it is assigned
    to is a tuple by default, but if a type is specified before the ellipses, it
    becomes an array of that type.  In either case, the number of arguments is always
    known at compile time, and can be accessed via .count.  If a function takes 
    a variable amount of parameters, ... can only be the last parameter.  In the
    lnprint function below, params is passed to the print function, with an additional
    newline passed at the beginning.  Note that the print function itself is a varargs
    function, and when printing an array or tuple it will by default print each value
    without a seperator.
`
void lnprint: ... params
    print('\n', params)


i64 sum: i32... nums
    i64 ret = 0
    for i32 i in nums
        ret += i
    return ret


~or alternatively a more functional approach using foldl can be taken.
let sum: nums =
    foldl(nums, (+), 0)

~or even
let sum = reduce(_, (+))

`
    Calling functions is accomplished by specifying the function's name, followed
    by a tuple of its parameter(s).  Function's taking no parameter's need to
    be called with an empty tuple ().
`
lnprint("Test #", add(3, 43), sum(3, 4, 5))
~output: 
~Test #, 46, 12

~Zero-parameter functions need to be called with ()
do_something()

~Functions can also take named parameters
add_floats(addend = 2.5, augend = 5.0)

`
        Control-Flow
    Control-Flow can be altered with the keywords if, elif, else, match, while,
    do while, and for.
`
~If statements come in the form of if <expr> Indent <statement list> Unindent
if 4 > 3
    print("4 is indeed greater than 3")

`
    Multiple elifs can optionally follow an if after the Unindent.  Their syntax is
    the same as an if, except with the keyword elif.  An elif will only be evaluated
    if and only if the first if, and all elifs preceeding the desired case, conditions
    evaluate to false
`
if 3 > 5
    print("3 > 5, what??")
elif 3 > 4
    print("3 > 4, how??")
elif 3 > 3
    print("3 > 3, huh??")
elif 3 > 2
    print("3 > 2, yup.")

`
    In addition to elif lists, a single else may optionally terminate the test cases.
    The else clause always follows either the first if clause or an elif clause, and
    like the elif clause, it may not be used on its own without a preceeding if.  Else
    clauses are executed if and only if non of the above test conditions evaluated to
    true.
`
if 3 > 2
    print("Hello World!")
else
    print("Invalid laws of mathematics, please try again in an alternate universe.")


if 3 > 5
    print("Something is seriously wrong if this prints.")
elif 4 > 5
    print("This shouldn't print either.")
else
    print("Phew, dodged a bullet there.")


`
        Loops

    Ante has three kinds of loops: while, do while, and for.
    The while loop runs while the following expression is true.  The do while
    loop runs once then runs while its following expression is true.  The for 
    loop loops through each element of an array or range.
`
while true
    print("I loop forever")


do while false
    print("I only loop once")

f32 total
for f32 n in arr
    total += n

for i32 count in 0..100
    print(count)


`
        Expressions
    Expressions are pieces of code that return a value, as opposed to statements
    which return no value.  Expressions can be any length from a single value to
    a complex expression containing many operations.  Expressions are expected
    inside several statements, namely variable declarations/assignments, let
    bindings, if conditions, and loop conditions.  Expressions are usually
    terminated with a Newline or an Unindent token, although they may be extended
    by ignoring a newline with \, or with an Indent and matching Unindent token.
`

~A simple expression consisting of only the I32 0
let zero = 0

~If statements can be used within expressions, albeit with a slightly altered syntax
let stoplight = "go" if light == "green" else "stop"

~Expressions can also be more complex
~Here is an example of a function declaration with a let binding.
let takeWhile = \f l
    [] if !f(l[0]) else
    l[0] ++ takeWhile(f, l[1..])

`
        Pathogen infections
    Pathogen is a modifier given to a function which can never be evaluated
    compile time.  Examples include io functions such as print and read.  When
    called within another function, the pathogen function infects that function
    as well, making it a pathogen function without the need to explicitly
    declare it as such.  The implicit pathogen function is said to be infected.
    The pathogen modifier is usually only used in rare cases such as defining your 
    own print function without utilizing the standard api, or using an external c api.  
    While less common, the pathogen modifier may be used for variables, classes, enums, etc.
`
pathogen void myPrint: c32* msg
    i32 i = 4 + 2
    system("echo '" ++ msg ++ "'") ~note: system is already a pathogen function

~Because the following function uses the pathogen myPrint, it cannot be
~evaluated compile-time, so the system call to echo 'Hello World' will
~occur during run-time.
void printMsg:
    myPrint("Hello World!")

~To use a pathogen function without the host becoming infected, the keyword do
~is used when calling a pathogen or infected function.  This compile time evaluation
~of pathogen functions can be useful in several applications, such as loading an image
~into a variable or class representing it without the need to search for it during runtime,
~and eliminating the need to include the raw image as an asset in production.
Image* compileTimeLoadImg:
    File f = File("path/to/image.png")
    u8[] imgData
    do f.readAll(imgData) ~Reads all of the image data into data at compile time
    return new Image(imgData)

~Conversely, to infect a non-pathogen function, the infect keyword may be used.
~Note that only the infected instance of the function is evaluated during runtime.
Image* runTimeLoadImg:
    return infect compileTimeLoadImg()

~Values can also be infected if set equal to the return value of a pathogen function
let myImg = runTimeLoadImg()
someFunction(myImg) ~This instance of someFunction is infected since an infected parameter is used.


`
        Compile-Time only statements
    There are some scenarios where it is desirable for certain statements
    to only be evaluated during compile-time, without being compiled into
    the final binary.  This is accomplished with the when keyword.  When is
    syntactically similar to if, but with the key difference that it must
    be able to be evaluated compile-time (ie no pathogens).
`

`
    The following function takes two parameters, and if m is negative, panics
    with the message "calculateForce: mass cannot be negative!", and fails to
    compile.

    ~NOTE: a better method of ensuring m is positive is using the where
           statement discussed later.
`
f64 calculateForce: f64 m a
    when m < 0
        panic("calculateForce: mass cannot be negative!\nError value: " ++ m)
    return m*a

~when true  can be used to perform a generic check during compile time
i8 add: i8 a b
    when true
        i16 c = a
        i16 d = b
        if c + d > 255 or c + d < -256
            panic("Likely integer overflow in add function.")
    return a + b


`
        C FFI
    The c foreign function interface is implemented within the c_ffi module.
    Once this module is imported, objects can be created of the C class.
    This class contains the header(s) to parse, and possibly specific
    functions from that header.  Since the object is primarily used for
    its overloading of import, its contents must be known at compile-time.
`

~By default, the file is parsed and every function is added.
import C("path/to/file.h")

~Alternatively, specific functions can be whitelisted with .fn
import C("some/other/file.h").fn("func1", "func2", "func3")

~Multiple files can also stored in one C object
import C("stdio.h", "stdlib.h")

putchar(72)
putchar(105)
putchar(10)
~output: Hi


`
        -> and ;;
    -> and ;; can be used to manually insert indent and unindent tokens
    respectively.  -> is commonly used in single line blocks, but ;; is much
    more rare, being added to simplify the declaration of enums within a data
    declaration with multiple fields.  Both -> and ;; change the indentation level
    in addition to issuing the token.  Doing so with -> ensures an unindent token
    is automatically issued once a statement is encountered on the same line as
    the one containing the ->.  With a ;; an Unindent is introduced followed by
    an Indent if the next statement returns to the normal level.
`
if 5 > 2 -> print("5 is greater than 2")
else     -> print("Invalid laws of mathematics, please try again in an alternate universe")

for f32 f in arr -> print(f)

f32 subtract: f32 a, f32 b -> return a - b

~While these can be nested, overnesting should be avoided as it leads to clutter.
data Integer -> i32 i, void init(): i32 a -> i = a;; u8 byte

~compared to
data Integer
    i32 i

    void init(): i32 a
        i = a

    u8 byte

`
        Data declarations
    In ante, all datatypes are declared through the data keyword which binds a 
    name to a type expression.  This binding must begin with a capital letter 
    and be succeeded by zero or more alphanumeric characters or underscores.
    A data declaration consists of one or more type expressions seperated by 
    the field names for those expressions.
`

~Declare coord, a datatype consisting of three f64s named x, y, and z.
~NOTE: just as in functions, multiple variables of the same type can be declared
~      by seperating the field name with spaces. if an = is encountered 
~      afterwards, each of the variables will be set to that default value.
data Coord
    f64 x y z

~Declare Char, a datatype that can contain a c8 or c32 char
data Char
    c8|c32 c

let ch = 'a'


data Coord2D
    f32 x
    f32 y

~Anonymous fields can be declared simply by neglecting to give each field a name.  Anonymous
~fields can only be accessed with [] as tuple indices.
data Q1Coord
    u32
    u32

let myQ1C = (2, 3)
print(myQ1C[1]) ~output: 3

~Each datatype containing more than one field is internally represented by a tuple, so they
~Can be created in a similar fashion.
Coord coord = (100.0, -50.0, 66.7)
print(coord.y)  ~output: -50

~To access a specific field of an anonymous datatype in an expression, it must be casted to
~the desired type.
let y = Coord(100, -50, 66.7).y

~Set p1 p2 and p3 to 0, 0
i32,i32 p1 p2 p3 = (0, 0)


`
        Ranges and Type Conditions
    Ranges are denoted by start and end values surrounded by the .. operator.
    Ranges declared in this fashion have an inclusive startpoint and exclusive
    endpoint.
`

~Print 0 to 99 inclusive
for i32 i in 0 .. 100
    print(i)


~Iterate through indexes of an array:
let testArr = [0, 3, 5, 6]

for u32 u in 0 .. testArr.len()
    print(testArr[u])


~Ranges can also be used in combination with the in keyword to test if a given value
~is within the range
if 3 in 1..10
    print("3 is a single-digit positive number")


~in can also test if a value is in an array or tuple
if "two" in ["one", "two", "three"]
    print("Found it!")

`
    Type Conditions are signified with the where keyword and provide a concise way to
    verify the value of a variable.  Where is always followed by the boolean expression
    to be checked.
`
data Teen
    u8 age  in 10 .. 19
    Str name  where name.length > 0

let john = Teen(15, "John Brown")

~TypeConditionErr
let sara = Teen(18, "")


~Create a datatype TwoDigits that represents a number that is between
~10 and 99 inclusive.
data TwoDigits
    u8 in 10..99

let td1 = TwoDigits(32) ~Good!
let td2 = TwoDigits(100) ~RangeErr


~Type conditions with anonymous fields:
data LongStr
    Str where this.length > 10

~Type conditions are evaluated whenever the corresponding field is changed.
data Q2Coord
    i32 where this[0] < 0
    i32 where this[1] > 0

Q2Coord q = -4, 5
q[0] = 2 ~where this[0] < 0 is evaluated, and a TypeConditionErr is thrown.

`
        Classes
    Class-like data structures can be declared by simply including methods within the
    data declaration.  These methods are associated methods and do not add to the size of
    the datatype, but are linked to it at compile-time.  These methods are each within a namespace
    that is the name of the datatype, but cannot be accessed without an initialization of the
    datatype if they take self as a parameter.
`
data Animal
    u16 age
    c8* species
    c8* name

`
    Create a static function init that creates a new instance of an animal.
`
    Animal init: u16 age, c8* species name
        return Animal(age, species, name)
        
`
    Create a non-static method taking self as a parameter.  This function cannot be used as 
    Animal.printInfo, it must be called on a previously initialized Animal.
`
    void printInfo: self
        print(self.name .. " is a/an " .. self.species .. " and is " .. self.age .. " year(s) old.\n")

`
    The new keyword can be used to allocate and initialize memory to be stored in a
    pointer type.
`
Animal* clifford = new Animal.init(7, "magnum rubrum canis", "Clifford")


`
    Datatypes can also inherit from other datatypes with the : operator.
`
data Person : Animal
    c8* job

    Person init: u16 age, c8* job name
        Person ret = Animal.init(age, "Homo sapien", name)
        ret.job = job
        return ret

`
    This function obscures the printInfo declared in the Animal type.
`
    void printInfo: self*
        print(self.name .. " is " .. self.age .. " years old and is a(n) " .. self.job)


`
    Methods of the same name can also be overloaded if they take different amounts or types of variables.
`
    void printInfo: self*, bool showAge
        if showAge
            print(self.name .. " is " .. self.age .. " years old and is a(n) " .. self.job)
        else
            print(self.name .. " is a(n) " .. self.job)


Person john = Person.init(44, "electrician", "John")
john.printInfo() ~output: John is 44 years old and is a(n) electrician

`
        Modifiers in data declarations
    Modifiers modify the behaviour of a particular instance of a variable, and 
    are listed before its type.  The visibility modifiers pub, pro, and pri are 
    short for public, protected, and private respectively.  Pri variables can only
    be accessed by associated methods within the data declaration or impls.  Pub 
    variables are the default and can be accessed from anywhere.  Pro variables can
    be accessed by the datatype and any inheriting datatypes.  Another common modifier 
    is const to declare a constant variable.

    Modifiers can be placed before a variable or function, or alternatively
    can be placed before a new block to modify everything within the block
`
data Statistics
    ~declare secretData as a private variable, only able to be accessed
    ~from within member functions (methods).
    pri f64 secretData

    pro const f32 pi = 3.14159265
    
    pub i32 varCount

    ~Alternatively, you can also use modifiers before a block:
    pub
        f64 getData: self*
            return self.secretData ~not so secret anymore

        c8* getStatus: self*
            if self.secretData > 10
                return "Good"
            else
                return "Not so good"

    pri f64 doCalculations: self*, f64 mData
            return mData * self.secretData / self.varCount

    ~Because the init function is declared within the datatype, it can access private members.
    Statistics init: i32[] mData
        Statistics ret = `secretData =`0, `varCount =`0
        for i32 i in mData
            ret.secretData += mData / ret.pi
            ret.varCount += 1
        return ret

`
        Type Specifications, Generics, Where, and Operator Overloading
    Type specifications in ante are a powerful way to specialize a class or function
    to a specific usage.  In its most general case, it can be used in much the same
    way as generics or templates in other object oriented languages.  To declare a type
    specification for a class, parenthesis are used after the class name.  Within the
    parenthesis a type is binded to a name, and an optional boolean expression which
    must be able to be evaluated at compile time.  For functions, the keyword where is
    used followed by the name of the type in question and a boolean statment validating
    that the type is valid for the function.
`
~For functions, the where keyword always comes at the end of the list of parameters.
~where statements are evaluated at compile time whenever possible.  If the expression after
~where evaluates to false, an error is thrown.
let actions = "walk", "talk", "stand"

c32[] getAction: u8 action  where action >= 0 and action <= 3
    return actions[action]


~Here is the calculateForce function from earlier
f64 calculateForce: f64 m, f64 a
    ct
        if m < 0
            myPrint("calculateForce: mass cannot be negative!")

    return m*a

~and this is its equivilent using where
f64 calculateForce: f64 m a  where m >= 0
    return m*a

calculateForce(-54, 2)
`
Exception thrown when the where condition is not met:

function calculateForce: f64 m, f64 a requires the condition
m >= 0
which was not met for input value m = -54
`

`
        Generic Functions
    Generic Functions can be a powerfull tool to recompile a function for a given
    argument (usually a type) during compile time.  These functions are expressed
    with the use of type variables.  Unlike user types which must begin with an
    uppercase letter, type variables are variables and thus must begin with a
    lowercase letter.  Once declared, a type variable can be used until it
    falls out of scope.
`
~Create a function that takes in two variables, obj1 and obj2, of some type t
~and returns true if the first is greater than the second.
bool greater: t obj1 obj2
    return obj1 > obj2

~This function will fail to compile if they are called with variables of a type
~That do not have < and > implemented.
bool cmp: t v1 v2
    if v1 < v2 -> return -1
    return v1 > v2

cmp(3, 4) ~valid
~cmp(3, "three") ~invalid: types must be the same for function cmp


~Each of the above functions assert that the two variables passed have the same type,
~and have > implemented to return a bool.  This may not always be the case if the user
~defines the operator to return a different type or overloads the operator function for
~two different types.  Here is a more general definition that takes this into account.
gen add: t1 a, t2 b
    return a + b


~The syntax for type specifications in a class is to surround them in < and >.
~In the Angle class, each time it is initialized, a bool is specified as true if the
~angle is in radians, false otherwise.  This determines how Angle is compiled and
~cannot be changed after initialization.
data Angle<bool isRadians>
    f32 angle

    if isRadians
        u8 getQuadrant: self
            return self.angle / (3.14159265 / 4) % 4 + 1
    else
        u8 getQuadrant: self
            return self.angle / 90 % 4 + 1
~usage:
Angle<true> a1 = 3.14159265 * 2 / 3
Angle<false> a2 = 120
assert(a1.getQuadrent() == a2.getQuadrent())

`
    The use of type specifications eliminates the need to store excess metadata about
    the object to be checked each time a function runs as well as encouraging classes
    to be more specialized without having several copies of otherwise very similar
    classes, eg. having a AngleDegrees and AngleRadians class seperate then having
    to worry about them interacting properly.  In this usage, type specifications
    act by creating a parent class Angle, and two child classes, Angle<true>, and
    Angle<False>, which correspond to AngleRadians and AngleDegrees.
`


`
    To have a data structure with a member of variable type, type variables can also
    be used.

    NOTE: Ante implements smart pointers by default, so this class is meant to show
          how one could be implemented without this feature (eg. if it disabled).
`
data MySmartPtr : Clone
    t* rawPtr
    pri u16* refCount

    void op("new"): T val
        rawPtr = alloc(val)
        refCount = new 0u16

    void op("drop"):
        if @refCount == 0
            free(refCount)
            free(rawPtr)
        else
            @refCount -= 1

    ~Required by Clone trait
    MySmartPtr clone: self
        let clone = MySmartPtr(rawPtr, refCount)
        self.@rawPtr += 1
        return clone


~where can also be used to check the type specification
data ChessPiece<Str piece> where searchFor(piece, ["pawn", "knight", "king"]) != None
    u8 x
    u8 y
    
    ChessPiece<piece> init: u8 x, u8 y
        return ChessPiece<piece>(x, y)
    
    if piece == "pawn" 
        bool validateMove: u8 x2, u8 y2
            return x == x2 and abs(y - y2) == 1

    elif piece == "knight"
        bool validateMove: u8 x2, u8 y2
            if abs(x - x2) == 1
                return abs(y - y2) == 2
            return abs(x - x2) == 2 and abs(y - y2) == 1
    
    elif piece == "king"
        bool validateMove: u8 x2, u8 y2
            return abs(x - x2) <= 1 and abs(y - y2) <= 1


ChessPiece<"knight"> knight = ChessPiece(2, 3)
assert(validateMove(3, 5))

`
        Operator Overloading and Infix Functions
    Note that the cmp example above requires that the operator < is implemented for
    the two objects.  To do this we must implement operator overloading.  In the
    following example, the class Point is created and overloads the > and < operators,
    and creates the new infix function cmp for comparisons.
`
data Point
    pub i32 x, y

    `
        Now to implement the < operator. Each operator is declared as a function 
        with the name generated by the function op which is imported from the 
        op module. This function requires the operator in question in string form.  Invalid
        operators will throw a compile-time error.  Note that since operators are declared
        within classes, operators for primitive datatypes cannot be redefined.
    `
    bool op('<'): self, Point rVal
        if self.x < rVal.x
            return 1
        return self.y < rVal.y

    bool op('>'): self, Point rVal
        if x > rVal.x
            return 1
        return y > rVal.y

    `
            Infix functions
    
        Infix functions are declared by calling the 'infix' function.  This
        function takes one parameter, the name of your function.  The precedence
        of an infix function is extremely high, as if both parametrs were surrounded
        by parenthesis.  The example  4^6 plus 3%9 would be parsed as (4^(6 plus 3))%9
    `

    ~An example of a generic comparison function
    ~Note that this function uses the > and < operators
    ~declared earlier in this class.
    i8 infix('cmp'): self, Point rVal
        if self < rVal -> return -1
        return self > rVal


Point origin = 0, 0
Point topRight = 3, 4

print(origin < topRight)
print(origin > topRight)

print(origin cmp topRight)
`output
true
false
-1
5
`

`
        Implementations
    The impl keyword can be used to extend any type with additional methods, 
    but no new instance data can be added for congregate datatypes.  A common 
    usage of this would be extending an API to implement a function or even inherit
    from an additional parent class as long as it has no instance data.
`
impl Point : SomeAdditionalTrait
    ~implement new methods
    bool op("=="): self, Point p2
        return self.x == p2.x and self.y == p2.y

trait Drawable
    void draw: self

    ~Default definitions for traits can also be created.
    ~NOTE: because self.surface is accessed, this requires the implementing object
    ~      to either have a 'surface' field, or override this function.
    s getSurface: self
        return self.surface

data Rectangle
    u32 height
    Surface surface

impl Rectangle : Drawable
    ~Now Rectangle must implement the methods of Drawable
    void draw: self
         self.surf.print("___")
         for u32 i in 0 .. height
            self.surf.print("| |")
         self.surf.print("|_|")

    void setHeight: mut self, u32 newHeight
        height = newHeight

    Rectangle cast(): u32 height
        return Rectangle
            height = height,
            surface = Surface()

Rectangle r = Rectangle(4)

~Mutator functions are differentiated from accessors
r:setHeight(5)


~Mutator functions cannot be used with constant variables
let immutRect = Rectangle(3)

~Error here!
immutRect:setHeight(5)


~Implementations can also be used for primitive types
impl i32, i32
    void swap: self
        print("Swapped i32!")
        return self[1], self[0]

impl e, e
    void swap: self
        print("Swapped pair!")
        return self[1], self[0]

~In the case multiple impls apply, the most specific is always chosen
~If there are multiple equally specific impls, a compile-time error is thrown.
let point = (3,4).swap()
~output: Swapped i32!

assert(point[0] == 4 and point[1] == 3)

~The only limitation on implementations is that it cannot be used for pointer types.
~Pointers will be automatically dereferenced if their dereferenced type has a valid
~implementation, otherwise a compilation error will result.

impl c32* ~invalid
    c32* addInitials: self
        return self ++ " -JF"

impl c32[] ~valid
    c32[] addInitials: self
        return self ++ " -JF"


c32* ptrQuote = "implementations cannot be used for pointer types"
 
~Compilation error since c32 has no function addInitials:
ptrQuote = ptrQuote.addInitials()

c32[] ptrQuote ~convert to array
ptrQuote.addInitials() ~valid

`
    NOTE: because string literals have the type c32[], the following is valid:

    c32* ptrQuote = c32* "implementations cannot be used for pointer types".addInitials()
`


`
        Pattern Matching
    Pattern matching can be accomplished with the match keyword.
    This attempts to match the input value to any valid type or
    value it comes across.  Each candidate is indented relative
    to the match keyword, and their associated statements are
    indented relative to themselves.  To save space for short
    statements, it is reccomended to use the -> token.
`

i8 testInt = 3
match testInt
    1 -> print("Yup, its one")
    2 -> print("It's actually two")
    3 -> print("Nope, it's three")
    4 .. 10 -> print("It's between 4 and 10 inclusive")
    _ -> print("It's not one, two, or three, or in the range 4-10")
~output: Nope, it's three

~In this example, match is used to determine Joe's class
Person joe = Person(32, "Programmer", "Joe")
match joe
    Point  -> print("Joe is a point")
    Animal -> print("Joe is an Animal")
    Person -> print("Joe is a Person")
    _      -> print("I don't know what Joe is")
~output: Joe is an Animal
~This is because the Person class inherits from the Animal
~class, so the Animal cast to joe was the first valid cast

data MyStr
    c32* s
    u32 len

MyStr testStr = "Test", 4

match testStr
    MyStr("Test", 3)
        print("This will not be matched")
    MyStr("Testing", _)
        print("This will not be matched either")
    MyStr("Test", 4")
        print("This will be matched")


~Match can also be used in expressions
let s = match 2
    0 -> "zero"
    1 -> "one"
    2 -> "two"
    _ -> "other"
`
        Enums
    Where data declares a named type, enums declare named
    values.  The values declared are represented by integers
    internally.  The specific integer for each value can also
    be manually set using the assignment operator.
    
    The values within an anonymous enum are exported into the global
    namespace.  Values within a named enum are exported under
    the namespace of the same name.

    Note that since enums only declare named values, they do
    not yet have an associated type, but can still be used
    as integers.  To declare a type, use a data declaration
    in combination with an enum.

    Indentation is required after the enum keyword in an anonymous enum,
    or after its name in a named enum.
`

~Export each suit into the namespace Suit
~NOTE: since Suit is not declared as data, it is not its own type.
enum Suit -> Diamonds, Hearts, Spades, Clubs

print(Suit.Spades)  ~output: 2

data Card
    u8 number
    i32 suit

Card fourOfHearts = 4, Suit.Hearts
i32 suit = (Card(3, Suit.Hearts)).suit
~Enums are automatically assigned values, but can also be manually assigned with the
~ = operator after the first operand.  Each consecutive member will have a value equal
~ to its distance from the fist + the first's value.
enum Numbers
    One   = 1
    Two~  = 2 (inferred)
    Three~= 3
    Four~ = 4
    Five~ = 5

~   number = 3
i32 number = Three

~Alternatively, if the first and second's value are given then each consecutive member
~Is incremented by their difference instead of 1.
~Note the double indentation after enum.  The -> after EvenNumbers increments the
~indentation level by 1, and enum requires another.
data EvenNumbers -> enum
        Two = 2
        Four = 4
        Six~ = 6
        Eight~ = 8, and so on
        Ten, Twelve, Fourteen

~           evenNumber = 12
EvenNumbers evenNumber = EvenNumbers.Twelve

`
        Pointers
    Pointers are created by adding an * directly after the datatype,
    without any whitespace.  Pointers are smart pointers by default and
    will be automatically freed.  If a raw pointer is wanted, it can be
    created with the raw modifier.
`


let five = 5
let ptrToFive = &five
~The unary & operator gets the location of the value 5, which is on the stack in this case.

~The new keyword automatically allocates data for a class or struct and calls its
~constructor if it has one.
let tod1 = new Card(3, Suit.Diamonds)

~alternatively, data can be manually allocated.  The following is equivilent
~to the statement above
let tod2 = malloc(sizeof(Card))
@tod2 = Card(3, Suit.Diamonds)

~Example of a raw pointer to the u8 value 5.
let raw example = new 5u8

~Raw pointers must be manually freed with the free function
free(example)

~Pointers are also used to create strings as char arrays
~Since there are multiple sizes of chars, the dfeault
~encoding (from single byte to 4 byte UTF-8) can be specified.
~The default encoding for string literals is 4 byte UTF-8
let c32[] str = "Hello World!"
let c8[] msg = c8[] "Condensed String"

`
        Automatic dereferencing.
    When accessing a member function through a pointer to an object,
    dereferences are automatically added, eliminating the need for a
    seperate member accessor operator for pointers (-> in c like
    languages).
`
data PtrExample
    c8[] msg

    void printMsg:
        print(msg)

PtrExample ex1 = msg
PtrExample* ex2 = new ex1
PtrExample** ex3 = new ex2

ex1.printMsg() ~No pointer, so no dereferencing is necessary
ex2.printMsg() ~(@ex2).printMsg()
ex3.printMsg() ~(@@ex3).printMsg()

`
        Pointers and Arrays
    Internally, pointers are stored the same way as arrays.
    They only differ based on the operators used on them.  Conversions
    between array and pointer are zero cost, they simply change how they
    interact with operators or impls.
`

~Both of these strings are stored as pointers to the first c32.
c32[] arrStr = "str"
c32*  ptrStr = c32* "str"

`
    += operator
    
    Pointers:
        increments the address pointed to by b bytes, where b
        is the integer result of the evaluated expression.  
    Arrays:
        Allocates additional capacity for one element to the end
        of the array, and inserts the rvalue into that slot.
`
ptrStr += 1
arrStr += "element 2"

`
    [] operator

    Same behaviour in pointers and arrays.  Fetches the element 
    at address pointer + b*sizeof(element), where b is the integer
    expression evaluated between [ and ].  Bounds checking is
    not employed at runtime for either.
`
assert(ptrStr[0] == arrStr[0])

`
    Implementations

    Pointers:
        In order to preserve auto dereferencing, impls cannot be declared
        for arbitrary pointer types.

    Arrays:
        Impls are perfectly valid for array types, including arrays of
        pointer types, despite sharing the same structure in memory.  
        To use array impls with a pointer, the pointer should be casted 
        to an array type.
`
impl c32[]
    void reverse: self, u32 len
        raw c32[] rev = malloc((len+1) * sizeof(c32))
        for u32 i in range(len-1, 0)
            rev[i] = self[len-i-1]
        rev[len] = '\0'
        self = rev

arrStr.reverse() ~valid

`
ptrStr.reverse()  <- compilation error.  To make this work, a cast should be added

c32[] ptrStr
ptrStr.reverse

`

`
    Comparisons

    Pointers:
        When pointers are checked for equality, their addresses are checked
        for equality.

    Arrays:
        Arrays (unless overloaded) define equality as checking each corresopnding
        element for equality.  Since string literals are character arrays by
        default, the following is always true: "five" == "five"
`
let c32[] strlit = "test"

assert(strlit == "test")


assert("two" in ["one", "two", "three"])


`
        Function pointers
    To declare a function pointer, the following syntax is used:

    returnType(paramType1, paramType2, ...) name

    Notice the absence of the *, which is implied since it is not
    possible in ante to store a function on the stack.
`
~Some functions to point to:
f32 mul: f32 a, f32 b -> return a * b
f32 div: f32 a, f32 b -> return a / b

~This function takes one parameter, a function pointer 
~that takes two f32s as parameters and returns one as well.
f32 doOperation: f32(f32, f32) opFunc
    return opFunc(6, 4)

~our function pointer
f32(f32, f32) fnPtr = mul

assert(doOperation(fnPtr) == 24)

fnPtr = div
assert(doOperation(fnPtr) == 1.5)


`
        Algebraic datatypes
    Algebraic datatypes can be declared with the type keyword.
    Any other type can be combined to form an algebraic types.
    The | operator indicates that the type can be either the
    preceeding or the proceeding type.  To combine types in
    an and fashion, tuples can be used.

`

~declare a type str that can be a char array of any size
data Str -> c8[] | c32[]

~declare a type coord that can be an integer or float tuple
~NOTE: the precedence of | is greater than that of ,
data Coord -> (i32, i32) | (f64, f64)

data Maybe
    t | enum -> None

~declare a list type that is a tuple with two indices, the first
~being the value type, and the second being the next List node.
data TList -> t, Maybe<List<t>*>

~alternatively, type declarations can name each member of the
~tuple, mimicking a struct.
data List
    t val
    Maybe<List<t>*> next

data Vec
    t[] mem
    u32 len
    u32 cap

let numsList = List(1u8, &(2u8, &(3u8, None)))

`
        Multiline expressions/statements
    Statements are normally terminated by a newline
    character, but can be extended by adding a backslash
    right before the newline as the final character.  Expressions
    on the other hand can also be extended with an expression block,
    an indentation and expression with a terminating unindent in
    place of a value.  Because the expression is seperated by the
    Indent and Unindent tokens, there is an implicit () grouping around
    the expression.
`

~Functions can be declared this way using lambda syntax
let square = lambda x
    x*x



data Num -> i8  | i16 | i32 | i64 \
          | u8  | u16 | u32 | u64 \
          | f32 | f64


data Int -> i8  \
          | i16 \
          | i32 \
          | i64

`
        Expression blocks.
    In addition to the above, an expression ending in a binary operator
    (without its right operand) may be continued with an Indent.  After
    this Indent is an expression block where newlines are ignored until
    the terminating Unindent.  These expression blocks may also be
    nested.
`
print(
    "Hello ",
    "World!"
)

let result = 
    if someReallyLongFunctionNameThatShouldProbablyBeShorterInHindsight()
        "branch " ++ 1
    else
        "branch " ++ 2


let result = 2 *
    3 *
    4 *
        1+2+3+4+5
    * 5

~Since nested expression blocks are parsed similarly to parenthesis,
~The resulting order of operations would look like the following:
~ 2 * 3 * 4 * (1+2+3+4+5) * 5


`
        Error Handling
    Functions that can return an error can declare their
    return type as the desired type | error type.  When
    Checking for errors, the operator ? can be used.  This
    operator checks if the value implements the Error trait.
    If so, it returns from the method, otherwise, the value
    is not changed.
`
data MyErr : Err
    const Str msg

    MyErr op("cast"): Err e
        return MyErr(e.desc())

    MyErr op("cast"): Str msg
        return MyErr{msg}

    Str Err.desc: self*
        return "MyErr: " ++ self.msg


~This function takes three parameters: two i32s and
~a function that can return a Str or StrErr
i32|MyErr errFunc: i32 a b, (Str|Err)(i32) fn
    ~Try to open a file, and if no FileErr is found
    ~Then write Just a test, otherwise wrap the error
    ~In type MyErr (using fromErr()), and return it.
    openFile("test")?.write("Just a test")

    ~ ? can also be chained
    Parser()?.parseI32("32")?.map(fn)?.show()


`
        Experimental
    These features are being proposed or considered
    but are not yet known to be of enough value to
    include in the language.
`
macro pstr: ident i
    pub const c32* i = "p"
    print(i)

pstr!(g)
~output: p

macro double: expr e
    ((e) * 2)

print(double!(2 + 3))

~possible scoped macros
c32* getTokenType: c32 t
    macro isLetter: c32 i
        (i >= 65 and i <= 90 or i >= 97 and i <= 122)

    if isLetter(t)
        return "ident"
    else
        return "not an ident"

~the macro below would not be valid since isLetter would have gone out of scope.
if isLetter('a')
    print("a is a letter")


~possible new c_ffi syntax
pathogen void c_ffi("putchar"): u8

~lambda functions
lambda: i32 x -> return x + 50
|i32 x| -> return x + 50
\x -> x + 50

i32(i32, i32) addFn = |i32 x, i32 y| -> return x + y
i32(i32, i32) addFn = |x, y| -> return x + y
i32(i32, i32) addFn = \x y -> x + y

~alternate c_ffi declaration
pathogen void* c_ffi("malloc"): u32 size

~syntax change for type casts to distinguish them from declarations
f32 f = 7 as f32
f32 f = (f32)7

~threading and concurrency support
async void printMsg: str msg
    print(msg)

sync for i32 i in arr
    print(i)

f32 f = await someFunction()

~pssible ternary operator
f32 f = x+2 if x > 0 else x-2

f32 f = if x > 0
    x + 2
else
    x - 2

f32 f = x > 0 ? x + 2 : x - 2

~Is keyword/operator for matching types or values
assert(3 is i32)
assert(5 is 5)
~Could be called as the comparison for match statements

~Allow/force names in data declarations to precede types
data Vec
    mem: t
    len: u32
    cap: u32

data List
    val: t
    next: List<t> | enum -> end

~vs
data List
    t val
    List<t> | enum -> end
    next

~or
data List<type T>
    T val
    List<T> | enum -> end;; next

~WIth type constructors:
data List
    List: t val, List<t> l
    End: None

~Possible alternate enum syntax
data None = enum Empty

~Possibly allow (force?) = for single-line declarations
data MyEnum = enum
    One = 1, 
    Two = 2,
    Three,
    Four,
    Five

i32 add: i32 a b = return a + b

i32 add: i32 a b =
    return a + b

~New enum syntax to simplify named enums in data
data Numbers -> enum(One, Two, Three)

data Numbers -> enum{One, Two, Three} num

~Original for comparison:
data Numbers -> enum -> One, Two, Three;; num


~Possible syntax change for comments and multiline comments

~ STYLE 1
#single line comment or pre-proc statement

#[
    multi-line comment1
]

#[
#   stylish multi-line comment
#]
 
~ STYLE 2
{ comment }

{
    multi-line comment
}

{
|   stylish multi-line comment    
}

`
        Keywords
primitive datatypes:
    i8
    i16
    i32
    i64
    u8
    u16
    u32
    u64
    isz
    usz
    f32
    f64
    c8
    c32
    bool 
    void

constants:
    true 
    false

statements:
    if 
    elif 
    else 
    import 
    match
    impl
    
loops: 
    for
    in 
    do 
    while
    continue 
    break

modifiers:
    pub 
    pri 
    pro 
    const
    noinit
    pathogen

datatypes:
    data
    enum

other:
    when
    where
    infect
`

`
        Unused Symbols
@
#
$
|
?

`
