`
    stdlib.an
        Experimental stdlib functions and tests
`

~math module
import "math"

i32 testInt = 4
f32 testFlt = 1/3.0

assert(sqrt(testInt) == 2)
assert(pow(testInt, 3) == 64)

assert(floor(testFlt) == 0)
assert(ceil(testFlt) == 1)


~io module
import "io"

print("Hello World!\n")
print(3)

~print as varargs function
print("Test #", 1, '\n')

~Or concatenate everything to one string
print("Test #" ++ 2 ++ '\n')

File* f = new File("out.txt", File.write)
f.print("2 + 3 = 5")

~Errors return as seperate values
File|Err findFile: Str dir
    if os.fileSearch(dir)
        return File(os.read(dir), File.read)
    return Err("File " ++ dir ++ " not found.")

~Set file to findFile, unless findFile returns an Err,
~In which case stop function execution and return the Err
let file = findFile("test.txt", File.read)?

~Try to write to the file, but if write returns an Err,
~print it
file.write("I only have read permissions")
    @Err e -> println(e)


~Execute void function in expression
i32 i = print("hi"); 4

~string module
import "string"


~Example declaration of Str
const data Str
    u32 len
    c32[] rawStr


impl Str
    Str op("cast"): c32[] str
        return String(str.length(), str)

    Str op("cast"): i32 int
        return String(stoi(int))

    Str op("cast"): c32 c
        return String(1, [c])


void print: Str... strs
    for Str s in strs
        for c32 c in s
            putchar(c)


Str msg = "Hello World!"

msg = msg.repl("Hello", "Goodbye")
assert(msg == "Goodbye World!")

~op module
import "op"

impl Str
    ~Set ! to function as an isEmpty method
    bool op('!'): self*
        return self.len == 0

    Str pop: self* where self.length > 0
        return self[0 .. this.length-1]


~c_ffi module
import "c_ffi"

~Create a C file object, defined in c_ffi, holding cstdio and cstdlib to import.
import C("cstdio", "cstdlib")

putchar(65)
putchar(110)
~output: an
