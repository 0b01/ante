`
    stdlib.an
        Experimental stdlib functions and tests
`

~math module
import "math"

i32 testInt = 4
f32 testFlt = 1/3.0

assert(sqrt(testInt) == 2)
assert(pow(testInt, 3) == 64)

assert(floor(testFlt) == 0)
assert(ceil(testFlt) == 1)


~io module
import "io"

print("Hello World!\n")
print(3)

~print as varargs function
print("Test #", 1, '\n')

~Or concatenate everything to one string
print("Test #" ++ 2 ++ '\n')

File* f = new File("out.txt", File.write)
f.print("2 + 3 = 5")

~Errors return as seperate values
fun findFile: Str dir => File|Err
    if os.fileSearch(dir)
        return File(os.read(dir), File.read)
    return Err("File " ++ dir ++ " not found.")

~Set file to findFile, unless findFile returns an Err,
~In which case stop function execution and return the Err
let file = findFile("test.txt", File.read)?

~Try to write to the file, but if write returns an Err,
~print it
file.write("I only have read permissions")
    @Err e -> println(e)


~Execute void function in expression
i32 i = print("hi"); 4

~string module
import "string"


~Example declaration of Str
type Str =
    u32 len
    c32[] rawStr


ext Str
    fun cast(): c32[] str = String(str.length(), str)

    fun cast(): i32 int = String(stoi(int))

    fun cast(): c32 c = String(1, [c,0])


fun print: Str... strs
    for Str s in strs
        for c32 c in s
            putchar(c)


var msg = Str "Hello World!"

msg:repl("Hello", "Goodbye")
assert(msg == "Goodbye World!")

~op module
import "op"

ext Str
    ~Set 'not' operator to an isEmpty method
    fun op("not"): self* =
        self.len == 0

    fun pop: self* => Str  where self.length > 0
        return self[0 .. this.length-1]


~c_ffi module
import "c_ffi"

~Create a C file object, defined in c_ffi, holding cstdio and cstdlib to import.
import C("cstdio", "cstdlib")

putchar(65)
putchar(110)
~output: an
