`
        functional.an
    Showcase various functional aspects of ante
`

~Example of a polymorphic add function.  Uses the type variable t.
~Type variables can be any type, and are denoted with '
fun add: 't a b => 't
    return a + b


~The list data structure to iterate through
data List : Iter
    't val
    List<t>*|None nextNode


impl List
    ~Implement the next function from Iter
    fun next: List<t> l => 't|None
        return l.nextNode?.val

    ~Also required by Iter
    fun unwrap: self* => 't
        return self.val


impl Iter
    ~Example of a possible foldl implementation
    fun foldl: self*, 't('t,'t) f, 't init => 't
        return match @self
            None -> init
            _ -> foldl(l.next(), f, f(init, l.unwrap()))

    ~foldl1 using foldl above
    fun foldl1: self*, 't('t,'t) f => 't
        return foldl(self.next(), f, self.unwrap())

    fun map: self*, 'r('t) f => Iter*
        for elem in self
            f(elem)
        return self

~Since this is a polymorphic function, the list member's type does
~not have to be specified, and if one really wanted to, List could be 
~omitted as well and would be assumed to be a type implementing Iter.  
~If List<var> was specified then var could be used as a type variable 
~within the function
fun sum_of_list: List l => 't
    return l.reduce(add)


let l = List(1, &(2, &(3, &(4, None))))

assert(sum_of_list(l) == 10)


~Alternate, more imperative approach to sum_of_list
~NOTE: this still requires next() to be implemented.
fun sum_of_list: List<'t> l => 't
    var acc = l.val

    for x in l.next()
        acc += x
    return acc
