`
        functional.an
    Showcase various functional aspects of ante
`

~Example of a polymorphic add function.  Since types in ante
~must start with a capital letter, gen and t are type variables.
gen add: t a b
    return a + b


~The list data structure to iterate through
data List<type T> : Iter
    T val
    List<T>* | None nextNode


    ~Implement the next function from Iter
    T|None next: List<T> l
        return l.nextNode?.val

    ~Also required by Iter
    T unwrap:
        return t.val


impl Iter
    ~Example of a possible foldl implementation
    t foldl: self*, t(t,t) f, t init
        return match *self
            None -> init
            _ -> foldl(l.next(), f, f(init, l.unwrap()))

    ~foldl1 using foldl above
    t foldl1: self*, t(t,t) f
        return foldl(self.next(), f, self.unwrap())

    Iter* map: self*, r(t) f
        for t elem in *self
            f(elem)
        return self

~Since this is a polymorphic function, the list member's type does
~not have to be specified, and if one really wanted to, List could be 
~omitted as well and would be assumed to be a type implementing Iter.  
~If List<var> was specified then var could be used as a type variable 
~within the function
gen sum_of_list: List l
    return l.foldl1(add)


List l = 1, &(2, &(3, &(4, None))

assert(sum_of_list(l) == 10)


~Alternate, more imperative approach to sum_of_list
~NOTE: this still requires next() to be implemented.
gen sum_of_list: List<ty> l
    ty acc = l.val

    for ty x in l.next()
        acc += x
    return acc
