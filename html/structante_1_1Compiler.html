<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Ante: ante::Compiler Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Ante
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>ante</b></li><li class="navelem"><a class="el" href="structante_1_1Compiler.html">Compiler</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structante_1_1Compiler-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ante::Compiler Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>An Ante compiler responsible for a single module.  
 <a href="structante_1_1Compiler.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="compiler_8h_source.html">compiler.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afdb96f422caf19f04ca073fe495c1a72"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#afdb96f422caf19f04ca073fe495c1a72">Compiler</a> (const char *fileName, bool lib=false, std::shared_ptr&lt; llvm::LLVMContext &gt; ctxt=nullptr)</td></tr>
<tr class="memdesc:afdb96f422caf19f04ca073fe495c1a72"><td class="mdescLeft">&#160;</td><td class="mdescRight">The main constructor for <a class="el" href="structante_1_1Compiler.html" title="An Ante compiler responsible for a single module. ">Compiler</a>.  <a href="#afdb96f422caf19f04ca073fe495c1a72">More...</a><br /></td></tr>
<tr class="separator:afdb96f422caf19f04ca073fe495c1a72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44d69e04f3427d8935f8cad20bcbb495"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#a44d69e04f3427d8935f8cad20bcbb495">Compiler</a> (<a class="el" href="structante_1_1Compiler.html">Compiler</a> *c, <a class="el" href="structante_1_1Node.html">Node</a> *root, std::string modName, bool lib=false)</td></tr>
<tr class="memdesc:a44d69e04f3427d8935f8cad20bcbb495"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for a <a class="el" href="structante_1_1Compiler.html" title="An Ante compiler responsible for a single module. ">Compiler</a> compiling a sub-module within the current file. Currently only used for string interpolation.  <a href="#a44d69e04f3427d8935f8cad20bcbb495">More...</a><br /></td></tr>
<tr class="separator:a44d69e04f3427d8935f8cad20bcbb495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad90a555d154fdd436ef0a9ae4e68185f"><td class="memItemLeft" align="right" valign="top"><a id="ad90a555d154fdd436ef0a9ae4e68185f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#ad90a555d154fdd436ef0a9ae4e68185f">compile</a> ()</td></tr>
<tr class="memdesc:ad90a555d154fdd436ef0a9ae4e68185f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully compiles a module into llvm bytecode. <br /></td></tr>
<tr class="separator:ad90a555d154fdd436ef0a9ae4e68185f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14d932ffda1eb271c27205be1a8d7cfb"><td class="memItemLeft" align="right" valign="top"><a id="a14d932ffda1eb271c27205be1a8d7cfb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#a14d932ffda1eb271c27205be1a8d7cfb">compileNative</a> ()</td></tr>
<tr class="memdesc:a14d932ffda1eb271c27205be1a8d7cfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compiles a native binary. <br /></td></tr>
<tr class="separator:a14d932ffda1eb271c27205be1a8d7cfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4729b39972523c4996debf67113376c6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#a4729b39972523c4996debf67113376c6">compileObj</a> (std::string &amp;outName)</td></tr>
<tr class="memdesc:a4729b39972523c4996debf67113376c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compiles a module to an object file.  <a href="#a4729b39972523c4996debf67113376c6">More...</a><br /></td></tr>
<tr class="separator:a4729b39972523c4996debf67113376c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a5e861e43aa9644bde7521e854434d0"><td class="memItemLeft" align="right" valign="top"><a id="a6a5e861e43aa9644bde7521e854434d0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#a6a5e861e43aa9644bde7521e854434d0">compilePrelude</a> ()</td></tr>
<tr class="memdesc:a6a5e861e43aa9644bde7521e854434d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Imports the prelude module unless the current module is the prelude. <br /></td></tr>
<tr class="separator:a6a5e861e43aa9644bde7521e854434d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9586ff05c0f9b53e950e27cf0427d357"><td class="memItemLeft" align="right" valign="top">llvm::Function *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#a9586ff05c0f9b53e950e27cf0427d357">createMainFn</a> ()</td></tr>
<tr class="memdesc:a9586ff05c0f9b53e950e27cf0427d357"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the main function of a main module or creates the library_init function of a lib module.  <a href="#a9586ff05c0f9b53e950e27cf0427d357">More...</a><br /></td></tr>
<tr class="separator:a9586ff05c0f9b53e950e27cf0427d357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8601989e980b18b0020ae3bb0e019ebf"><td class="memItemLeft" align="right" valign="top"><a id="a8601989e980b18b0020ae3bb0e019ebf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#a8601989e980b18b0020ae3bb0e019ebf">eval</a> ()</td></tr>
<tr class="memdesc:a8601989e980b18b0020ae3bb0e019ebf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts the REPL. <br /></td></tr>
<tr class="separator:a8601989e980b18b0020ae3bb0e019ebf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90c0d7b91fd51ef50bd6785a391c5fbb"><td class="memItemLeft" align="right" valign="top"><a id="a90c0d7b91fd51ef50bd6785a391c5fbb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#a90c0d7b91fd51ef50bd6785a391c5fbb">emitIR</a> ()</td></tr>
<tr class="memdesc:a90c0d7b91fd51ef50bd6785a391c5fbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumps current contents of module to stdout. <br /></td></tr>
<tr class="separator:a90c0d7b91fd51ef50bd6785a391c5fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dad7943c8df0d795353bad94fc085b3"><td class="memItemLeft" align="right" valign="top"><a id="a2dad7943c8df0d795353bad94fc085b3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#a2dad7943c8df0d795353bad94fc085b3">enterNewScope</a> ()</td></tr>
<tr class="memdesc:a2dad7943c8df0d795353bad94fc085b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and enters a new scope. <br /></td></tr>
<tr class="separator:a2dad7943c8df0d795353bad94fc085b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7207955f5a2786b656c80be7283c467"><td class="memItemLeft" align="right" valign="top"><a id="ad7207955f5a2786b656c80be7283c467"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#ad7207955f5a2786b656c80be7283c467">exitScope</a> ()</td></tr>
<tr class="memdesc:ad7207955f5a2786b656c80be7283c467"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exits a scope and performs any necessary cleanup. <br /></td></tr>
<tr class="separator:ad7207955f5a2786b656c80be7283c467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aa71837815ac3175a483f69d5cfc78b"><td class="memItemLeft" align="right" valign="top"><a id="a1aa71837815ac3175a483f69d5cfc78b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#a1aa71837815ac3175a483f69d5cfc78b">scanAllDecls</a> (<a class="el" href="structante_1_1RootNode.html">RootNode</a> *n=0)</td></tr>
<tr class="memdesc:a1aa71837815ac3175a483f69d5cfc78b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sweeps through parse tree registering all functions, type declarations, and traits. <br /></td></tr>
<tr class="separator:a1aa71837815ac3175a483f69d5cfc78b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf5d0d47a6f50d33ab75853c51defb2a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#adf5d0d47a6f50d33ab75853c51defb2a">processArgs</a> (<a class="el" href="structante_1_1CompilerArgs.html">CompilerArgs</a> *args)</td></tr>
<tr class="memdesc:adf5d0d47a6f50d33ab75853c51defb2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets appropriate flags and executes operations specified by the command line arguments.  <a href="#adf5d0d47a6f50d33ab75853c51defb2a">More...</a><br /></td></tr>
<tr class="separator:adf5d0d47a6f50d33ab75853c51defb2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2016159de829e78933dc0ca3d7b709df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structante_1_1TypedValue.html">TypedValue</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#a2016159de829e78933dc0ca3d7b709df">compAdd</a> (<a class="el" href="structante_1_1TypedValue.html">TypedValue</a> *l, <a class="el" href="structante_1_1TypedValue.html">TypedValue</a> *r, <a class="el" href="structante_1_1BinOpNode.html">BinOpNode</a> *op)</td></tr>
<tr class="memdesc:a2016159de829e78933dc0ca3d7b709df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emits an add instruction.  <a href="#a2016159de829e78933dc0ca3d7b709df">More...</a><br /></td></tr>
<tr class="separator:a2016159de829e78933dc0ca3d7b709df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f3145d3218e42921a3a3073ed6974a2"><td class="memItemLeft" align="right" valign="top"><a id="a0f3145d3218e42921a3a3073ed6974a2"></a>
<a class="el" href="structante_1_1TypedValue.html">TypedValue</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>compSub</b> (<a class="el" href="structante_1_1TypedValue.html">TypedValue</a> *l, <a class="el" href="structante_1_1TypedValue.html">TypedValue</a> *r, <a class="el" href="structante_1_1BinOpNode.html">BinOpNode</a> *op)</td></tr>
<tr class="separator:a0f3145d3218e42921a3a3073ed6974a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f65037835cfb7be27dae83857fa8e2b"><td class="memItemLeft" align="right" valign="top"><a id="a3f65037835cfb7be27dae83857fa8e2b"></a>
<a class="el" href="structante_1_1TypedValue.html">TypedValue</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>compMul</b> (<a class="el" href="structante_1_1TypedValue.html">TypedValue</a> *l, <a class="el" href="structante_1_1TypedValue.html">TypedValue</a> *r, <a class="el" href="structante_1_1BinOpNode.html">BinOpNode</a> *op)</td></tr>
<tr class="separator:a3f65037835cfb7be27dae83857fa8e2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a137b241c2999a7302f9d79e8d540c106"><td class="memItemLeft" align="right" valign="top"><a id="a137b241c2999a7302f9d79e8d540c106"></a>
<a class="el" href="structante_1_1TypedValue.html">TypedValue</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>compDiv</b> (<a class="el" href="structante_1_1TypedValue.html">TypedValue</a> *l, <a class="el" href="structante_1_1TypedValue.html">TypedValue</a> *r, <a class="el" href="structante_1_1BinOpNode.html">BinOpNode</a> *op)</td></tr>
<tr class="separator:a137b241c2999a7302f9d79e8d540c106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf8ac67ced0c260c87bc3a344dad5c33"><td class="memItemLeft" align="right" valign="top"><a id="acf8ac67ced0c260c87bc3a344dad5c33"></a>
<a class="el" href="structante_1_1TypedValue.html">TypedValue</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>compRem</b> (<a class="el" href="structante_1_1TypedValue.html">TypedValue</a> *l, <a class="el" href="structante_1_1TypedValue.html">TypedValue</a> *r, <a class="el" href="structante_1_1BinOpNode.html">BinOpNode</a> *op)</td></tr>
<tr class="separator:acf8ac67ced0c260c87bc3a344dad5c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7b248b8d12d206d64030bcee9814f18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structante_1_1TypedValue.html">TypedValue</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#ae7b248b8d12d206d64030bcee9814f18">compExtract</a> (<a class="el" href="structante_1_1TypedValue.html">TypedValue</a> *l, <a class="el" href="structante_1_1TypedValue.html">TypedValue</a> *r, <a class="el" href="structante_1_1BinOpNode.html">BinOpNode</a> *op)</td></tr>
<tr class="memdesc:ae7b248b8d12d206d64030bcee9814f18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compiles an extract operation such as array::index.  <a href="#ae7b248b8d12d206d64030bcee9814f18">More...</a><br /></td></tr>
<tr class="separator:ae7b248b8d12d206d64030bcee9814f18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca4d2e5d46466cd4bc4b4430c4424c1f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structante_1_1TypedValue.html">TypedValue</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#aca4d2e5d46466cd4bc4b4430c4424c1f">compInsert</a> (<a class="el" href="structante_1_1BinOpNode.html">BinOpNode</a> *insertOp, <a class="el" href="structante_1_1Node.html">Node</a> *assignExpr)</td></tr>
<tr class="memdesc:aca4d2e5d46466cd4bc4b4430c4424c1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compiles an insert operation such as array::index = 2.  <a href="#aca4d2e5d46466cd4bc4b4430c4424c1f">More...</a><br /></td></tr>
<tr class="separator:aca4d2e5d46466cd4bc4b4430c4424c1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae10106729b487ca3e88012553d4dd6f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structante_1_1TypedValue.html">TypedValue</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#ae10106729b487ca3e88012553d4dd6f8">compMemberAccess</a> (<a class="el" href="structante_1_1Node.html">Node</a> *ln, <a class="el" href="structante_1_1VarNode.html">VarNode</a> *field, <a class="el" href="structante_1_1BinOpNode.html">BinOpNode</a> *binop)</td></tr>
<tr class="memdesc:ae10106729b487ca3e88012553d4dd6f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compiles a named member access such as str.len.  <a href="#ae10106729b487ca3e88012553d4dd6f8">More...</a><br /></td></tr>
<tr class="separator:ae10106729b487ca3e88012553d4dd6f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2d2076cb79a85a0fe7e393e86994f4c"><td class="memItemLeft" align="right" valign="top"><a id="ac2d2076cb79a85a0fe7e393e86994f4c"></a>
<a class="el" href="structante_1_1TypedValue.html">TypedValue</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>compLogicalOr</b> (<a class="el" href="structante_1_1Node.html">Node</a> *l, <a class="el" href="structante_1_1Node.html">Node</a> *r, <a class="el" href="structante_1_1BinOpNode.html">BinOpNode</a> *op)</td></tr>
<tr class="separator:ac2d2076cb79a85a0fe7e393e86994f4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c264c7a2e583bb7cbf5b32ee4aa1ec3"><td class="memItemLeft" align="right" valign="top"><a id="a3c264c7a2e583bb7cbf5b32ee4aa1ec3"></a>
<a class="el" href="structante_1_1TypedValue.html">TypedValue</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>compLogicalAnd</b> (<a class="el" href="structante_1_1Node.html">Node</a> *l, <a class="el" href="structante_1_1Node.html">Node</a> *r, <a class="el" href="structante_1_1BinOpNode.html">BinOpNode</a> *op)</td></tr>
<tr class="separator:a3c264c7a2e583bb7cbf5b32ee4aa1ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16e0d9af94bb9084d47bcba09387417b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structante_1_1TypedValue.html">TypedValue</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#a16e0d9af94bb9084d47bcba09387417b">compErr</a> (<a class="el" href="structante_1_1lazy__printer.html">lazy_printer</a> msg, const yy::location &amp;loc, ErrorType t=ErrorType::Error)</td></tr>
<tr class="memdesc:a16e0d9af94bb9084d47bcba09387417b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports a message and highlights the relevant source lines.  <a href="#a16e0d9af94bb9084d47bcba09387417b">More...</a><br /></td></tr>
<tr class="separator:a16e0d9af94bb9084d47bcba09387417b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac0d539920d04deb2143881fc6f13530"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#aac0d539920d04deb2143881fc6f13530">jitFunction</a> (llvm::Function *fnName)</td></tr>
<tr class="memdesc:aac0d539920d04deb2143881fc6f13530"><td class="mdescLeft">&#160;</td><td class="mdescRight">JIT compiles a function with no arguments and calls it afterward.  <a href="#aac0d539920d04deb2143881fc6f13530">More...</a><br /></td></tr>
<tr class="separator:aac0d539920d04deb2143881fc6f13530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aced731a03097f99f56bf48e14039538c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#aced731a03097f99f56bf48e14039538c">importFile</a> (const char *name, <a class="el" href="structante_1_1Node.html">Node</a> *locNode=0)</td></tr>
<tr class="memdesc:aced731a03097f99f56bf48e14039538c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Imports a given ante file to the current module inputted file must exist and be a valid ante source file.  <a href="#aced731a03097f99f56bf48e14039538c">More...</a><br /></td></tr>
<tr class="separator:aced731a03097f99f56bf48e14039538c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a350f94044482ce04fdbb1571c6ee6c84"><td class="memItemLeft" align="right" valign="top"><a id="a350f94044482ce04fdbb1571c6ee6c84"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#a350f94044482ce04fdbb1571c6ee6c84">updateFn</a> (<a class="el" href="structante_1_1TypedValue.html">TypedValue</a> *f, <a class="el" href="structante_1_1FuncDecl.html">FuncDecl</a> *fd, std::string &amp;name, std::string &amp;mangledName)</td></tr>
<tr class="memdesc:a350f94044482ce04fdbb1571c6ee6c84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the tv of the <a class="el" href="structante_1_1FuncDecl.html" title="Contains information about a function that is not contained within its FuncDeclNode. ">FuncDecl</a> specified to the value of f. <br /></td></tr>
<tr class="separator:a350f94044482ce04fdbb1571c6ee6c84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae81e93dc33f382e5e3b6f89bbda80a05"><td class="memItemLeft" align="right" valign="top"><a id="ae81e93dc33f382e5e3b6f89bbda80a05"></a>
<a class="el" href="structante_1_1FuncDecl.html">FuncDecl</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getCurrentFunction</b> () const</td></tr>
<tr class="separator:ae81e93dc33f382e5e3b6f89bbda80a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a142271c79982d257fd1bb0599164ee1a"><td class="memItemLeft" align="right" valign="top"><a id="a142271c79982d257fd1bb0599164ee1a"></a>
<a class="el" href="structante_1_1TypedValue.html">TypedValue</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#a142271c79982d257fd1bb0599164ee1a">getFunction</a> (std::string &amp;name, std::string &amp;mangledName)</td></tr>
<tr class="memdesc:a142271c79982d257fd1bb0599164ee1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the exact function specified if found or nullptr if not. <br /></td></tr>
<tr class="separator:a142271c79982d257fd1bb0599164ee1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6322062f57deeec58ea4a2c3c436b27c"><td class="memItemLeft" align="right" valign="top"><a id="a6322062f57deeec58ea4a2c3c436b27c"></a>
std::vector&lt; std::shared_ptr&lt; <a class="el" href="structante_1_1FuncDecl.html">FuncDecl</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#a6322062f57deeec58ea4a2c3c436b27c">getFunctionList</a> (std::string &amp;name) const</td></tr>
<tr class="memdesc:a6322062f57deeec58ea4a2c3c436b27c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of all functions with the specified baseName. <br /></td></tr>
<tr class="separator:a6322062f57deeec58ea4a2c3c436b27c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20b44eb99cf51b96158a1363b4f6710c"><td class="memItemLeft" align="right" valign="top"><a id="a20b44eb99cf51b96158a1363b4f6710c"></a>
<a class="el" href="structante_1_1FuncDecl.html">FuncDecl</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#a20b44eb99cf51b96158a1363b4f6710c">getFuncDecl</a> (std::string bn, std::string mangledName)</td></tr>
<tr class="memdesc:a20b44eb99cf51b96158a1363b4f6710c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the exact <a class="el" href="structante_1_1FuncDecl.html" title="Contains information about a function that is not contained within its FuncDeclNode. ">FuncDecl</a> specified if found or nullptr if not. <br /></td></tr>
<tr class="separator:a20b44eb99cf51b96158a1363b4f6710c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7de67a20fcebe150b771916dfde4008f"><td class="memItemLeft" align="right" valign="top"><a id="a7de67a20fcebe150b771916dfde4008f"></a>
<a class="el" href="structante_1_1TypedValue.html">TypedValue</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#a7de67a20fcebe150b771916dfde4008f">callFn</a> (std::string fnBaseName, std::vector&lt; <a class="el" href="structante_1_1TypedValue.html">TypedValue</a> *&gt; args)</td></tr>
<tr class="memdesc:a7de67a20fcebe150b771916dfde4008f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emits and returns a function call. <br /></td></tr>
<tr class="separator:a7de67a20fcebe150b771916dfde4008f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afde8ba149df81ceb75d2679b76999f40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structante_1_1TypedValue.html">TypedValue</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#afde8ba149df81ceb75d2679b76999f40">getMangledFn</a> (std::string name, std::vector&lt; <a class="el" href="structante_1_1TypeNode.html">TypeNode</a> *&gt; args)</td></tr>
<tr class="memdesc:afde8ba149df81ceb75d2679b76999f40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the function specified.  <a href="#afde8ba149df81ceb75d2679b76999f40">More...</a><br /></td></tr>
<tr class="separator:afde8ba149df81ceb75d2679b76999f40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a221877c86c514b5dcff9453eae8dfbb2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structante_1_1TypedValue.html">TypedValue</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#a221877c86c514b5dcff9453eae8dfbb2">getCastFn</a> (<a class="el" href="structante_1_1TypeNode.html">TypeNode</a> *from_ty, <a class="el" href="structante_1_1TypeNode.html">TypeNode</a> *to_ty, <a class="el" href="structante_1_1FuncDecl.html">FuncDecl</a> *fd=0)</td></tr>
<tr class="memdesc:a221877c86c514b5dcff9453eae8dfbb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the init method of a type.  <a href="#a221877c86c514b5dcff9453eae8dfbb2">More...</a><br /></td></tr>
<tr class="separator:a221877c86c514b5dcff9453eae8dfbb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae912e9978fea0918efcacefacc5e51a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structante_1_1FuncDecl.html">FuncDecl</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#ae912e9978fea0918efcacefacc5e51a6">getMangledFuncDecl</a> (std::string name, std::vector&lt; <a class="el" href="structante_1_1TypeNode.html">TypeNode</a> *&gt; args)</td></tr>
<tr class="memdesc:ae912e9978fea0918efcacefacc5e51a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the <a class="el" href="structante_1_1FuncDecl.html" title="Contains information about a function that is not contained within its FuncDeclNode. ">FuncDecl</a> specified.  <a href="#ae912e9978fea0918efcacefacc5e51a6">More...</a><br /></td></tr>
<tr class="separator:ae912e9978fea0918efcacefacc5e51a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76b7e3f0bad3155050fcb2a6c404b4b7"><td class="memItemLeft" align="right" valign="top"><a id="a76b7e3f0bad3155050fcb2a6c404b4b7"></a>
<a class="el" href="structante_1_1FuncDecl.html">FuncDecl</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getCastFuncDecl</b> (<a class="el" href="structante_1_1TypeNode.html">TypeNode</a> *from_ty, <a class="el" href="structante_1_1TypeNode.html">TypeNode</a> *to_ty)</td></tr>
<tr class="separator:a76b7e3f0bad3155050fcb2a6c404b4b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae0845ded3c51ebb25607c9d99b206af"><td class="memItemLeft" align="right" valign="top"><a id="aae0845ded3c51ebb25607c9d99b206af"></a>
<a class="el" href="structante_1_1TypedValue.html">TypedValue</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#aae0845ded3c51ebb25607c9d99b206af">compLetBindingFn</a> (<a class="el" href="structante_1_1FuncDecl.html">FuncDecl</a> *fdn, std::vector&lt; llvm::Type *&gt; &amp;paramTys)</td></tr>
<tr class="memdesc:aae0845ded3c51ebb25607c9d99b206af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compiles a function with inferred return type. <br /></td></tr>
<tr class="separator:aae0845ded3c51ebb25607c9d99b206af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af12c139a90b4c2bc8e1836f342e27fe4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structante_1_1TypedValue.html">TypedValue</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#af12c139a90b4c2bc8e1836f342e27fe4">compFn</a> (<a class="el" href="structante_1_1FuncDecl.html">FuncDecl</a> *fn)</td></tr>
<tr class="memdesc:af12c139a90b4c2bc8e1836f342e27fe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compiles any non-generic function.  <a href="#af12c139a90b4c2bc8e1836f342e27fe4">More...</a><br /></td></tr>
<tr class="separator:af12c139a90b4c2bc8e1836f342e27fe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a307c04817f98cb7483a8d823e1993885"><td class="memItemLeft" align="right" valign="top"><a id="a307c04817f98cb7483a8d823e1993885"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>registerFunction</b> (<a class="el" href="structante_1_1FuncDeclNode.html">FuncDeclNode</a> *func)</td></tr>
<tr class="separator:a307c04817f98cb7483a8d823e1993885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9a29d3daf69b8ad5b52e6fb27383fe4"><td class="memItemLeft" align="right" valign="top"><a id="ad9a29d3daf69b8ad5b52e6fb27383fe4"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>getScope</b> () const</td></tr>
<tr class="separator:ad9a29d3daf69b8ad5b52e6fb27383fe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3c37473195d132a18f72af945032445"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structante_1_1Variable.html">Variable</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#ae3c37473195d132a18f72af945032445">lookup</a> (std::string var) const</td></tr>
<tr class="memdesc:ae3c37473195d132a18f72af945032445"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a lookup for a variable.  <a href="#ae3c37473195d132a18f72af945032445">More...</a><br /></td></tr>
<tr class="separator:ae3c37473195d132a18f72af945032445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1bc6b687a50f60ccdd258668c580694"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#ad1bc6b687a50f60ccdd258668c580694">stoVar</a> (std::string var, <a class="el" href="structante_1_1Variable.html">Variable</a> *val)</td></tr>
<tr class="memdesc:ad1bc6b687a50f60ccdd258668c580694"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a variable in the current scope.  <a href="#ad1bc6b687a50f60ccdd258668c580694">More...</a><br /></td></tr>
<tr class="separator:ad1bc6b687a50f60ccdd258668c580694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b84981e7a70934f9d350e0ecc3fd087"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structante_1_1DataType.html">DataType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#a8b84981e7a70934f9d350e0ecc3fd087">lookupType</a> (std::string tyname) const</td></tr>
<tr class="memdesc:a8b84981e7a70934f9d350e0ecc3fd087"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a lookup for the specified <a class="el" href="structante_1_1DataType.html" title="Contains information about a data type. ">DataType</a>.  <a href="#a8b84981e7a70934f9d350e0ecc3fd087">More...</a><br /></td></tr>
<tr class="separator:a8b84981e7a70934f9d350e0ecc3fd087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a989af02b7251eee25738ed0c44266fd4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structante_1_1DataType.html">DataType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#a989af02b7251eee25738ed0c44266fd4">lookupType</a> (const <a class="el" href="structante_1_1TypeNode.html">TypeNode</a> *tn) const</td></tr>
<tr class="memdesc:a989af02b7251eee25738ed0c44266fd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a lookup a type's full definition.  <a href="#a989af02b7251eee25738ed0c44266fd4">More...</a><br /></td></tr>
<tr class="separator:a989af02b7251eee25738ed0c44266fd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f026cfd23efe539bfbb0cc403676228"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structante_1_1Trait.html">Trait</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#a5f026cfd23efe539bfbb0cc403676228">lookupTrait</a> (std::string tyname) const</td></tr>
<tr class="memdesc:a5f026cfd23efe539bfbb0cc403676228"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a lookup for the specified trait.  <a href="#a5f026cfd23efe539bfbb0cc403676228">More...</a><br /></td></tr>
<tr class="separator:a5f026cfd23efe539bfbb0cc403676228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a452d693a23c3690bd955a0a04bc3e653"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#a452d693a23c3690bd955a0a04bc3e653">typeImplementsTrait</a> (<a class="el" href="structante_1_1DataType.html">DataType</a> *dt, std::string traitName) const</td></tr>
<tr class="separator:a452d693a23c3690bd955a0a04bc3e653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad5d03a0bef93374a1f9e54406c1f5ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#aad5d03a0bef93374a1f9e54406c1f5ab">stoType</a> (<a class="el" href="structante_1_1DataType.html">DataType</a> *ty, std::string &amp;typeName)</td></tr>
<tr class="memdesc:aad5d03a0bef93374a1f9e54406c1f5ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a new <a class="el" href="structante_1_1DataType.html" title="Contains information about a data type. ">DataType</a>.  <a href="#aad5d03a0bef93374a1f9e54406c1f5ab">More...</a><br /></td></tr>
<tr class="separator:aad5d03a0bef93374a1f9e54406c1f5ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0398f0c21b54f2a3bef8961ed042705"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#ae0398f0c21b54f2a3bef8961ed042705">stoTypeVar</a> (std::string &amp;name, <a class="el" href="structante_1_1TypeNode.html">TypeNode</a> *ty)</td></tr>
<tr class="memdesc:ae0398f0c21b54f2a3bef8961ed042705"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a TypeVar in the current scope.  <a href="#ae0398f0c21b54f2a3bef8961ed042705">More...</a><br /></td></tr>
<tr class="separator:ae0398f0c21b54f2a3bef8961ed042705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72d9ff3f1651d1de1f3c78901925da8e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#a72d9ff3f1651d1de1f3c78901925da8e">searchAndReplaceBoundTypeVars</a> (<a class="el" href="structante_1_1TypeNode.html">TypeNode</a> *tn) const</td></tr>
<tr class="memdesc:a72d9ff3f1651d1de1f3c78901925da8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches through tn and replaces any typevars inside with their definition from a lookup if found.  <a href="#a72d9ff3f1651d1de1f3c78901925da8e">More...</a><br /></td></tr>
<tr class="separator:a72d9ff3f1651d1de1f3c78901925da8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d47ee22f298eb44daa87c5a471f4e1e"><td class="memItemLeft" align="right" valign="top"><a id="a9d47ee22f298eb44daa87c5a471f4e1e"></a>
llvm::Type *&#160;</td><td class="memItemRight" valign="bottom"><b>typeNodeToLlvmType</b> (const <a class="el" href="structante_1_1TypeNode.html">TypeNode</a> *tyNode)</td></tr>
<tr class="separator:a9d47ee22f298eb44daa87c5a471f4e1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa365b83ce890cd8e8914343cc1317341"><td class="memItemLeft" align="right" valign="top"><a id="aa365b83ce890cd8e8914343cc1317341"></a>
<a class="el" href="structante_1_1TypeCheckResult.html">TypeCheckResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#aa365b83ce890cd8e8914343cc1317341">typeEq</a> (const <a class="el" href="structante_1_1TypeNode.html">TypeNode</a> *l, const <a class="el" href="structante_1_1TypeNode.html">TypeNode</a> *r) const</td></tr>
<tr class="memdesc:aa365b83ce890cd8e8914343cc1317341"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a type check against l and r. <br /></td></tr>
<tr class="separator:aa365b83ce890cd8e8914343cc1317341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42313239d22ef4cc13891726d62548c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structante_1_1TypeCheckResult.html">TypeCheckResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#a42313239d22ef4cc13891726d62548c9">typeEq</a> (std::vector&lt; <a class="el" href="structante_1_1TypeNode.html">TypeNode</a> *&gt; l, std::vector&lt; <a class="el" href="structante_1_1TypeNode.html">TypeNode</a> *&gt; r) const</td></tr>
<tr class="memdesc:a42313239d22ef4cc13891726d62548c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a type check against l and r.  <a href="#a42313239d22ef4cc13891726d62548c9">More...</a><br /></td></tr>
<tr class="separator:a42313239d22ef4cc13891726d62548c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab19dff31d4d5d0eb1d770d2ff8c8d0e9"><td class="memItemLeft" align="right" valign="top"><a id="ab19dff31d4d5d0eb1d770d2ff8c8d0e9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#ab19dff31d4d5d0eb1d770d2ff8c8d0e9">expand</a> (<a class="el" href="structante_1_1TypeNode.html">TypeNode</a> *tn)</td></tr>
<tr class="memdesc:ab19dff31d4d5d0eb1d770d2ff8c8d0e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expands any TT_Data -typed nodes inside of tn to contain their constituent types. Does not expand any nodes pointed to by a pointer type to avoid infinite recursion. <br /></td></tr>
<tr class="separator:ab19dff31d4d5d0eb1d770d2ff8c8d0e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a297c58e36b13159b56ea8ed0d1095b18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structante_1_1TypedValue.html">TypedValue</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#a297c58e36b13159b56ea8ed0d1095b18">implicitlyWidenNum</a> (<a class="el" href="structante_1_1TypedValue.html">TypedValue</a> *num, TypeTag castTy)</td></tr>
<tr class="memdesc:a297c58e36b13159b56ea8ed0d1095b18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an implicit widening.  <a href="#a297c58e36b13159b56ea8ed0d1095b18">More...</a><br /></td></tr>
<tr class="separator:a297c58e36b13159b56ea8ed0d1095b18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57010cd33f617f2a00f9d66f4535a5a2"><td class="memItemLeft" align="right" valign="top"><a id="a57010cd33f617f2a00f9d66f4535a5a2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#a57010cd33f617f2a00f9d66f4535a5a2">handleImplicitConversion</a> (<a class="el" href="structante_1_1TypedValue.html">TypedValue</a> **lhs, <a class="el" href="structante_1_1TypedValue.html">TypedValue</a> **rhs)</td></tr>
<tr class="memdesc:a57010cd33f617f2a00f9d66f4535a5a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutates numerical arguments to match types if possible. <br /></td></tr>
<tr class="separator:a57010cd33f617f2a00f9d66f4535a5a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7491f56e44dd73e2acf54f90e82e38d7"><td class="memItemLeft" align="right" valign="top"><a id="a7491f56e44dd73e2acf54f90e82e38d7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#a7491f56e44dd73e2acf54f90e82e38d7">implicitlyCastIntToInt</a> (<a class="el" href="structante_1_1TypedValue.html">TypedValue</a> **lhs, <a class="el" href="structante_1_1TypedValue.html">TypedValue</a> **rhs)</td></tr>
<tr class="memdesc:a7491f56e44dd73e2acf54f90e82e38d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutates integer arguments to match types if not already. <br /></td></tr>
<tr class="separator:a7491f56e44dd73e2acf54f90e82e38d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ef8efaba6bee7a102fd24ba198c815d"><td class="memItemLeft" align="right" valign="top"><a id="a2ef8efaba6bee7a102fd24ba198c815d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#a2ef8efaba6bee7a102fd24ba198c815d">implicitlyCastFltToFlt</a> (<a class="el" href="structante_1_1TypedValue.html">TypedValue</a> **lhs, <a class="el" href="structante_1_1TypedValue.html">TypedValue</a> **rhs)</td></tr>
<tr class="memdesc:a2ef8efaba6bee7a102fd24ba198c815d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutates floating-point arguments to match types if not already. <br /></td></tr>
<tr class="separator:a2ef8efaba6bee7a102fd24ba198c815d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ba94223a0d2c695defadc292a315169"><td class="memItemLeft" align="right" valign="top"><a id="a1ba94223a0d2c695defadc292a315169"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#a1ba94223a0d2c695defadc292a315169">implicitlyCastIntToFlt</a> (<a class="el" href="structante_1_1TypedValue.html">TypedValue</a> **tval, llvm::Type *ty)</td></tr>
<tr class="memdesc:a1ba94223a0d2c695defadc292a315169"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutates an integer to a float. <br /></td></tr>
<tr class="separator:a1ba94223a0d2c695defadc292a315169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f67cede4b0f6d590b40f450a98ffdbf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#a4f67cede4b0f6d590b40f450a98ffdbf">compileIRtoObj</a> (llvm::Module *mod, std::string outFile)</td></tr>
<tr class="memdesc:a4f67cede4b0f6d590b40f450a98ffdbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compiles a module into an obj file to be used for linking.  <a href="#a4f67cede4b0f6d590b40f450a98ffdbf">More...</a><br /></td></tr>
<tr class="separator:a4f67cede4b0f6d590b40f450a98ffdbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52cbb938fefe7ff479229302db5cefa4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structante_1_1TypedValue.html">TypedValue</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#a52cbb938fefe7ff479229302db5cefa4">getVoidLiteral</a> ()</td></tr>
<tr class="memdesc:a52cbb938fefe7ff479229302db5cefa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns a literal of type void.  <a href="#a52cbb938fefe7ff479229302db5cefa4">More...</a><br /></td></tr>
<tr class="separator:a52cbb938fefe7ff479229302db5cefa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a47cc1eee42440cc034f2a3e71f408cc7"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#a47cc1eee42440cc034f2a3e71f408cc7">linkObj</a> (std::string inFiles, std::string outFile)</td></tr>
<tr class="memdesc:a47cc1eee42440cc034f2a3e71f408cc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes the linker specified by AN_LINKER (in <a class="el" href="target_8h_source.html">target.h</a>) to link each object file.  <a href="#a47cc1eee42440cc034f2a3e71f408cc7">More...</a><br /></td></tr>
<tr class="separator:a47cc1eee42440cc034f2a3e71f408cc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a71e7a8c82f30d779f8fc0a52eb184374"><td class="memItemLeft" align="right" valign="top"><a id="a71e7a8c82f30d779f8fc0a52eb184374"></a>
std::shared_ptr&lt; llvm::LLVMContext &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ctxt</b></td></tr>
<tr class="separator:a71e7a8c82f30d779f8fc0a52eb184374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9f6fad60cf5c8423a0f68e6cb3d7edd"><td class="memItemLeft" align="right" valign="top"><a id="ad9f6fad60cf5c8423a0f68e6cb3d7edd"></a>
std::unique_ptr&lt; llvm::ExecutionEngine &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>jit</b></td></tr>
<tr class="separator:ad9f6fad60cf5c8423a0f68e6cb3d7edd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d5fcbe7dae0bb7dbb939c726aab7c75"><td class="memItemLeft" align="right" valign="top"><a id="a5d5fcbe7dae0bb7dbb939c726aab7c75"></a>
std::unique_ptr&lt; llvm::legacy::FunctionPassManager &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>passManager</b></td></tr>
<tr class="separator:a5d5fcbe7dae0bb7dbb939c726aab7c75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2cc9ee3730e87a2ee449bf7e3156f91"><td class="memItemLeft" align="right" valign="top"><a id="ae2cc9ee3730e87a2ee449bf7e3156f91"></a>
std::unique_ptr&lt; llvm::Module &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>module</b></td></tr>
<tr class="separator:ae2cc9ee3730e87a2ee449bf7e3156f91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1b2a6467064c2a63b4d275a2bc174c4"><td class="memItemLeft" align="right" valign="top"><a id="af1b2a6467064c2a63b4d275a2bc174c4"></a>
std::unique_ptr&lt; <a class="el" href="structante_1_1RootNode.html">RootNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ast</b></td></tr>
<tr class="separator:af1b2a6467064c2a63b4d275a2bc174c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0292d2d26ec0a97c80dc0ef0774288b8"><td class="memItemLeft" align="right" valign="top"><a id="a0292d2d26ec0a97c80dc0ef0774288b8"></a>
llvm::IRBuilder&#160;</td><td class="memItemRight" valign="bottom"><b>builder</b></td></tr>
<tr class="separator:a0292d2d26ec0a97c80dc0ef0774288b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97e60cfc09ceb5ced8691f3d1de2e067"><td class="memItemLeft" align="right" valign="top"><a id="a97e60cfc09ceb5ced8691f3d1de2e067"></a>
std::shared_ptr&lt; <a class="el" href="structante_1_1Module.html">Module</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#a97e60cfc09ceb5ced8691f3d1de2e067">compUnit</a></td></tr>
<tr class="memdesc:a97e60cfc09ceb5ced8691f3d1de2e067"><td class="mdescLeft">&#160;</td><td class="mdescRight">functions and type definitions of current module <br /></td></tr>
<tr class="separator:a97e60cfc09ceb5ced8691f3d1de2e067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab39b3edca5bdc075fdae3917d2153467"><td class="memItemLeft" align="right" valign="top"><a id="ab39b3edca5bdc075fdae3917d2153467"></a>
std::shared_ptr&lt; <a class="el" href="structante_1_1Module.html">Module</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#ab39b3edca5bdc075fdae3917d2153467">mergedCompUnits</a></td></tr>
<tr class="memdesc:ab39b3edca5bdc075fdae3917d2153467"><td class="mdescLeft">&#160;</td><td class="mdescRight">all functions and type definitions visible to current module <br /></td></tr>
<tr class="separator:ab39b3edca5bdc075fdae3917d2153467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a529fd144a4c3d7003419f84a4560da0a"><td class="memItemLeft" align="right" valign="top"><a id="a529fd144a4c3d7003419f84a4560da0a"></a>
std::vector&lt; std::shared_ptr&lt; <a class="el" href="structante_1_1Module.html">Module</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#a529fd144a4c3d7003419f84a4560da0a">imports</a></td></tr>
<tr class="memdesc:a529fd144a4c3d7003419f84a4560da0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">all imported modules <br /></td></tr>
<tr class="separator:a529fd144a4c3d7003419f84a4560da0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03f9e25692e3ec7023667c90a02259d3"><td class="memItemLeft" align="right" valign="top"><a id="a03f9e25692e3ec7023667c90a02259d3"></a>
std::shared_ptr&lt; std::unordered_map&lt; std::string, std::shared_ptr&lt; <a class="el" href="structante_1_1Module.html">Module</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#a03f9e25692e3ec7023667c90a02259d3">allCompiledModules</a></td></tr>
<tr class="memdesc:a03f9e25692e3ec7023667c90a02259d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">every single compiled module, even ones invisible to the current compilation unit. Prevents recompilation of modules <br /></td></tr>
<tr class="separator:a03f9e25692e3ec7023667c90a02259d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ec96ad867ebf52d5d701668d175ca3e"><td class="memItemLeft" align="right" valign="top"><a id="a8ec96ad867ebf52d5d701668d175ca3e"></a>
std::vector&lt; std::unique_ptr&lt; std::unordered_map&lt; std::string, <a class="el" href="structante_1_1Variable.html">Variable</a> * &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#a8ec96ad867ebf52d5d701668d175ca3e">varTable</a></td></tr>
<tr class="memdesc:a8ec96ad867ebf52d5d701668d175ca3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stack of variables mapped to their identifier. Maps are seperated according to their scope. <br /></td></tr>
<tr class="separator:a8ec96ad867ebf52d5d701668d175ca3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a1570831b0d49e292e4bd534e646117"><td class="memItemLeft" align="right" valign="top"><a id="a8a1570831b0d49e292e4bd534e646117"></a>
std::unique_ptr&lt; <a class="el" href="structante_1_1CompilerCtxt.html">CompilerCtxt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>compCtxt</b></td></tr>
<tr class="separator:a8a1570831b0d49e292e4bd534e646117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae80e715ca0f1d89a277a317488241b54"><td class="memItemLeft" align="right" valign="top"><a id="ae80e715ca0f1d89a277a317488241b54"></a>
std::shared_ptr&lt; <a class="el" href="structante_1_1CompilerCtCtxt.html">CompilerCtCtxt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ctCtxt</b></td></tr>
<tr class="separator:ae80e715ca0f1d89a277a317488241b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b937b0373fd399673d1e949bae33987"><td class="memItemLeft" align="right" valign="top"><a id="a2b937b0373fd399673d1e949bae33987"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>errFlag</b></td></tr>
<tr class="separator:a2b937b0373fd399673d1e949bae33987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3af520cc4406c344cb13085b9064667"><td class="memItemLeft" align="right" valign="top"><a id="ab3af520cc4406c344cb13085b9064667"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>compiled</b></td></tr>
<tr class="separator:ab3af520cc4406c344cb13085b9064667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eada2ae7db8a214762cec4efcdd51e6"><td class="memItemLeft" align="right" valign="top"><a id="a2eada2ae7db8a214762cec4efcdd51e6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isLib</b></td></tr>
<tr class="separator:a2eada2ae7db8a214762cec4efcdd51e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b0064c4c6844b9a8d4281a35698ac3c"><td class="memItemLeft" align="right" valign="top"><a id="a5b0064c4c6844b9a8d4281a35698ac3c"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>fileName</b></td></tr>
<tr class="separator:a5b0064c4c6844b9a8d4281a35698ac3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b687cb6b32bdc04b0d212dca5a70eb5"><td class="memItemLeft" align="right" valign="top"><a id="a7b687cb6b32bdc04b0d212dca5a70eb5"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>outFile</b></td></tr>
<tr class="separator:a7b687cb6b32bdc04b0d212dca5a70eb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaff49a9b3edec3f8d4c569bdc6953527"><td class="memItemLeft" align="right" valign="top"><a id="aaff49a9b3edec3f8d4c569bdc6953527"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>funcPrefix</b></td></tr>
<tr class="separator:aaff49a9b3edec3f8d4c569bdc6953527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a985cda2993bbf58b0120a87905759bd3"><td class="memItemLeft" align="right" valign="top"><a id="a985cda2993bbf58b0120a87905759bd3"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>scope</b></td></tr>
<tr class="separator:a985cda2993bbf58b0120a87905759bd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a0f791776d450019cc3272fdfbfbe19"><td class="memItemLeft" align="right" valign="top"><a id="a9a0f791776d450019cc3272fdfbfbe19"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>optLvl</b></td></tr>
<tr class="separator:a9a0f791776d450019cc3272fdfbfbe19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4772b7ae7d73420190a7647ee53f812e"><td class="memItemLeft" align="right" valign="top"><a id="a4772b7ae7d73420190a7647ee53f812e"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>fnScope</b></td></tr>
<tr class="separator:a4772b7ae7d73420190a7647ee53f812e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An Ante compiler responsible for a single module. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="afdb96f422caf19f04ca073fe495c1a72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdb96f422caf19f04ca073fe495c1a72">&#9670;&nbsp;</a></span>Compiler() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ante::Compiler::Compiler </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lib</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; llvm::LLVMContext &gt;&#160;</td>
          <td class="paramname"><em>ctxt</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The main constructor for <a class="el" href="structante_1_1Compiler.html" title="An Ante compiler responsible for a single module. ">Compiler</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileName</td><td>Name of the file being compiled </td></tr>
    <tr><td class="paramname">lib</td><td>Set to true if this module should be compiled as a library </td></tr>
    <tr><td class="paramname">ctxt</td><td>The LLVMContext possibly shared with another <a class="el" href="structante_1_1Compiler.html" title="An Ante compiler responsible for a single module. ">Compiler</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a44d69e04f3427d8935f8cad20bcbb495"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44d69e04f3427d8935f8cad20bcbb495">&#9670;&nbsp;</a></span>Compiler() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ante::Compiler::Compiler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structante_1_1Compiler.html">Compiler</a> *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structante_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>modName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lib</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor for a <a class="el" href="structante_1_1Compiler.html" title="An Ante compiler responsible for a single module. ">Compiler</a> compiling a sub-module within the current file. Currently only used for string interpolation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>The node to set as the root node (does not need to be a <a class="el" href="structante_1_1RootNode.html">RootNode</a> already) </td></tr>
    <tr><td class="paramname">modName</td><td>Name of the module being compiled </td></tr>
    <tr><td class="paramname">fName</td><td>Name of the file being compiled </td></tr>
    <tr><td class="paramname">lib</td><td>Set to true if this module should be compiled as a library </td></tr>
    <tr><td class="paramname">ctxt</td><td>The LLVMContext shared from the parent <a class="el" href="structante_1_1Compiler.html" title="An Ante compiler responsible for a single module. ">Compiler</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a2016159de829e78933dc0ca3d7b709df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2016159de829e78933dc0ca3d7b709df">&#9670;&nbsp;</a></span>compAdd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structante_1_1TypedValue.html">TypedValue</a> * ante::Compiler::compAdd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structante_1_1TypedValue.html">TypedValue</a> *&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structante_1_1TypedValue.html">TypedValue</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structante_1_1BinOpNode.html">BinOpNode</a> *&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emits an add instruction. </p>
<p>Operator overloads are not taken into account and should be handled beforehand. l and r must be the same type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The + <a class="el" href="structante_1_1Node.html">Node</a> used for error reporting</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting add instruction </dd></dl>

</div>
</div>
<a id="a16e0d9af94bb9084d47bcba09387417b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16e0d9af94bb9084d47bcba09387417b">&#9670;&nbsp;</a></span>compErr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structante_1_1TypedValue.html">TypedValue</a> * ante::Compiler::compErr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structante_1_1lazy__printer.html">lazy_printer</a>&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const yy::location &amp;&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ErrorType&#160;</td>
          <td class="paramname"><em>t</em> = <code>ErrorType::Error</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports a message and highlights the relevant source lines. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Type of message to report, either Error, Warning, or Note </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae7b248b8d12d206d64030bcee9814f18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7b248b8d12d206d64030bcee9814f18">&#9670;&nbsp;</a></span>compExtract()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structante_1_1TypedValue.html">TypedValue</a> * ante::Compiler::compExtract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structante_1_1TypedValue.html">TypedValue</a> *&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structante_1_1TypedValue.html">TypedValue</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structante_1_1BinOpNode.html">BinOpNode</a> *&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compiles an extract operation such as array::index. </p>
<p>Operator overloads are not taken into account and should be handled beforehand.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>The container to extract from </td></tr>
    <tr><td class="paramname">r</td><td>The index to extract </td></tr>
    <tr><td class="paramname">op</td><td>The # operator used for error reporting</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the extraction </dd></dl>

</div>
</div>
<a id="af12c139a90b4c2bc8e1836f342e27fe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af12c139a90b4c2bc8e1836f342e27fe4">&#9670;&nbsp;</a></span>compFn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structante_1_1TypedValue.html">TypedValue</a> * ante::Compiler::compFn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structante_1_1FuncDecl.html">FuncDecl</a> *&#160;</td>
          <td class="paramname"><em>fn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compiles any non-generic function. </p>
<p>Generic functions (indicated by a typecheck returning TypeCheckResult::SuccessWithTypeVars) should be compiled with compTemplateFn which calls this function internally. </p>

</div>
</div>
<a id="a4f67cede4b0f6d590b40f450a98ffdbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f67cede4b0f6d590b40f450a98ffdbf">&#9670;&nbsp;</a></span>compileIRtoObj()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ante::Compiler::compileIRtoObj </td>
          <td>(</td>
          <td class="paramtype">llvm::Module *&#160;</td>
          <td class="paramname"><em>mod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>outFile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compiles a module into an obj file to be used for linking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mod</td><td>The already-compiled module </td></tr>
    <tr><td class="paramname">outFile</td><td>Name of the file to output</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd></dl>

</div>
</div>
<a id="a4729b39972523c4996debf67113376c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4729b39972523c4996debf67113376c6">&#9670;&nbsp;</a></span>compileObj()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ante::Compiler::compileObj </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>outName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compiles a module to an object file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outName</td><td>name of the file to output</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd></dl>

</div>
</div>
<a id="aca4d2e5d46466cd4bc4b4430c4424c1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca4d2e5d46466cd4bc4b4430c4424c1f">&#9670;&nbsp;</a></span>compInsert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structante_1_1TypedValue.html">TypedValue</a> * ante::Compiler::compInsert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structante_1_1BinOpNode.html">BinOpNode</a> *&#160;</td>
          <td class="paramname"><em>insertOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structante_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>assignExpr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compiles an insert operation such as array::index = 2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">insertOp</td><td>The # operator containing the lhs of the assignment </td></tr>
    <tr><td class="paramname">assignExpr</td><td>The rhs of the assignment</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A void literal </dd></dl>

</div>
</div>
<a id="ae10106729b487ca3e88012553d4dd6f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae10106729b487ca3e88012553d4dd6f8">&#9670;&nbsp;</a></span>compMemberAccess()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structante_1_1TypedValue.html">TypedValue</a> * ante::Compiler::compMemberAccess </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structante_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>ln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structante_1_1VarNode.html">VarNode</a> *&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structante_1_1BinOpNode.html">BinOpNode</a> *&#160;</td>
          <td class="paramname"><em>binop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compiles a named member access such as str.len. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ln</td><td>The value or type/module being accessed </td></tr>
    <tr><td class="paramname">field</td><td>Name of the desired field/method </td></tr>
    <tr><td class="paramname">binop</td><td>Location of the . operator for error reporting</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The extracted field or method </dd></dl>

</div>
</div>
<a id="a9586ff05c0f9b53e950e27cf0427d357"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9586ff05c0f9b53e950e27cf0427d357">&#9670;&nbsp;</a></span>createMainFn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Function * ante::Compiler::createMainFn </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates the main function of a main module or creates the library_init function of a lib module. </p>
<dl class="section return"><dt>Returns</dt><dd>The llvm::Function* of the created function. </dd></dl>

</div>
</div>
<a id="a221877c86c514b5dcff9453eae8dfbb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a221877c86c514b5dcff9453eae8dfbb2">&#9670;&nbsp;</a></span>getCastFn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structante_1_1TypedValue.html">TypedValue</a> * ante::Compiler::getCastFn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structante_1_1TypeNode.html">TypeNode</a> *&#160;</td>
          <td class="paramname"><em>from_ty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structante_1_1TypeNode.html">TypeNode</a> *&#160;</td>
          <td class="paramname"><em>to_ty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structante_1_1FuncDecl.html">FuncDecl</a> *&#160;</td>
          <td class="paramname"><em>fd</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the init method of a type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from_ty</td><td>Tuple of argument types </td></tr>
    <tr><td class="paramname">to_ty</td><td>Type to cast to </td></tr>
    <tr><td class="paramname">fd</td><td>Optional <a class="el" href="structante_1_1FuncDecl.html" title="Contains information about a function that is not contained within its FuncDeclNode. ">FuncDecl</a> of cast function to use if already found</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The compiled cast function or nullptr if not found </dd></dl>

</div>
</div>
<a id="afde8ba149df81ceb75d2679b76999f40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afde8ba149df81ceb75d2679b76999f40">&#9670;&nbsp;</a></span>getMangledFn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structante_1_1TypedValue.html">TypedValue</a> * ante::Compiler::getMangledFn </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structante_1_1TypeNode.html">TypeNode</a> *&gt;&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the function specified. </p>
<p>Automatically binds generic functions and Performs argument deduction if necessary</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Basename of function to search for </td></tr>
    <tr><td class="paramname">args</td><td>Types of each argument in case multiple functions are found</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The specified function or nullptr </dd></dl>

</div>
</div>
<a id="ae912e9978fea0918efcacefacc5e51a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae912e9978fea0918efcacefacc5e51a6">&#9670;&nbsp;</a></span>getMangledFuncDecl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structante_1_1FuncDecl.html">FuncDecl</a> * ante::Compiler::getMangledFuncDecl </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structante_1_1TypeNode.html">TypeNode</a> *&gt;&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the <a class="el" href="structante_1_1FuncDecl.html" title="Contains information about a function that is not contained within its FuncDeclNode. ">FuncDecl</a> specified. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Basename of function to search for </td></tr>
    <tr><td class="paramname">args</td><td><a class="el" href="structante_1_1Argument.html">Argument</a> types if multiple functions are found</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="structante_1_1FuncDecl.html" title="Contains information about a function that is not contained within its FuncDeclNode. ">FuncDecl</a> if found or nullptr if not </dd></dl>

</div>
</div>
<a id="a52cbb938fefe7ff479229302db5cefa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52cbb938fefe7ff479229302db5cefa4">&#9670;&nbsp;</a></span>getVoidLiteral()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structante_1_1TypedValue.html">TypedValue</a> * ante::Compiler::getVoidLiteral </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates and returns a literal of type void. </p>
<dl class="section return"><dt>Returns</dt><dd>A void literal </dd></dl>

</div>
</div>
<a id="a297c58e36b13159b56ea8ed0d1095b18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a297c58e36b13159b56ea8ed0d1095b18">&#9670;&nbsp;</a></span>implicitlyWidenNum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structante_1_1TypedValue.html">TypedValue</a> * ante::Compiler::implicitlyWidenNum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structante_1_1TypedValue.html">TypedValue</a> *&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TypeTag&#160;</td>
          <td class="paramname"><em>castTy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs an implicit widening. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num</td><td>Integer to widen </td></tr>
    <tr><td class="paramname">castTy</td><td>Type to widen to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The widened integer </dd></dl>

</div>
</div>
<a id="aced731a03097f99f56bf48e14039538c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aced731a03097f99f56bf48e14039538c">&#9670;&nbsp;</a></span>importFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ante::Compiler::importFile </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structante_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>locNode</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Imports a given ante file to the current module inputted file must exist and be a valid ante source file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fName</td><td>Name of file to import </td></tr>
    <tr><td class="paramname">The</td><td>node containing where the file was imported from. Usually the <a class="el" href="structante_1_1ImportNode.html">ImportNode</a> importing the file. Used for error reporting. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aac0d539920d04deb2143881fc6f13530"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac0d539920d04deb2143881fc6f13530">&#9670;&nbsp;</a></span>jitFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ante::Compiler::jitFunction </td>
          <td>(</td>
          <td class="paramtype">llvm::Function *&#160;</td>
          <td class="paramname"><em>fnName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>JIT compiles a function with no arguments and calls it afterward. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>the function to JIT </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a47cc1eee42440cc034f2a3e71f408cc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47cc1eee42440cc034f2a3e71f408cc7">&#9670;&nbsp;</a></span>linkObj()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ante::Compiler::linkObj </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>inFiles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>outFile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invokes the linker specified by AN_LINKER (in <a class="el" href="target_8h_source.html">target.h</a>) to link each object file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inFiles</td><td>String containing each obj file to link separated with spaces </td></tr>
    <tr><td class="paramname">outFile</td><td>Name of the file to output</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd></dl>

</div>
</div>
<a id="ae3c37473195d132a18f72af945032445"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3c37473195d132a18f72af945032445">&#9670;&nbsp;</a></span>lookup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structante_1_1Variable.html">Variable</a> * ante::Compiler::lookup </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>var</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a lookup for a variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">var</td><td>Name of the variable to lookup</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Variable* if found, otherwise nullptr </dd></dl>

</div>
</div>
<a id="a5f026cfd23efe539bfbb0cc403676228"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f026cfd23efe539bfbb0cc403676228">&#9670;&nbsp;</a></span>lookupTrait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structante_1_1Trait.html">Trait</a> * ante::Compiler::lookupTrait </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tyname</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a lookup for the specified trait. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tyname</td><td>Name of the trait to lookup</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Trait* if found, otherwise nullptr </dd></dl>

</div>
</div>
<a id="a8b84981e7a70934f9d350e0ecc3fd087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b84981e7a70934f9d350e0ecc3fd087">&#9670;&nbsp;</a></span>lookupType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structante_1_1DataType.html">DataType</a>* ante::Compiler::lookupType </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tyname</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a lookup for the specified <a class="el" href="structante_1_1DataType.html" title="Contains information about a data type. ">DataType</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tyname</td><td>Name of the type to lookup</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The DataType* if found, otherwise nullptr </dd></dl>

</div>
</div>
<a id="a989af02b7251eee25738ed0c44266fd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a989af02b7251eee25738ed0c44266fd4">&#9670;&nbsp;</a></span>lookupType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structante_1_1DataType.html">DataType</a> * ante::Compiler::lookupType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structante_1_1TypeNode.html">TypeNode</a> *&#160;</td>
          <td class="paramname"><em>tn</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a lookup a type's full definition. </p>
<dl class="section return"><dt>Returns</dt><dd>The DataType* if found, otherwise nullptr </dd></dl>

</div>
</div>
<a id="adf5d0d47a6f50d33ab75853c51defb2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf5d0d47a6f50d33ab75853c51defb2a">&#9670;&nbsp;</a></span>processArgs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ante::Compiler::processArgs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structante_1_1CompilerArgs.html">CompilerArgs</a> *&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets appropriate flags and executes operations specified by the command line arguments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>The command line arguments </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a72d9ff3f1651d1de1f3c78901925da8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72d9ff3f1651d1de1f3c78901925da8e">&#9670;&nbsp;</a></span>searchAndReplaceBoundTypeVars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ante::Compiler::searchAndReplaceBoundTypeVars </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structante_1_1TypeNode.html">TypeNode</a> *&#160;</td>
          <td class="paramname"><em>tn</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches through tn and replaces any typevars inside with their definition from a lookup if found. </p>
<p>Care must be taken so that the resulting <a class="el" href="structante_1_1TypeNode.html">TypeNode</a> not escape the scope of the typevars in the lookup. Thus, this function should not be used for TypeNodes that may be reused at lower scopes. </p>

</div>
</div>
<a id="aad5d03a0bef93374a1f9e54406c1f5ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad5d03a0bef93374a1f9e54406c1f5ab">&#9670;&nbsp;</a></span>stoType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ante::Compiler::stoType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structante_1_1DataType.html">DataType</a> *&#160;</td>
          <td class="paramname"><em>ty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>typeName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores a new <a class="el" href="structante_1_1DataType.html" title="Contains information about a data type. ">DataType</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ty</td><td>The <a class="el" href="structante_1_1DataType.html" title="Contains information about a data type. ">DataType</a> to store </td></tr>
    <tr><td class="paramname">typeName</td><td>The name of the <a class="el" href="structante_1_1DataType.html" title="Contains information about a data type. ">DataType</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae0398f0c21b54f2a3bef8961ed042705"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0398f0c21b54f2a3bef8961ed042705">&#9670;&nbsp;</a></span>stoTypeVar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ante::Compiler::stoTypeVar </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structante_1_1TypeNode.html">TypeNode</a> *&#160;</td>
          <td class="paramname"><em>ty</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stores a TypeVar in the current scope. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the typevar to store (including the preceeding ') </td></tr>
    <tr><td class="paramname">ty</td><td>The type to store </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad1bc6b687a50f60ccdd258668c580694"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1bc6b687a50f60ccdd258668c580694">&#9670;&nbsp;</a></span>stoVar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ante::Compiler::stoVar </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structante_1_1Variable.html">Variable</a> *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stores a variable in the current scope. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">var</td><td>Name of the variable to store </td></tr>
    <tr><td class="paramname">val</td><td><a class="el" href="structante_1_1Variable.html">Variable</a> to store </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a42313239d22ef4cc13891726d62548c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42313239d22ef4cc13891726d62548c9">&#9670;&nbsp;</a></span>typeEq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structante_1_1TypeCheckResult.html">TypeCheckResult</a> ante::Compiler::typeEq </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structante_1_1TypeNode.html">TypeNode</a> *&gt;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structante_1_1TypeNode.html">TypeNode</a> *&gt;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a type check against l and r. </p>
<p>Used for function parameters and similar situations where typevars across multiple type checks need to be consistent. Eg. a function of type ('t, 't)-&gt;void should not match the arguments i32 and u64. Performing a typecheck on each argument separately would give a different bound value for 't. Using this function would result in the appropriate TypeCheckResult::Failure </p>

</div>
</div>
<a id="a452d693a23c3690bd955a0a04bc3e653"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a452d693a23c3690bd955a0a04bc3e653">&#9670;&nbsp;</a></span>typeImplementsTrait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ante::Compiler::typeImplementsTrait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structante_1_1DataType.html">DataType</a> *&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>traitName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if a <a class="el" href="structante_1_1DataType.html" title="Contains information about a data type. ">DataType</a> implements the specified trait </dd></dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>master/include/<a class="el" href="compiler_8h_source.html">compiler.h</a></li>
<li>master/src/compiler.cpp</li>
<li>master/src/error.cpp</li>
<li>master/src/function.cpp</li>
<li>master/src/operator.cpp</li>
<li>master/src/types.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
