<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ante</title>
    <link>https://jfecher.github.io/ante/public/</link>
    <description>Recent content on Ante</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 15 Nov 2017 14:33:28 -0500</lastBuildDate>
    
	<atom:link href="https://jfecher.github.io/ante/public/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Build System</title>
      <link>https://jfecher.github.io/ante/public/compiler-extensions/build-system/</link>
      <pubDate>Wed, 15 Nov 2017 14:33:28 -0500</pubDate>
      
      <guid>https://jfecher.github.io/ante/public/compiler-extensions/build-system/</guid>
      <description>The Build module defines several useful functions for compiling and linking applications. Its interface is as follows:
option ante fun option: Str opt  Equivalent to passing the string opt while evoking the compiler, eg. a call to option &amp;quot;-O3&amp;quot; is equivalent to compiling a module with ante -O3
If the given option is not recognized a compilation error will be issued with the message &amp;ldquo;Unrecognized option ${opt}&amp;rdquo;
ante fun option: CompilerFlag f  Enables the compiler flag f.</description>
    </item>
    
    <item>
      <title>Loops</title>
      <link>https://jfecher.github.io/ante/public/tutorial/loops/</link>
      <pubDate>Wed, 15 Nov 2017 14:15:21 -0500</pubDate>
      
      <guid>https://jfecher.github.io/ante/public/tutorial/loops/</guid>
      <description>Ante provides two forms of loops: while and for.
While While loops are the most basic form of loop, they continue executing their body while the given condition remains true. The syntax is as follows:
while &amp;lt;expr&amp;gt; do &amp;lt;expr&amp;gt;  The first expression is the loop condition and must evaluate to a bool. The second expression is the body to loop over, and is usually a block. While loops are often used when you are unsure precisely how many times you should loop.</description>
    </item>
    
    <item>
      <title>Pattern Matching</title>
      <link>https://jfecher.github.io/ante/public/tutorial/pattern-matching/</link>
      <pubDate>Wed, 15 Nov 2017 14:14:23 -0500</pubDate>
      
      <guid>https://jfecher.github.io/ante/public/tutorial/pattern-matching/</guid>
      <description>Pattern matching is a powerful tool that compares a value against a several patterns until it finds one that matches. These patterns can range from simple literal values to a complex assortment and combination of other patterns, most of which are covered below.
Perhaps most importantly, pattern Matches with are completeness checked, so all possibilities for a given value must be covered. For example, a match against an integer x with a single pattern 0 (the equivalent of if x == 0) is rejected as it does not have a case for when x !</description>
    </item>
    
    <item>
      <title>If</title>
      <link>https://jfecher.github.io/ante/public/tutorial/if/</link>
      <pubDate>Wed, 15 Nov 2017 14:14:02 -0500</pubDate>
      
      <guid>https://jfecher.github.io/ante/public/tutorial/if/</guid>
      <description> Expressions Elif Chains Return Value </description>
    </item>
    
    <item>
      <title>Blocks</title>
      <link>https://jfecher.github.io/ante/public/tutorial/blocks/</link>
      <pubDate>Wed, 15 Nov 2017 14:12:44 -0500</pubDate>
      
      <guid>https://jfecher.github.io/ante/public/tutorial/blocks/</guid>
      <description> Block Keyword Indentation Ignored within (), [], and {} { and } can replace indents </description>
    </item>
    
    <item>
      <title>Traits</title>
      <link>https://jfecher.github.io/ante/public/tutorial/traits/</link>
      <pubDate>Wed, 15 Nov 2017 14:11:54 -0500</pubDate>
      
      <guid>https://jfecher.github.io/ante/public/tutorial/traits/</guid>
      <description> In Type Declarations Extending A Type With A Trait In External Modules </description>
    </item>
    
    <item>
      <title>Modules</title>
      <link>https://jfecher.github.io/ante/public/tutorial/modules/</link>
      <pubDate>Wed, 15 Nov 2017 14:11:33 -0500</pubDate>
      
      <guid>https://jfecher.github.io/ante/public/tutorial/modules/</guid>
      <description> Imports Visibility Type Extensions </description>
    </item>
    
    <item>
      <title>Compiler Directives</title>
      <link>https://jfecher.github.io/ante/public/tutorial/compiler-directives/</link>
      <pubDate>Wed, 15 Nov 2017 14:11:01 -0500</pubDate>
      
      <guid>https://jfecher.github.io/ante/public/tutorial/compiler-directives/</guid>
      <description>As the &amp;ldquo;compile-time&amp;rdquo; language Ante naturally needs a mechanism for interacting with the compiler and other compile-time constructs. Of course, you can use the ante modifier or any of the builtin compile-time functions in the Ante module but to properly leverage the full power of Ante it is necessary to learn about compiler directives.
In Ante, compiler directives are essentially user-defined modifiers. Just like modifiers, compiler-directives can be used to modify variable declarations, function declarations, or even arbitrary expressions.</description>
    </item>
    
    <item>
      <title>Modifiers</title>
      <link>https://jfecher.github.io/ante/public/tutorial/modifiers/</link>
      <pubDate>Wed, 15 Nov 2017 14:10:13 -0500</pubDate>
      
      <guid>https://jfecher.github.io/ante/public/tutorial/modifiers/</guid>
      <description>pub, pri, pro, const raw noinit global ante
Modifiers can appear before and modify any declaration (function, variable, or type), any type, or any arbitrary expression.
For example, the ante modifier used before a function marks the function&amp;rsquo;s parameters and its output as compile-time constants and the function itself to be executed during compile-time. Before a type declaration, it signifies the value of the type should always be known during compile-time.</description>
    </item>
    
    <item>
      <title>Variables</title>
      <link>https://jfecher.github.io/ante/public/tutorial/variables/</link>
      <pubDate>Wed, 15 Nov 2017 14:09:45 -0500</pubDate>
      
      <guid>https://jfecher.github.io/ante/public/tutorial/variables/</guid>
      <description> Let Var Assignment Explicit Types </description>
    </item>
    
    <item>
      <title>Functions</title>
      <link>https://jfecher.github.io/ante/public/tutorial/functions/</link>
      <pubDate>Wed, 15 Nov 2017 14:07:26 -0500</pubDate>
      
      <guid>https://jfecher.github.io/ante/public/tutorial/functions/</guid>
      <description>Function Calls The syntax for calling a function is f arg1 arg2 ... argn. The arguments are separated by spaces and are each expressions, although the only operator with a higher precedence than a function call is . to access fields. For example, to call the print function with the parameters 2 and &amp;ldquo;three&amp;rdquo;:
print 2 &amp;quot;three&amp;quot;  UFCS Universal Function Call Syntax is fully supported on every function. That is to say that the call f arg1 arg2 .</description>
    </item>
    
    <item>
      <title>Operators</title>
      <link>https://jfecher.github.io/ante/public/tutorial/operators/</link>
      <pubDate>Wed, 15 Nov 2017 14:03:27 -0500</pubDate>
      
      <guid>https://jfecher.github.io/ante/public/tutorial/operators/</guid>
      <description>Binary Arithmetic + - * / %
Logical &amp;lt; &amp;gt; &amp;lt;= &amp;gt;= == != is and or
Assignment = &amp;lt;binop&amp;gt;=
Bitwise implemented as library functions. Bitwise.xor a b
Other in ++ .. # ; . |&amp;gt; &amp;lt;|
Unary not new - @ &amp;amp;
Operator Precedence    Operator Unary or Binary Associativity Precedence     . Binary Left 17   &amp;amp; Unary Right 16   new Unary Right 15   - Unary Right 15   @ Unary Right 15   # Binary Left 14   * Binary Left 13   / Binary Left 13   % Binary Left 13   + Binary Left 12   - Binary Left 12   .</description>
    </item>
    
    <item>
      <title>Type Casts</title>
      <link>https://jfecher.github.io/ante/public/tutorial/type-casts/</link>
      <pubDate>Wed, 15 Nov 2017 14:02:48 -0500</pubDate>
      
      <guid>https://jfecher.github.io/ante/public/tutorial/type-casts/</guid>
      <description> Explicit Casts Generic Casts Implicit Casts </description>
    </item>
    
    <item>
      <title>Type Declarations</title>
      <link>https://jfecher.github.io/ante/public/tutorial/type_declarations/</link>
      <pubDate>Wed, 15 Nov 2017 14:01:44 -0500</pubDate>
      
      <guid>https://jfecher.github.io/ante/public/tutorial/type_declarations/</guid>
      <description> Basic Structs and Records Tagged Unions Type Aliases </description>
    </item>
    
    <item>
      <title>Types</title>
      <link>https://jfecher.github.io/ante/public/tutorial/types/</link>
      <pubDate>Wed, 15 Nov 2017 14:00:44 -0500</pubDate>
      
      <guid>https://jfecher.github.io/ante/public/tutorial/types/</guid>
      <description> Primitives Pointers Arrays Tuples Sum Types Type Variables Trait Types </description>
    </item>
    
    <item>
      <title>Literals</title>
      <link>https://jfecher.github.io/ante/public/tutorial/literals/</link>
      <pubDate>Tue, 14 Nov 2017 17:53:00 -0500</pubDate>
      
      <guid>https://jfecher.github.io/ante/public/tutorial/literals/</guid>
      <description>Ante has four types of literal values: integers, floats, booleans, and strings. Every literal, except for strings, is a primitive type.
Integers Integer literals in Ante can be any primitive integer type, i8, i16, i32, i64, u8, u16, u32, u64, isz, or usz. Without a type suffix, an integer literal&amp;rsquo;s default type is i32. Integer literals have four parts: the optional base notation, the number itself, the optional exponent, and the optional type suffix.</description>
    </item>
    
  </channel>
</rss>