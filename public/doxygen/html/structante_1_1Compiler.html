<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Ante: ante::Compiler Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Ante
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>ante</b></li><li class="navelem"><a class="el" href="structante_1_1Compiler.html">Compiler</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structante_1_1Compiler-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ante::Compiler Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>An Ante compiler responsible for a single module.  
 <a href="structante_1_1Compiler.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="compiler_8h_source.html">compiler.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afdb96f422caf19f04ca073fe495c1a72"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#afdb96f422caf19f04ca073fe495c1a72">Compiler</a> (const char *fileName, bool lib=false, std::shared_ptr&lt; llvm::LLVMContext &gt; ctxt=nullptr)</td></tr>
<tr class="memdesc:afdb96f422caf19f04ca073fe495c1a72"><td class="mdescLeft">&#160;</td><td class="mdescRight">The main constructor for <a class="el" href="structante_1_1Compiler.html" title="An Ante compiler responsible for a single module. ">Compiler</a>.  <a href="#afdb96f422caf19f04ca073fe495c1a72">More...</a><br /></td></tr>
<tr class="separator:afdb96f422caf19f04ca073fe495c1a72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32d6af78b250b54b0142e3d258ba944e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#a32d6af78b250b54b0142e3d258ba944e">Compiler</a> (<a class="el" href="structante_1_1Compiler.html">Compiler</a> *c, <a class="el" href="structante_1_1parser_1_1Node.html">parser::Node</a> *root, std::string modName, bool lib=false)</td></tr>
<tr class="memdesc:a32d6af78b250b54b0142e3d258ba944e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for a <a class="el" href="structante_1_1Compiler.html" title="An Ante compiler responsible for a single module. ">Compiler</a> compiling a sub-module within the current file.  <a href="#a32d6af78b250b54b0142e3d258ba944e">More...</a><br /></td></tr>
<tr class="separator:a32d6af78b250b54b0142e3d258ba944e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad90a555d154fdd436ef0a9ae4e68185f"><td class="memItemLeft" align="right" valign="top"><a id="ad90a555d154fdd436ef0a9ae4e68185f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#ad90a555d154fdd436ef0a9ae4e68185f">compile</a> ()</td></tr>
<tr class="memdesc:ad90a555d154fdd436ef0a9ae4e68185f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully compiles a module into llvm bytecode. <br /></td></tr>
<tr class="separator:ad90a555d154fdd436ef0a9ae4e68185f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14d932ffda1eb271c27205be1a8d7cfb"><td class="memItemLeft" align="right" valign="top"><a id="a14d932ffda1eb271c27205be1a8d7cfb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#a14d932ffda1eb271c27205be1a8d7cfb">compileNative</a> ()</td></tr>
<tr class="memdesc:a14d932ffda1eb271c27205be1a8d7cfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compiles a native binary. <br /></td></tr>
<tr class="separator:a14d932ffda1eb271c27205be1a8d7cfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4729b39972523c4996debf67113376c6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#a4729b39972523c4996debf67113376c6">compileObj</a> (std::string &amp;outName)</td></tr>
<tr class="memdesc:a4729b39972523c4996debf67113376c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compiles a module to an object file.  <a href="#a4729b39972523c4996debf67113376c6">More...</a><br /></td></tr>
<tr class="separator:a4729b39972523c4996debf67113376c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a5e861e43aa9644bde7521e854434d0"><td class="memItemLeft" align="right" valign="top"><a id="a6a5e861e43aa9644bde7521e854434d0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#a6a5e861e43aa9644bde7521e854434d0">compilePrelude</a> ()</td></tr>
<tr class="memdesc:a6a5e861e43aa9644bde7521e854434d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Imports the prelude module unless the current module is the prelude. <br /></td></tr>
<tr class="separator:a6a5e861e43aa9644bde7521e854434d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9586ff05c0f9b53e950e27cf0427d357"><td class="memItemLeft" align="right" valign="top">llvm::Function *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#a9586ff05c0f9b53e950e27cf0427d357">createMainFn</a> ()</td></tr>
<tr class="memdesc:a9586ff05c0f9b53e950e27cf0427d357"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the main function of a main module or creates the library_init function of a lib module.  <a href="#a9586ff05c0f9b53e950e27cf0427d357">More...</a><br /></td></tr>
<tr class="separator:a9586ff05c0f9b53e950e27cf0427d357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8601989e980b18b0020ae3bb0e019ebf"><td class="memItemLeft" align="right" valign="top"><a id="a8601989e980b18b0020ae3bb0e019ebf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#a8601989e980b18b0020ae3bb0e019ebf">eval</a> ()</td></tr>
<tr class="memdesc:a8601989e980b18b0020ae3bb0e019ebf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts the REPL. <br /></td></tr>
<tr class="separator:a8601989e980b18b0020ae3bb0e019ebf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90c0d7b91fd51ef50bd6785a391c5fbb"><td class="memItemLeft" align="right" valign="top"><a id="a90c0d7b91fd51ef50bd6785a391c5fbb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#a90c0d7b91fd51ef50bd6785a391c5fbb">emitIR</a> ()</td></tr>
<tr class="memdesc:a90c0d7b91fd51ef50bd6785a391c5fbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumps current contents of module to stdout. <br /></td></tr>
<tr class="separator:a90c0d7b91fd51ef50bd6785a391c5fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dad7943c8df0d795353bad94fc085b3"><td class="memItemLeft" align="right" valign="top"><a id="a2dad7943c8df0d795353bad94fc085b3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#a2dad7943c8df0d795353bad94fc085b3">enterNewScope</a> ()</td></tr>
<tr class="memdesc:a2dad7943c8df0d795353bad94fc085b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and enters a new scope. <br /></td></tr>
<tr class="separator:a2dad7943c8df0d795353bad94fc085b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7207955f5a2786b656c80be7283c467"><td class="memItemLeft" align="right" valign="top"><a id="ad7207955f5a2786b656c80be7283c467"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#ad7207955f5a2786b656c80be7283c467">exitScope</a> ()</td></tr>
<tr class="memdesc:ad7207955f5a2786b656c80be7283c467"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exits a scope and performs any necessary cleanup. <br /></td></tr>
<tr class="separator:ad7207955f5a2786b656c80be7283c467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d05473024c5cbd5841f976a0cd08bb4"><td class="memItemLeft" align="right" valign="top"><a id="a9d05473024c5cbd5841f976a0cd08bb4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#a9d05473024c5cbd5841f976a0cd08bb4">scanAllDecls</a> (<a class="el" href="structante_1_1parser_1_1RootNode.html">parser::RootNode</a> *n=0)</td></tr>
<tr class="memdesc:a9d05473024c5cbd5841f976a0cd08bb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sweeps through parse tree registering all functions, type declarations, and traits. <br /></td></tr>
<tr class="separator:a9d05473024c5cbd5841f976a0cd08bb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf5d0d47a6f50d33ab75853c51defb2a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#adf5d0d47a6f50d33ab75853c51defb2a">processArgs</a> (<a class="el" href="structante_1_1CompilerArgs.html">CompilerArgs</a> *args)</td></tr>
<tr class="memdesc:adf5d0d47a6f50d33ab75853c51defb2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets appropriate flags and executes operations specified by the command line arguments.  <a href="#adf5d0d47a6f50d33ab75853c51defb2a">More...</a><br /></td></tr>
<tr class="separator:adf5d0d47a6f50d33ab75853c51defb2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24d957798fbe9610d23f79feb5d40e34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structante_1_1TypedValue.html">TypedValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#a24d957798fbe9610d23f79feb5d40e34">compAdd</a> (<a class="el" href="structante_1_1TypedValue.html">TypedValue</a> &amp;l, <a class="el" href="structante_1_1TypedValue.html">TypedValue</a> &amp;r, <a class="el" href="structante_1_1parser_1_1BinOpNode.html">parser::BinOpNode</a> *op)</td></tr>
<tr class="memdesc:a24d957798fbe9610d23f79feb5d40e34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emits an add instruction.  <a href="#a24d957798fbe9610d23f79feb5d40e34">More...</a><br /></td></tr>
<tr class="separator:a24d957798fbe9610d23f79feb5d40e34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8060aca7a440989c02572641fd758a6a"><td class="memItemLeft" align="right" valign="top"><a id="a8060aca7a440989c02572641fd758a6a"></a>
<a class="el" href="structante_1_1TypedValue.html">TypedValue</a>&#160;</td><td class="memItemRight" valign="bottom"><b>compSub</b> (<a class="el" href="structante_1_1TypedValue.html">TypedValue</a> &amp;l, <a class="el" href="structante_1_1TypedValue.html">TypedValue</a> &amp;r, <a class="el" href="structante_1_1parser_1_1BinOpNode.html">parser::BinOpNode</a> *op)</td></tr>
<tr class="separator:a8060aca7a440989c02572641fd758a6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a2521c12dc8de36d84b50984f73d662"><td class="memItemLeft" align="right" valign="top"><a id="a0a2521c12dc8de36d84b50984f73d662"></a>
<a class="el" href="structante_1_1TypedValue.html">TypedValue</a>&#160;</td><td class="memItemRight" valign="bottom"><b>compMul</b> (<a class="el" href="structante_1_1TypedValue.html">TypedValue</a> &amp;l, <a class="el" href="structante_1_1TypedValue.html">TypedValue</a> &amp;r, <a class="el" href="structante_1_1parser_1_1BinOpNode.html">parser::BinOpNode</a> *op)</td></tr>
<tr class="separator:a0a2521c12dc8de36d84b50984f73d662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58672a562a807043c26f3ed04945d6ef"><td class="memItemLeft" align="right" valign="top"><a id="a58672a562a807043c26f3ed04945d6ef"></a>
<a class="el" href="structante_1_1TypedValue.html">TypedValue</a>&#160;</td><td class="memItemRight" valign="bottom"><b>compDiv</b> (<a class="el" href="structante_1_1TypedValue.html">TypedValue</a> &amp;l, <a class="el" href="structante_1_1TypedValue.html">TypedValue</a> &amp;r, <a class="el" href="structante_1_1parser_1_1BinOpNode.html">parser::BinOpNode</a> *op)</td></tr>
<tr class="separator:a58672a562a807043c26f3ed04945d6ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a343ed19def0d1b3d24f25526c4b5620f"><td class="memItemLeft" align="right" valign="top"><a id="a343ed19def0d1b3d24f25526c4b5620f"></a>
<a class="el" href="structante_1_1TypedValue.html">TypedValue</a>&#160;</td><td class="memItemRight" valign="bottom"><b>compRem</b> (<a class="el" href="structante_1_1TypedValue.html">TypedValue</a> &amp;l, <a class="el" href="structante_1_1TypedValue.html">TypedValue</a> &amp;r, <a class="el" href="structante_1_1parser_1_1BinOpNode.html">parser::BinOpNode</a> *op)</td></tr>
<tr class="separator:a343ed19def0d1b3d24f25526c4b5620f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77fcf22917c28c7c88ecb0022aa30714"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structante_1_1TypedValue.html">TypedValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#a77fcf22917c28c7c88ecb0022aa30714">compExtract</a> (<a class="el" href="structante_1_1TypedValue.html">TypedValue</a> &amp;l, <a class="el" href="structante_1_1TypedValue.html">TypedValue</a> &amp;r, <a class="el" href="structante_1_1parser_1_1BinOpNode.html">parser::BinOpNode</a> *op)</td></tr>
<tr class="memdesc:a77fcf22917c28c7c88ecb0022aa30714"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compiles an extract operation such as array::index.  <a href="#a77fcf22917c28c7c88ecb0022aa30714">More...</a><br /></td></tr>
<tr class="separator:a77fcf22917c28c7c88ecb0022aa30714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1da356dd307491d183153e7f0e6cab8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structante_1_1TypedValue.html">TypedValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#ab1da356dd307491d183153e7f0e6cab8">compInsert</a> (<a class="el" href="structante_1_1parser_1_1BinOpNode.html">parser::BinOpNode</a> *insertOp, <a class="el" href="structante_1_1parser_1_1Node.html">parser::Node</a> *assignExpr)</td></tr>
<tr class="memdesc:ab1da356dd307491d183153e7f0e6cab8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compiles an insert operation such as array::index = 2.  <a href="#ab1da356dd307491d183153e7f0e6cab8">More...</a><br /></td></tr>
<tr class="separator:ab1da356dd307491d183153e7f0e6cab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5344f586b928cad058d9a2fb93f056c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structante_1_1TypedValue.html">TypedValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#aa5344f586b928cad058d9a2fb93f056c">compMemberAccess</a> (<a class="el" href="structante_1_1parser_1_1Node.html">parser::Node</a> *ln, <a class="el" href="structante_1_1parser_1_1VarNode.html">parser::VarNode</a> *field, <a class="el" href="structante_1_1parser_1_1BinOpNode.html">parser::BinOpNode</a> *binop)</td></tr>
<tr class="memdesc:aa5344f586b928cad058d9a2fb93f056c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compiles a named member access such as str.len.  <a href="#aa5344f586b928cad058d9a2fb93f056c">More...</a><br /></td></tr>
<tr class="separator:aa5344f586b928cad058d9a2fb93f056c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa994d92c590c407d924e54d5904b51e3"><td class="memItemLeft" align="right" valign="top"><a id="aa994d92c590c407d924e54d5904b51e3"></a>
<a class="el" href="structante_1_1TypedValue.html">TypedValue</a>&#160;</td><td class="memItemRight" valign="bottom"><b>compLogicalOr</b> (<a class="el" href="structante_1_1parser_1_1Node.html">parser::Node</a> *l, <a class="el" href="structante_1_1parser_1_1Node.html">parser::Node</a> *r, <a class="el" href="structante_1_1parser_1_1BinOpNode.html">parser::BinOpNode</a> *op)</td></tr>
<tr class="separator:aa994d92c590c407d924e54d5904b51e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ebe1d1ab6ba72abbbf3a742d0d2a336"><td class="memItemLeft" align="right" valign="top"><a id="a5ebe1d1ab6ba72abbbf3a742d0d2a336"></a>
<a class="el" href="structante_1_1TypedValue.html">TypedValue</a>&#160;</td><td class="memItemRight" valign="bottom"><b>compLogicalAnd</b> (<a class="el" href="structante_1_1parser_1_1Node.html">parser::Node</a> *l, <a class="el" href="structante_1_1parser_1_1Node.html">parser::Node</a> *r, <a class="el" href="structante_1_1parser_1_1BinOpNode.html">parser::BinOpNode</a> *op)</td></tr>
<tr class="separator:a5ebe1d1ab6ba72abbbf3a742d0d2a336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37dc19abb16179a71006cfa8554b77f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structante_1_1TypedValue.html">TypedValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#a37dc19abb16179a71006cfa8554b77f8">compErr</a> (<a class="el" href="structante_1_1lazy__printer.html">lazy_printer</a> msg, const <a class="el" href="classyy_1_1location.html">yy::location</a> &amp;loc, ErrorType t=ErrorType::Error)</td></tr>
<tr class="memdesc:a37dc19abb16179a71006cfa8554b77f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports a message and highlights the relevant source lines.  <a href="#a37dc19abb16179a71006cfa8554b77f8">More...</a><br /></td></tr>
<tr class="separator:a37dc19abb16179a71006cfa8554b77f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3af8de2adf0b373475eb4f25f5c62492"><td class="memItemLeft" align="right" valign="top"><a id="a3af8de2adf0b373475eb4f25f5c62492"></a>
<a class="el" href="structante_1_1TypedValue.html">TypedValue</a>&#160;</td><td class="memItemRight" valign="bottom"><b>compErr</b> (<a class="el" href="structante_1_1lazy__printer.html">lazy_printer</a> msg, ErrorType t=ErrorType::Error)</td></tr>
<tr class="separator:a3af8de2adf0b373475eb4f25f5c62492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac0d539920d04deb2143881fc6f13530"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#aac0d539920d04deb2143881fc6f13530">jitFunction</a> (llvm::Function *fnName)</td></tr>
<tr class="memdesc:aac0d539920d04deb2143881fc6f13530"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classante_1_1JIT.html">JIT</a> compiles a function with no arguments and calls it afterward.  <a href="#aac0d539920d04deb2143881fc6f13530">More...</a><br /></td></tr>
<tr class="separator:aac0d539920d04deb2143881fc6f13530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dff5018bf45f7895df5b2bba1f8048f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#a0dff5018bf45f7895df5b2bba1f8048f">importFile</a> (const char *name, <a class="el" href="structante_1_1parser_1_1Node.html">parser::Node</a> *locNode=0)</td></tr>
<tr class="memdesc:a0dff5018bf45f7895df5b2bba1f8048f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Imports a given ante file to the current module inputted file must exist and be a valid ante source file.  <a href="#a0dff5018bf45f7895df5b2bba1f8048f">More...</a><br /></td></tr>
<tr class="separator:a0dff5018bf45f7895df5b2bba1f8048f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a719981451ea6fe1eeab3c68970a27dec"><td class="memItemLeft" align="right" valign="top"><a id="a719981451ea6fe1eeab3c68970a27dec"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#a719981451ea6fe1eeab3c68970a27dec">updateFn</a> (<a class="el" href="structante_1_1TypedValue.html">TypedValue</a> &amp;f, <a class="el" href="structante_1_1FuncDecl.html">FuncDecl</a> *fd, std::string &amp;name, std::string &amp;mangledName)</td></tr>
<tr class="memdesc:a719981451ea6fe1eeab3c68970a27dec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the tv of the <a class="el" href="structante_1_1FuncDecl.html" title="Contains information about a function that is not contained within its FuncDeclNode. ">FuncDecl</a> specified to the value of f. <br /></td></tr>
<tr class="separator:a719981451ea6fe1eeab3c68970a27dec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae81e93dc33f382e5e3b6f89bbda80a05"><td class="memItemLeft" align="right" valign="top"><a id="ae81e93dc33f382e5e3b6f89bbda80a05"></a>
<a class="el" href="structante_1_1FuncDecl.html">FuncDecl</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getCurrentFunction</b> () const</td></tr>
<tr class="separator:ae81e93dc33f382e5e3b6f89bbda80a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc48133db3237d5db70f9aac7c43fb98"><td class="memItemLeft" align="right" valign="top"><a id="afc48133db3237d5db70f9aac7c43fb98"></a>
<a class="el" href="structante_1_1TypedValue.html">TypedValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#afc48133db3237d5db70f9aac7c43fb98">getFunction</a> (std::string &amp;name, std::string &amp;mangledName)</td></tr>
<tr class="memdesc:afc48133db3237d5db70f9aac7c43fb98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the exact function specified if found or nullptr if not. <br /></td></tr>
<tr class="separator:afc48133db3237d5db70f9aac7c43fb98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6322062f57deeec58ea4a2c3c436b27c"><td class="memItemLeft" align="right" valign="top"><a id="a6322062f57deeec58ea4a2c3c436b27c"></a>
std::vector&lt; std::shared_ptr&lt; <a class="el" href="structante_1_1FuncDecl.html">FuncDecl</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#a6322062f57deeec58ea4a2c3c436b27c">getFunctionList</a> (std::string &amp;name) const</td></tr>
<tr class="memdesc:a6322062f57deeec58ea4a2c3c436b27c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of all functions with the specified baseName. <br /></td></tr>
<tr class="separator:a6322062f57deeec58ea4a2c3c436b27c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20b44eb99cf51b96158a1363b4f6710c"><td class="memItemLeft" align="right" valign="top"><a id="a20b44eb99cf51b96158a1363b4f6710c"></a>
<a class="el" href="structante_1_1FuncDecl.html">FuncDecl</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#a20b44eb99cf51b96158a1363b4f6710c">getFuncDecl</a> (std::string bn, std::string mangledName)</td></tr>
<tr class="memdesc:a20b44eb99cf51b96158a1363b4f6710c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the exact <a class="el" href="structante_1_1FuncDecl.html" title="Contains information about a function that is not contained within its FuncDeclNode. ">FuncDecl</a> specified if found or nullptr if not. <br /></td></tr>
<tr class="separator:a20b44eb99cf51b96158a1363b4f6710c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8432786004d51bc7cafc2dd4fcbf4d3"><td class="memItemLeft" align="right" valign="top"><a id="af8432786004d51bc7cafc2dd4fcbf4d3"></a>
<a class="el" href="structante_1_1TypedValue.html">TypedValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#af8432786004d51bc7cafc2dd4fcbf4d3">callFn</a> (std::string fnBaseName, std::vector&lt; <a class="el" href="structante_1_1TypedValue.html">TypedValue</a> &gt; args)</td></tr>
<tr class="memdesc:af8432786004d51bc7cafc2dd4fcbf4d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emits and returns a function call. <br /></td></tr>
<tr class="separator:af8432786004d51bc7cafc2dd4fcbf4d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95122318dcd35120b39aa83245accef7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structante_1_1TypedValue.html">TypedValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#a95122318dcd35120b39aa83245accef7">getMangledFn</a> (std::string name, std::vector&lt; <a class="el" href="classante_1_1AnType.html">AnType</a> *&gt; &amp;args)</td></tr>
<tr class="memdesc:a95122318dcd35120b39aa83245accef7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the function specified.  <a href="#a95122318dcd35120b39aa83245accef7">More...</a><br /></td></tr>
<tr class="separator:a95122318dcd35120b39aa83245accef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56fa1c0637373bc464845c7b1006ea2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structante_1_1TypedValue.html">TypedValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#a56fa1c0637373bc464845c7b1006ea2d">getCastFn</a> (<a class="el" href="classante_1_1AnType.html">AnType</a> *from_ty, <a class="el" href="classante_1_1AnType.html">AnType</a> *to_ty, <a class="el" href="structante_1_1FuncDecl.html">FuncDecl</a> *fd=0)</td></tr>
<tr class="memdesc:a56fa1c0637373bc464845c7b1006ea2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the init method of a type.  <a href="#a56fa1c0637373bc464845c7b1006ea2d">More...</a><br /></td></tr>
<tr class="separator:a56fa1c0637373bc464845c7b1006ea2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebe63e69261dbecc8571ddb084fcaa46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structante_1_1FuncDecl.html">FuncDecl</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#aebe63e69261dbecc8571ddb084fcaa46">getMangledFuncDecl</a> (std::string name, std::vector&lt; <a class="el" href="classante_1_1AnType.html">AnType</a> *&gt; &amp;args)</td></tr>
<tr class="memdesc:aebe63e69261dbecc8571ddb084fcaa46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the <a class="el" href="structante_1_1FuncDecl.html" title="Contains information about a function that is not contained within its FuncDeclNode. ">FuncDecl</a> specified.  <a href="#aebe63e69261dbecc8571ddb084fcaa46">More...</a><br /></td></tr>
<tr class="separator:aebe63e69261dbecc8571ddb084fcaa46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7003a0e0e7204d7d90f52749131a735"><td class="memItemLeft" align="right" valign="top"><a id="aa7003a0e0e7204d7d90f52749131a735"></a>
<a class="el" href="structante_1_1FuncDecl.html">FuncDecl</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getCastFuncDecl</b> (<a class="el" href="classante_1_1AnType.html">AnType</a> *from_ty, <a class="el" href="classante_1_1AnType.html">AnType</a> *to_ty)</td></tr>
<tr class="separator:aa7003a0e0e7204d7d90f52749131a735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c889d4d40dfb08252b3d0c000c5f931"><td class="memItemLeft" align="right" valign="top"><a id="a1c889d4d40dfb08252b3d0c000c5f931"></a>
<a class="el" href="structante_1_1TypedValue.html">TypedValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#a1c889d4d40dfb08252b3d0c000c5f931">compLetBindingFn</a> (<a class="el" href="structante_1_1FuncDecl.html">FuncDecl</a> *fdn, std::vector&lt; llvm::Type *&gt; &amp;paramTys)</td></tr>
<tr class="memdesc:a1c889d4d40dfb08252b3d0c000c5f931"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compiles a function with inferred return type. <br /></td></tr>
<tr class="separator:a1c889d4d40dfb08252b3d0c000c5f931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d801a585a6bfc19a07ca8ea558f8398"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structante_1_1TypedValue.html">TypedValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#a1d801a585a6bfc19a07ca8ea558f8398">compFn</a> (<a class="el" href="structante_1_1FuncDecl.html">FuncDecl</a> *fn)</td></tr>
<tr class="memdesc:a1d801a585a6bfc19a07ca8ea558f8398"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compiles any non-generic function.  <a href="#a1d801a585a6bfc19a07ca8ea558f8398">More...</a><br /></td></tr>
<tr class="separator:a1d801a585a6bfc19a07ca8ea558f8398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ecb12ef245eb6fb3638f4357bc8a2d2"><td class="memItemLeft" align="right" valign="top"><a id="a8ecb12ef245eb6fb3638f4357bc8a2d2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>registerFunction</b> (<a class="el" href="structante_1_1parser_1_1FuncDeclNode.html">parser::FuncDeclNode</a> *func, std::string &amp;mangledName)</td></tr>
<tr class="separator:a8ecb12ef245eb6fb3638f4357bc8a2d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9a29d3daf69b8ad5b52e6fb27383fe4"><td class="memItemLeft" align="right" valign="top"><a id="ad9a29d3daf69b8ad5b52e6fb27383fe4"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>getScope</b> () const</td></tr>
<tr class="separator:ad9a29d3daf69b8ad5b52e6fb27383fe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01a995b28b305621ca2d8f6f649258f2"><td class="memItemLeft" align="right" valign="top"><a id="a01a995b28b305621ca2d8f6f649258f2"></a>
std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getModuleName</b> () const</td></tr>
<tr class="separator:a01a995b28b305621ca2d8f6f649258f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3c37473195d132a18f72af945032445"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structante_1_1Variable.html">Variable</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#ae3c37473195d132a18f72af945032445">lookup</a> (std::string var) const</td></tr>
<tr class="memdesc:ae3c37473195d132a18f72af945032445"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a lookup for a variable.  <a href="#ae3c37473195d132a18f72af945032445">More...</a><br /></td></tr>
<tr class="separator:ae3c37473195d132a18f72af945032445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1bc6b687a50f60ccdd258668c580694"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#ad1bc6b687a50f60ccdd258668c580694">stoVar</a> (std::string var, <a class="el" href="structante_1_1Variable.html">Variable</a> *val)</td></tr>
<tr class="memdesc:ad1bc6b687a50f60ccdd258668c580694"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a variable in the current scope.  <a href="#ad1bc6b687a50f60ccdd258668c580694">More...</a><br /></td></tr>
<tr class="separator:ad1bc6b687a50f60ccdd258668c580694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a318ab2029fa46fcf5d06b00ec9baf6b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classante_1_1AnDataType.html">AnDataType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#a318ab2029fa46fcf5d06b00ec9baf6b2">lookupType</a> (std::string tyname) const</td></tr>
<tr class="memdesc:a318ab2029fa46fcf5d06b00ec9baf6b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a lookup for the specified DataType.  <a href="#a318ab2029fa46fcf5d06b00ec9baf6b2">More...</a><br /></td></tr>
<tr class="separator:a318ab2029fa46fcf5d06b00ec9baf6b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f026cfd23efe539bfbb0cc403676228"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structante_1_1Trait.html">Trait</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#a5f026cfd23efe539bfbb0cc403676228">lookupTrait</a> (std::string tyname) const</td></tr>
<tr class="memdesc:a5f026cfd23efe539bfbb0cc403676228"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a lookup for the specified trait.  <a href="#a5f026cfd23efe539bfbb0cc403676228">More...</a><br /></td></tr>
<tr class="separator:a5f026cfd23efe539bfbb0cc403676228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1f66deef59236733074d7fda5041d4b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#ad1f66deef59236733074d7fda5041d4b">typeImplementsTrait</a> (<a class="el" href="classante_1_1AnDataType.html">AnDataType</a> *dt, std::string traitName) const</td></tr>
<tr class="separator:ad1f66deef59236733074d7fda5041d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5559f8950e7a48fbf8d696a1250b0f4b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#a5559f8950e7a48fbf8d696a1250b0f4b">stoType</a> (<a class="el" href="classante_1_1AnDataType.html">AnDataType</a> *ty, std::string &amp;typeName)</td></tr>
<tr class="memdesc:a5559f8950e7a48fbf8d696a1250b0f4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a new DataType.  <a href="#a5559f8950e7a48fbf8d696a1250b0f4b">More...</a><br /></td></tr>
<tr class="separator:a5559f8950e7a48fbf8d696a1250b0f4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1c1a517d909e1f1917fcef5e8ba7398"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#ab1c1a517d909e1f1917fcef5e8ba7398">stoTypeVar</a> (std::string &amp;name, <a class="el" href="classante_1_1AnType.html">AnType</a> *ty)</td></tr>
<tr class="memdesc:ab1c1a517d909e1f1917fcef5e8ba7398"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a TypeVar in the current scope.  <a href="#ab1c1a517d909e1f1917fcef5e8ba7398">More...</a><br /></td></tr>
<tr class="separator:ab1c1a517d909e1f1917fcef5e8ba7398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64532bb2f4aa01449abfcf3b352e5a53"><td class="memItemLeft" align="right" valign="top">llvm::Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#a64532bb2f4aa01449abfcf3b352e5a53">anTypeToLlvmType</a> (const <a class="el" href="classante_1_1AnType.html">AnType</a> *ty, bool force=false)</td></tr>
<tr class="memdesc:a64532bb2f4aa01449abfcf3b352e5a53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches through tn and replaces any typevars inside with their definition from a lookup if found.  <a href="#a64532bb2f4aa01449abfcf3b352e5a53">More...</a><br /></td></tr>
<tr class="separator:a64532bb2f4aa01449abfcf3b352e5a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5c9939e7da1aa00dc04648a5b7e0752"><td class="memItemLeft" align="right" valign="top"><a id="ae5c9939e7da1aa00dc04648a5b7e0752"></a>
<a class="el" href="structante_1_1TypeCheckResult.html">TypeCheckResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#ae5c9939e7da1aa00dc04648a5b7e0752">typeEq</a> (const <a class="el" href="classante_1_1AnType.html">AnType</a> *l, const <a class="el" href="classante_1_1AnType.html">AnType</a> *r) const</td></tr>
<tr class="memdesc:ae5c9939e7da1aa00dc04648a5b7e0752"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a type check against l and r. <br /></td></tr>
<tr class="separator:ae5c9939e7da1aa00dc04648a5b7e0752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee24054c442440083a724f7df3d244a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structante_1_1TypeCheckResult.html">TypeCheckResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#aee24054c442440083a724f7df3d244a9">typeEq</a> (std::vector&lt; <a class="el" href="classante_1_1AnType.html">AnType</a> *&gt; l, std::vector&lt; <a class="el" href="classante_1_1AnType.html">AnType</a> *&gt; r) const</td></tr>
<tr class="memdesc:aee24054c442440083a724f7df3d244a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a type check against l and r.  <a href="#aee24054c442440083a724f7df3d244a9">More...</a><br /></td></tr>
<tr class="separator:aee24054c442440083a724f7df3d244a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dd6b21736ca04ff79f13f680bc599e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structante_1_1TypedValue.html">TypedValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#a9dd6b21736ca04ff79f13f680bc599e8">implicitlyWidenNum</a> (<a class="el" href="structante_1_1TypedValue.html">TypedValue</a> &amp;num, TypeTag castTy)</td></tr>
<tr class="memdesc:a9dd6b21736ca04ff79f13f680bc599e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an implicit widening.  <a href="#a9dd6b21736ca04ff79f13f680bc599e8">More...</a><br /></td></tr>
<tr class="separator:a9dd6b21736ca04ff79f13f680bc599e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a837345c06c7509126dad72f368ba4d77"><td class="memItemLeft" align="right" valign="top"><a id="a837345c06c7509126dad72f368ba4d77"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#a837345c06c7509126dad72f368ba4d77">handleImplicitConversion</a> (<a class="el" href="structante_1_1TypedValue.html">TypedValue</a> *lhs, <a class="el" href="structante_1_1TypedValue.html">TypedValue</a> *rhs)</td></tr>
<tr class="memdesc:a837345c06c7509126dad72f368ba4d77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutates numerical arguments to match types if possible. <br /></td></tr>
<tr class="separator:a837345c06c7509126dad72f368ba4d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cdc13aff6eff38813b2004b0ccfa2dd"><td class="memItemLeft" align="right" valign="top"><a id="a7cdc13aff6eff38813b2004b0ccfa2dd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#a7cdc13aff6eff38813b2004b0ccfa2dd">implicitlyCastIntToInt</a> (<a class="el" href="structante_1_1TypedValue.html">TypedValue</a> *lhs, <a class="el" href="structante_1_1TypedValue.html">TypedValue</a> *rhs)</td></tr>
<tr class="memdesc:a7cdc13aff6eff38813b2004b0ccfa2dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutates integer arguments to match types if not already. <br /></td></tr>
<tr class="separator:a7cdc13aff6eff38813b2004b0ccfa2dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0e955e99db25ab8d8498e10b734652a"><td class="memItemLeft" align="right" valign="top"><a id="af0e955e99db25ab8d8498e10b734652a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#af0e955e99db25ab8d8498e10b734652a">implicitlyCastFltToFlt</a> (<a class="el" href="structante_1_1TypedValue.html">TypedValue</a> *lhs, <a class="el" href="structante_1_1TypedValue.html">TypedValue</a> *rhs)</td></tr>
<tr class="memdesc:af0e955e99db25ab8d8498e10b734652a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutates floating-point arguments to match types if not already. <br /></td></tr>
<tr class="separator:af0e955e99db25ab8d8498e10b734652a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3efc372584121d9623a08a1083d8ceb5"><td class="memItemLeft" align="right" valign="top"><a id="a3efc372584121d9623a08a1083d8ceb5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#a3efc372584121d9623a08a1083d8ceb5">implicitlyCastIntToFlt</a> (<a class="el" href="structante_1_1TypedValue.html">TypedValue</a> *tval, llvm::Type *ty)</td></tr>
<tr class="memdesc:a3efc372584121d9623a08a1083d8ceb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutates an integer to a float. <br /></td></tr>
<tr class="separator:a3efc372584121d9623a08a1083d8ceb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f67cede4b0f6d590b40f450a98ffdbf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#a4f67cede4b0f6d590b40f450a98ffdbf">compileIRtoObj</a> (llvm::Module *mod, std::string outFile)</td></tr>
<tr class="memdesc:a4f67cede4b0f6d590b40f450a98ffdbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compiles a module into an obj file to be used for linking.  <a href="#a4f67cede4b0f6d590b40f450a98ffdbf">More...</a><br /></td></tr>
<tr class="separator:a4f67cede4b0f6d590b40f450a98ffdbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ebdce429d766ca440dd075cc18a898a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structante_1_1TypedValue.html">TypedValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#a5ebdce429d766ca440dd075cc18a898a">getVoidLiteral</a> ()</td></tr>
<tr class="memdesc:a5ebdce429d766ca440dd075cc18a898a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns a literal of type void.  <a href="#a5ebdce429d766ca440dd075cc18a898a">More...</a><br /></td></tr>
<tr class="separator:a5ebdce429d766ca440dd075cc18a898a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a47cc1eee42440cc034f2a3e71f408cc7"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#a47cc1eee42440cc034f2a3e71f408cc7">linkObj</a> (std::string inFiles, std::string outFile)</td></tr>
<tr class="memdesc:a47cc1eee42440cc034f2a3e71f408cc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes the linker specified by AN_LINKER (in <a class="el" href="target_8h_source.html">target.h</a>) to link each object file.  <a href="#a47cc1eee42440cc034f2a3e71f408cc7">More...</a><br /></td></tr>
<tr class="separator:a47cc1eee42440cc034f2a3e71f408cc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a71e7a8c82f30d779f8fc0a52eb184374"><td class="memItemLeft" align="right" valign="top"><a id="a71e7a8c82f30d779f8fc0a52eb184374"></a>
std::shared_ptr&lt; llvm::LLVMContext &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ctxt</b></td></tr>
<tr class="separator:a71e7a8c82f30d779f8fc0a52eb184374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9f6fad60cf5c8423a0f68e6cb3d7edd"><td class="memItemLeft" align="right" valign="top"><a id="ad9f6fad60cf5c8423a0f68e6cb3d7edd"></a>
std::unique_ptr&lt; llvm::ExecutionEngine &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>jit</b></td></tr>
<tr class="separator:ad9f6fad60cf5c8423a0f68e6cb3d7edd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d5fcbe7dae0bb7dbb939c726aab7c75"><td class="memItemLeft" align="right" valign="top"><a id="a5d5fcbe7dae0bb7dbb939c726aab7c75"></a>
std::unique_ptr&lt; llvm::legacy::FunctionPassManager &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>passManager</b></td></tr>
<tr class="separator:a5d5fcbe7dae0bb7dbb939c726aab7c75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2cc9ee3730e87a2ee449bf7e3156f91"><td class="memItemLeft" align="right" valign="top"><a id="ae2cc9ee3730e87a2ee449bf7e3156f91"></a>
std::unique_ptr&lt; llvm::Module &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>module</b></td></tr>
<tr class="separator:ae2cc9ee3730e87a2ee449bf7e3156f91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9314eba5eab7db054c4d9ed63266867d"><td class="memItemLeft" align="right" valign="top"><a id="a9314eba5eab7db054c4d9ed63266867d"></a>
std::unique_ptr&lt; <a class="el" href="structante_1_1parser_1_1RootNode.html">parser::RootNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ast</b></td></tr>
<tr class="separator:a9314eba5eab7db054c4d9ed63266867d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0292d2d26ec0a97c80dc0ef0774288b8"><td class="memItemLeft" align="right" valign="top"><a id="a0292d2d26ec0a97c80dc0ef0774288b8"></a>
llvm::IRBuilder&#160;</td><td class="memItemRight" valign="bottom"><b>builder</b></td></tr>
<tr class="separator:a0292d2d26ec0a97c80dc0ef0774288b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7f0c3b04dd30782053bfa925580c4c6"><td class="memItemLeft" align="right" valign="top"><a id="ad7f0c3b04dd30782053bfa925580c4c6"></a>
<a class="el" href="structante_1_1Module.html">Module</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#ad7f0c3b04dd30782053bfa925580c4c6">compUnit</a></td></tr>
<tr class="memdesc:ad7f0c3b04dd30782053bfa925580c4c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">functions and type definitions of current module <br /></td></tr>
<tr class="separator:ad7f0c3b04dd30782053bfa925580c4c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50ee6416a0da31cc5c17b02c3614b277"><td class="memItemLeft" align="right" valign="top"><a id="a50ee6416a0da31cc5c17b02c3614b277"></a>
<a class="el" href="structante_1_1Module.html">Module</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#a50ee6416a0da31cc5c17b02c3614b277">mergedCompUnits</a></td></tr>
<tr class="memdesc:a50ee6416a0da31cc5c17b02c3614b277"><td class="mdescLeft">&#160;</td><td class="mdescRight">all functions and type definitions visible to current module <br /></td></tr>
<tr class="separator:a50ee6416a0da31cc5c17b02c3614b277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67ba13edafc69d1c7028e90ffb840406"><td class="memItemLeft" align="right" valign="top"><a id="a67ba13edafc69d1c7028e90ffb840406"></a>
std::vector&lt; <a class="el" href="structante_1_1Module.html">Module</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#a67ba13edafc69d1c7028e90ffb840406">imports</a></td></tr>
<tr class="memdesc:a67ba13edafc69d1c7028e90ffb840406"><td class="mdescLeft">&#160;</td><td class="mdescRight">all imported modules <br /></td></tr>
<tr class="separator:a67ba13edafc69d1c7028e90ffb840406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a223b603990d1b63413eb70d7cf39f4ba"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::unique_ptr&lt; llvm::StringMap&lt; std::unique_ptr&lt; <a class="el" href="structante_1_1Variable.html">Variable</a> &gt; &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structante_1_1Compiler.html#a223b603990d1b63413eb70d7cf39f4ba">varTable</a></td></tr>
<tr class="memdesc:a223b603990d1b63413eb70d7cf39f4ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stack of variables mapped to their identifier.  <a href="#a223b603990d1b63413eb70d7cf39f4ba">More...</a><br /></td></tr>
<tr class="separator:a223b603990d1b63413eb70d7cf39f4ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a1570831b0d49e292e4bd534e646117"><td class="memItemLeft" align="right" valign="top"><a id="a8a1570831b0d49e292e4bd534e646117"></a>
std::unique_ptr&lt; <a class="el" href="structante_1_1CompilerCtxt.html">CompilerCtxt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>compCtxt</b></td></tr>
<tr class="separator:a8a1570831b0d49e292e4bd534e646117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae80e715ca0f1d89a277a317488241b54"><td class="memItemLeft" align="right" valign="top"><a id="ae80e715ca0f1d89a277a317488241b54"></a>
std::shared_ptr&lt; <a class="el" href="structante_1_1CompilerCtCtxt.html">CompilerCtCtxt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ctCtxt</b></td></tr>
<tr class="separator:ae80e715ca0f1d89a277a317488241b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b937b0373fd399673d1e949bae33987"><td class="memItemLeft" align="right" valign="top"><a id="a2b937b0373fd399673d1e949bae33987"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>errFlag</b></td></tr>
<tr class="separator:a2b937b0373fd399673d1e949bae33987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3af520cc4406c344cb13085b9064667"><td class="memItemLeft" align="right" valign="top"><a id="ab3af520cc4406c344cb13085b9064667"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>compiled</b></td></tr>
<tr class="separator:ab3af520cc4406c344cb13085b9064667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eada2ae7db8a214762cec4efcdd51e6"><td class="memItemLeft" align="right" valign="top"><a id="a2eada2ae7db8a214762cec4efcdd51e6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isLib</b></td></tr>
<tr class="separator:a2eada2ae7db8a214762cec4efcdd51e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04c19a2c3cdd4a6e08ff25e559df5551"><td class="memItemLeft" align="right" valign="top"><a id="a04c19a2c3cdd4a6e08ff25e559df5551"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isJIT</b></td></tr>
<tr class="separator:a04c19a2c3cdd4a6e08ff25e559df5551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b0064c4c6844b9a8d4281a35698ac3c"><td class="memItemLeft" align="right" valign="top"><a id="a5b0064c4c6844b9a8d4281a35698ac3c"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>fileName</b></td></tr>
<tr class="separator:a5b0064c4c6844b9a8d4281a35698ac3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b687cb6b32bdc04b0d212dca5a70eb5"><td class="memItemLeft" align="right" valign="top"><a id="a7b687cb6b32bdc04b0d212dca5a70eb5"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>outFile</b></td></tr>
<tr class="separator:a7b687cb6b32bdc04b0d212dca5a70eb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaff49a9b3edec3f8d4c569bdc6953527"><td class="memItemLeft" align="right" valign="top"><a id="aaff49a9b3edec3f8d4c569bdc6953527"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>funcPrefix</b></td></tr>
<tr class="separator:aaff49a9b3edec3f8d4c569bdc6953527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a985cda2993bbf58b0120a87905759bd3"><td class="memItemLeft" align="right" valign="top"><a id="a985cda2993bbf58b0120a87905759bd3"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>scope</b></td></tr>
<tr class="separator:a985cda2993bbf58b0120a87905759bd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a0f791776d450019cc3272fdfbfbe19"><td class="memItemLeft" align="right" valign="top"><a id="a9a0f791776d450019cc3272fdfbfbe19"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>optLvl</b></td></tr>
<tr class="separator:a9a0f791776d450019cc3272fdfbfbe19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4772b7ae7d73420190a7647ee53f812e"><td class="memItemLeft" align="right" valign="top"><a id="a4772b7ae7d73420190a7647ee53f812e"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>fnScope</b></td></tr>
<tr class="separator:a4772b7ae7d73420190a7647ee53f812e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An Ante compiler responsible for a single module. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="afdb96f422caf19f04ca073fe495c1a72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdb96f422caf19f04ca073fe495c1a72">&#9670;&nbsp;</a></span>Compiler() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ante::Compiler::Compiler </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lib</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; llvm::LLVMContext &gt;&#160;</td>
          <td class="paramname"><em>ctxt</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The main constructor for <a class="el" href="structante_1_1Compiler.html" title="An Ante compiler responsible for a single module. ">Compiler</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileName</td><td>Name of the file being compiled </td></tr>
    <tr><td class="paramname">lib</td><td>Set to true if this module should be compiled as a library </td></tr>
    <tr><td class="paramname">ctxt</td><td>The LLVMContext possibly shared with another <a class="el" href="structante_1_1Compiler.html" title="An Ante compiler responsible for a single module. ">Compiler</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a32d6af78b250b54b0142e3d258ba944e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32d6af78b250b54b0142e3d258ba944e">&#9670;&nbsp;</a></span>Compiler() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ante::Compiler::Compiler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structante_1_1Compiler.html">Compiler</a> *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structante_1_1parser_1_1Node.html">parser::Node</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>modName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lib</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor for a <a class="el" href="structante_1_1Compiler.html" title="An Ante compiler responsible for a single module. ">Compiler</a> compiling a sub-module within the current file. </p>
<p>Currently only used for string interpolation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>The node to set as the root node (does not need to be a RootNode already) </td></tr>
    <tr><td class="paramname">modName</td><td>Name of the module being compiled </td></tr>
    <tr><td class="paramname">fName</td><td>Name of the file being compiled </td></tr>
    <tr><td class="paramname">lib</td><td>Set to true if this module should be compiled as a library </td></tr>
    <tr><td class="paramname">ctxt</td><td>The LLVMContext shared from the parent <a class="el" href="structante_1_1Compiler.html" title="An Ante compiler responsible for a single module. ">Compiler</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a64532bb2f4aa01449abfcf3b352e5a53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64532bb2f4aa01449abfcf3b352e5a53">&#9670;&nbsp;</a></span>anTypeToLlvmType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Type * ante::Compiler::anTypeToLlvmType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classante_1_1AnType.html">AnType</a> *&#160;</td>
          <td class="paramname"><em>ty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches through tn and replaces any typevars inside with their definition from a lookup if found. </p>
<p>Care must be taken so that the resulting <a class="el" href="classante_1_1AnType.html" title="A primitive type. ">AnType</a> not escape the scope of the typevars in the lookup. Thus, this function should not be used for TypeNodes that may be reused at lower scopes. Translates an AnType* to an llvm::Type*.</p>
<p>Translation fails if the type contains an undeclared data type or an undeclared type variable unless the force flag is set. If the force flag is set each undeclared type var is replaced with a void* and undeclared data types remain an error.</p>
<p>The force flag should generally be avoided unless type inferencing is needed/guarenteed to be performed at a later step to retractively fix the translated type. </p>

</div>
</div>
<a id="a24d957798fbe9610d23f79feb5d40e34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24d957798fbe9610d23f79feb5d40e34">&#9670;&nbsp;</a></span>compAdd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structante_1_1TypedValue.html">TypedValue</a> ante::Compiler::compAdd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structante_1_1TypedValue.html">TypedValue</a> &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structante_1_1TypedValue.html">TypedValue</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structante_1_1parser_1_1BinOpNode.html">parser::BinOpNode</a> *&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emits an add instruction. </p>
<p>Operator overloads are not taken into account and should be handled beforehand. l and r must be the same type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The + Node used for error reporting</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting add instruction </dd></dl>

</div>
</div>
<a id="a37dc19abb16179a71006cfa8554b77f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37dc19abb16179a71006cfa8554b77f8">&#9670;&nbsp;</a></span>compErr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structante_1_1TypedValue.html">TypedValue</a> ante::Compiler::compErr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structante_1_1lazy__printer.html">lazy_printer</a>&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classyy_1_1location.html">yy::location</a> &amp;&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ErrorType&#160;</td>
          <td class="paramname"><em>t</em> = <code>ErrorType::Error</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports a message and highlights the relevant source lines. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Type of message to report, either Error, Warning, or Note </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a77fcf22917c28c7c88ecb0022aa30714"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77fcf22917c28c7c88ecb0022aa30714">&#9670;&nbsp;</a></span>compExtract()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structante_1_1TypedValue.html">TypedValue</a> ante::Compiler::compExtract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structante_1_1TypedValue.html">TypedValue</a> &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structante_1_1TypedValue.html">TypedValue</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structante_1_1parser_1_1BinOpNode.html">parser::BinOpNode</a> *&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compiles an extract operation such as array::index. </p>
<p>Operator overloads are not taken into account and should be handled beforehand.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>The container to extract from </td></tr>
    <tr><td class="paramname">r</td><td>The index to extract </td></tr>
    <tr><td class="paramname">op</td><td>The # operator used for error reporting</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the extraction </dd></dl>

</div>
</div>
<a id="a1d801a585a6bfc19a07ca8ea558f8398"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d801a585a6bfc19a07ca8ea558f8398">&#9670;&nbsp;</a></span>compFn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structante_1_1TypedValue.html">TypedValue</a> ante::Compiler::compFn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structante_1_1FuncDecl.html">FuncDecl</a> *&#160;</td>
          <td class="paramname"><em>fn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compiles any non-generic function. </p>
<p>Generic functions (indicated by a typecheck returning TypeCheckResult::SuccessWithTypeVars) should be compiled with compTemplateFn which calls this function internally. </p>

</div>
</div>
<a id="a4f67cede4b0f6d590b40f450a98ffdbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f67cede4b0f6d590b40f450a98ffdbf">&#9670;&nbsp;</a></span>compileIRtoObj()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ante::Compiler::compileIRtoObj </td>
          <td>(</td>
          <td class="paramtype">llvm::Module *&#160;</td>
          <td class="paramname"><em>mod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>outFile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compiles a module into an obj file to be used for linking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mod</td><td>The already-compiled module </td></tr>
    <tr><td class="paramname">outFile</td><td>Name of the file to output</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd></dl>

</div>
</div>
<a id="a4729b39972523c4996debf67113376c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4729b39972523c4996debf67113376c6">&#9670;&nbsp;</a></span>compileObj()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ante::Compiler::compileObj </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>outName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compiles a module to an object file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outName</td><td>name of the file to output</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd></dl>

</div>
</div>
<a id="ab1da356dd307491d183153e7f0e6cab8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1da356dd307491d183153e7f0e6cab8">&#9670;&nbsp;</a></span>compInsert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structante_1_1TypedValue.html">TypedValue</a> ante::Compiler::compInsert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structante_1_1parser_1_1BinOpNode.html">parser::BinOpNode</a> *&#160;</td>
          <td class="paramname"><em>insertOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structante_1_1parser_1_1Node.html">parser::Node</a> *&#160;</td>
          <td class="paramname"><em>assignExpr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compiles an insert operation such as array::index = 2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">insertOp</td><td>The # operator containing the lhs of the assignment </td></tr>
    <tr><td class="paramname">assignExpr</td><td>The rhs of the assignment</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A void literal </dd></dl>

</div>
</div>
<a id="aa5344f586b928cad058d9a2fb93f056c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5344f586b928cad058d9a2fb93f056c">&#9670;&nbsp;</a></span>compMemberAccess()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structante_1_1TypedValue.html">TypedValue</a> ante::Compiler::compMemberAccess </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structante_1_1parser_1_1Node.html">parser::Node</a> *&#160;</td>
          <td class="paramname"><em>ln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structante_1_1parser_1_1VarNode.html">parser::VarNode</a> *&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structante_1_1parser_1_1BinOpNode.html">parser::BinOpNode</a> *&#160;</td>
          <td class="paramname"><em>binop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compiles a named member access such as str.len. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ln</td><td>The value or type/module being accessed </td></tr>
    <tr><td class="paramname">field</td><td>Name of the desired field/method </td></tr>
    <tr><td class="paramname">binop</td><td>Location of the . operator for error reporting</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The extracted field or method </dd></dl>

</div>
</div>
<a id="a9586ff05c0f9b53e950e27cf0427d357"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9586ff05c0f9b53e950e27cf0427d357">&#9670;&nbsp;</a></span>createMainFn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Function * ante::Compiler::createMainFn </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates the main function of a main module or creates the library_init function of a lib module. </p>
<dl class="section return"><dt>Returns</dt><dd>The llvm::Function* of the created function. </dd></dl>

</div>
</div>
<a id="a56fa1c0637373bc464845c7b1006ea2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56fa1c0637373bc464845c7b1006ea2d">&#9670;&nbsp;</a></span>getCastFn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structante_1_1TypedValue.html">TypedValue</a> ante::Compiler::getCastFn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classante_1_1AnType.html">AnType</a> *&#160;</td>
          <td class="paramname"><em>from_ty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classante_1_1AnType.html">AnType</a> *&#160;</td>
          <td class="paramname"><em>to_ty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structante_1_1FuncDecl.html">FuncDecl</a> *&#160;</td>
          <td class="paramname"><em>fd</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the init method of a type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from_ty</td><td>Tuple of argument types </td></tr>
    <tr><td class="paramname">to_ty</td><td>Type to cast to </td></tr>
    <tr><td class="paramname">fd</td><td>Optional <a class="el" href="structante_1_1FuncDecl.html" title="Contains information about a function that is not contained within its FuncDeclNode. ">FuncDecl</a> of cast function to use if already found</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The compiled cast function or nullptr if not found </dd></dl>

</div>
</div>
<a id="a95122318dcd35120b39aa83245accef7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95122318dcd35120b39aa83245accef7">&#9670;&nbsp;</a></span>getMangledFn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structante_1_1TypedValue.html">TypedValue</a> ante::Compiler::getMangledFn </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classante_1_1AnType.html">AnType</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the function specified. </p>
<p>Automatically binds generic functions and Performs argument deduction if necessary</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Basename of function to search for </td></tr>
    <tr><td class="paramname">args</td><td>Types of each argument in case multiple functions are found</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The specified function or nullptr </dd></dl>

</div>
</div>
<a id="aebe63e69261dbecc8571ddb084fcaa46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebe63e69261dbecc8571ddb084fcaa46">&#9670;&nbsp;</a></span>getMangledFuncDecl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structante_1_1FuncDecl.html">FuncDecl</a> * ante::Compiler::getMangledFuncDecl </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classante_1_1AnType.html">AnType</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the <a class="el" href="structante_1_1FuncDecl.html" title="Contains information about a function that is not contained within its FuncDeclNode. ">FuncDecl</a> specified. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Basename of function to search for </td></tr>
    <tr><td class="paramname">args</td><td><a class="el" href="structante_1_1Argument.html">Argument</a> types if multiple functions are found</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="structante_1_1FuncDecl.html" title="Contains information about a function that is not contained within its FuncDeclNode. ">FuncDecl</a> if found or nullptr if not </dd></dl>

</div>
</div>
<a id="a5ebdce429d766ca440dd075cc18a898a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ebdce429d766ca440dd075cc18a898a">&#9670;&nbsp;</a></span>getVoidLiteral()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structante_1_1TypedValue.html">TypedValue</a> ante::Compiler::getVoidLiteral </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates and returns a literal of type void. </p>
<dl class="section return"><dt>Returns</dt><dd>A void literal </dd></dl>

</div>
</div>
<a id="a9dd6b21736ca04ff79f13f680bc599e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dd6b21736ca04ff79f13f680bc599e8">&#9670;&nbsp;</a></span>implicitlyWidenNum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structante_1_1TypedValue.html">TypedValue</a> ante::Compiler::implicitlyWidenNum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structante_1_1TypedValue.html">TypedValue</a> &amp;&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TypeTag&#160;</td>
          <td class="paramname"><em>castTy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs an implicit widening. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num</td><td>Integer to widen </td></tr>
    <tr><td class="paramname">castTy</td><td>Type to widen to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The widened integer </dd></dl>

</div>
</div>
<a id="a0dff5018bf45f7895df5b2bba1f8048f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dff5018bf45f7895df5b2bba1f8048f">&#9670;&nbsp;</a></span>importFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ante::Compiler::importFile </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structante_1_1parser_1_1Node.html">parser::Node</a> *&#160;</td>
          <td class="paramname"><em>locNode</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Imports a given ante file to the current module inputted file must exist and be a valid ante source file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fName</td><td>Name of file to import </td></tr>
    <tr><td class="paramname">The</td><td>node containing where the file was imported from. Usually the ImportNode importing the file. Used for error reporting. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aac0d539920d04deb2143881fc6f13530"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac0d539920d04deb2143881fc6f13530">&#9670;&nbsp;</a></span>jitFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ante::Compiler::jitFunction </td>
          <td>(</td>
          <td class="paramtype">llvm::Function *&#160;</td>
          <td class="paramname"><em>fnName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classante_1_1JIT.html">JIT</a> compiles a function with no arguments and calls it afterward. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>the function to <a class="el" href="classante_1_1JIT.html">JIT</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a47cc1eee42440cc034f2a3e71f408cc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47cc1eee42440cc034f2a3e71f408cc7">&#9670;&nbsp;</a></span>linkObj()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ante::Compiler::linkObj </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>inFiles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>outFile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invokes the linker specified by AN_LINKER (in <a class="el" href="target_8h_source.html">target.h</a>) to link each object file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inFiles</td><td>String containing each obj file to link separated with spaces </td></tr>
    <tr><td class="paramname">outFile</td><td>Name of the file to output</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd></dl>

</div>
</div>
<a id="ae3c37473195d132a18f72af945032445"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3c37473195d132a18f72af945032445">&#9670;&nbsp;</a></span>lookup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structante_1_1Variable.html">Variable</a> * ante::Compiler::lookup </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>var</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a lookup for a variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">var</td><td>Name of the variable to lookup</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Variable* if found, otherwise nullptr </dd></dl>

</div>
</div>
<a id="a5f026cfd23efe539bfbb0cc403676228"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f026cfd23efe539bfbb0cc403676228">&#9670;&nbsp;</a></span>lookupTrait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structante_1_1Trait.html">Trait</a> * ante::Compiler::lookupTrait </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tyname</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a lookup for the specified trait. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tyname</td><td>Name of the trait to lookup</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Trait* if found, otherwise nullptr </dd></dl>

</div>
</div>
<a id="a318ab2029fa46fcf5d06b00ec9baf6b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a318ab2029fa46fcf5d06b00ec9baf6b2">&#9670;&nbsp;</a></span>lookupType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classante_1_1AnDataType.html">AnDataType</a> * ante::Compiler::lookupType </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tyname</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a lookup for the specified DataType. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tyname</td><td>Name of the type to lookup</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The DataType* if found, otherwise nullptr </dd></dl>

</div>
</div>
<a id="adf5d0d47a6f50d33ab75853c51defb2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf5d0d47a6f50d33ab75853c51defb2a">&#9670;&nbsp;</a></span>processArgs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ante::Compiler::processArgs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structante_1_1CompilerArgs.html">CompilerArgs</a> *&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets appropriate flags and executes operations specified by the command line arguments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>The command line arguments </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5559f8950e7a48fbf8d696a1250b0f4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5559f8950e7a48fbf8d696a1250b0f4b">&#9670;&nbsp;</a></span>stoType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ante::Compiler::stoType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classante_1_1AnDataType.html">AnDataType</a> *&#160;</td>
          <td class="paramname"><em>ty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>typeName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores a new DataType. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ty</td><td>The DataType to store </td></tr>
    <tr><td class="paramname">typeName</td><td>The name of the DataType </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab1c1a517d909e1f1917fcef5e8ba7398"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1c1a517d909e1f1917fcef5e8ba7398">&#9670;&nbsp;</a></span>stoTypeVar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ante::Compiler::stoTypeVar </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classante_1_1AnType.html">AnType</a> *&#160;</td>
          <td class="paramname"><em>ty</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stores a TypeVar in the current scope. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the typevar to store (including the preceeding ') </td></tr>
    <tr><td class="paramname">ty</td><td>The type to store </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad1bc6b687a50f60ccdd258668c580694"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1bc6b687a50f60ccdd258668c580694">&#9670;&nbsp;</a></span>stoVar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ante::Compiler::stoVar </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structante_1_1Variable.html">Variable</a> *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stores a variable in the current scope. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">var</td><td>Name of the variable to store </td></tr>
    <tr><td class="paramname">val</td><td><a class="el" href="structante_1_1Variable.html">Variable</a> to store </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aee24054c442440083a724f7df3d244a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee24054c442440083a724f7df3d244a9">&#9670;&nbsp;</a></span>typeEq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structante_1_1TypeCheckResult.html">TypeCheckResult</a> ante::Compiler::typeEq </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classante_1_1AnType.html">AnType</a> *&gt;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classante_1_1AnType.html">AnType</a> *&gt;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a type check against l and r. </p>
<p>Used for function parameters and similar situations where typevars across multiple type checks need to be consistent. Eg. a function of type ('t, 't)-&gt;void should not match the arguments i32 and u64. Performing a typecheck on each argument separately would give a different bound value for 't. Using this function would result in the appropriate TypeCheckResult::Failure </p>

</div>
</div>
<a id="ad1f66deef59236733074d7fda5041d4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1f66deef59236733074d7fda5041d4b">&#9670;&nbsp;</a></span>typeImplementsTrait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ante::Compiler::typeImplementsTrait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classante_1_1AnDataType.html">AnDataType</a> *&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>traitName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if a DataType implements the specified trait </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a223b603990d1b63413eb70d7cf39f4ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a223b603990d1b63413eb70d7cf39f4ba">&#9670;&nbsp;</a></span>varTable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::unique_ptr&lt;llvm::StringMap&lt;std::unique_ptr&lt;<a class="el" href="structante_1_1Variable.html">Variable</a>&gt; &gt; &gt; &gt; ante::Compiler::varTable</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stack of variables mapped to their identifier. </p>
<p>Maps are seperated according to their scope. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>/home/rndmprsn/Code/Ante/include/<a class="el" href="compiler_8h_source.html">compiler.h</a></li>
<li>/home/rndmprsn/Code/Ante/src/compiler.cpp</li>
<li>/home/rndmprsn/Code/Ante/src/error.cpp</li>
<li>/home/rndmprsn/Code/Ante/src/function.cpp</li>
<li>/home/rndmprsn/Code/Ante/src/operator.cpp</li>
<li>/home/rndmprsn/Code/Ante/src/types.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
