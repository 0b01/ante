// builtin function
/*
        prelude.an
    Standard functions and datatypes pre-imported
    into every Ante source file.
*/

//C functions
extern 
    // printf (format: ref char) ... -> int
    puts: (ref char) -> i32
    putchar: char -> unit
    getchar: unit -> char
    exit: i32 -> never_returns
    malloc: usz -> ref a
    realloc: (ref a) usz -> ref a
    free: (ref a) -> unit
    memcpy: (ref a) (ref b) i32 -> ref a //dest
    system: (ref char) -> i32
    strlen: (ref char) -> i32

//C stdio
type File = f: ref unit
type FilePos = f: ref unit

type InFile = f:File
type OutFile = f:File

extern 
    fopen: (ref char) (ref char) -> File
    fclose: File -> unit

    fputs: (ref char) OutFile -> i32
    fputc: i32 OutFile -> i32
    fgetc: InFile -> i32
    fgets: (ref char) i32 InFile -> ref char
    ungetc: i32 InFile -> i32

    fgetpos: File FilePos -> unit
    ftell: File -> i32
    fsetpos: File FilePos -> unit
    fseek: File i32 i32 -> i32

    feof: InFile -> i32
    ferror: File -> i32

//Convenience function for using fgetc, and feof with better types
// TODO: builtin casting between primitives
// fgetchar f = fgetc f as char
// feofb f = feof f as bool

//Ante datatypes
type Maybe t =
   | Some t
   | None


trait Empty t
    empty: t

// TODO: trait impls with 'given' clauses
// impl Eq (Maybe 'e) given Eq 'e
//     (==) l r =
//         match (l, r) with
//         | (Some lv, Some rv) -> lv == rv
//         | (None, None) -> true
//         | _ -> false

trait Cast a /*to*/ b
    cast: a -> b

impl Cast a a
    cast a = a

impl Cast (ref a) usz
    cast (_ptr: ref a) = builtin "CastRefUsz"

impl Cast usz (ref a)
    cast (_address: usz) = builtin "CastRefUsz"

// TODO: trait impls with 'given' clauses
// impl Cast (Maybe 'm) string given Cast 'm string
//     cast maybe =
//         match maybe with
//         | Some val -> "Some (" ++ cast val ++ ")"
//         | None -> "None"

trait TryCast a b
    try_cast: a -> Maybe b

// TODO: trait impls with 'given' clauses
// impl TryCast 'a 'b given Cast 'a 'b
//     try_cast a = Some (cast a)


trait Add n
    (+): n n -> n

impl Add a given Int a
    (+) _ _ = builtin "AddInt"

impl Add float
    (+) (_: float) (_: float) -> float = builtin "AddFloat"


trait Sub n
    (-): n n -> n

impl Sub a given Int a
    (-) _ _ = builtin "SubInt"

impl Sub float
    (-) (_: float) (_: float) -> float = builtin "SubFloat"


trait Mul n
    (*): n n -> n

impl Mul a given Int a
    (*) _ _ = builtin "MulInt"

impl Mul float
    (*) (_: float) (_: float) -> float = builtin "MulFloat"


trait Div n
    (/): n n -> n

impl Div a given Int a
    (/) _ _ = builtin "DivInt"

impl Div float
    (/) (_: float) (_: float) -> float = builtin "DivFloat"


trait Mod n
    (%): n n -> n


impl Mod a given Int a
    (%) _ _ = builtin "ModInt"

impl Mod float
    (%) (_: float) (_: float) -> float = builtin "ModFloat"


trait Eq t
    (==): t t -> bool

(not) a = if a then false else true
(!=) l r = not (l == r)

impl Eq a given Int a
    (==) _ _ = builtin "EqInt"

impl Eq float
    (==) (_: float) (_: float) -> bool = builtin "EqFloat"

type Ordering = | Less | Equal | Greater

impl Eq Ordering
    (==) (a: Ordering) (b: Ordering) -> bool =
        match (a, b) with
        | (Less, Less) -> true
        | (Equal, Equal) -> true
        | (Greater, Greater) -> true
        | _ -> false

trait Cmp a
    compare: a a -> Ordering

(<) a b = compare a b == Less
(>) a b = compare a b == Greater
(<=) a b = compare a b != Greater
(>=) a b = compare a b != Less

impl Cmp a given Int a
    compare _ _ =
        if builtin "LessInt" then Less
        else if builtin "GreaterInt" then Greater
        else Equal

impl Cmp float
    compare (_: float) (_: float) -> Ordering =
        if builtin "LessFloat" then Less
        else if builtin "GreaterFloat" then Greater
        else Equal

// TODO: 'is' operator for identity/referential equality
// trait Is 't
//     (is) 't 't -> bool

trait Append t
    (++): t t -> t

trait Extract col index -> elem
    (#): col index -> elem

// TODO: 'mut' and special-case extract versus append
// trait Insert col index elem
//     // temporary until functions with the same name and
//     // a differing number of parameters can be declared.
//     insert (mut col) index elem -> unit

trait In elem col
    (in): elem col -> bool

// trait Deref ptr -> elem
//     (@): ptr -> elem

// TODO: Do we need a separate trait for unary '-'?
// trait Neg t
//     neg t -> t

// TODO: Is a trait for unary 'Not' needed or can it just be a normal function?
// trait Not t
//     (not) t -> t


trait Print t
    printne: t -> unit

print x =
    printne x
    putchar '\n'

impl Print i32
    printne x =
        extern printf : (ref char) i32 -> unit
        printf ("%d".c_string) x

// TODO: need varargs support for printf
// impl Print int
//     printne x = printf ("%d".cStr) x
// 
// impl Print float
//     printne x = printf ("%.14f".cStr) x
// 
// impl Print char
//     printne x = printf ("%c".cStr) x
// 
// impl Print bool
//     printne b =
//         if b then printf ("true".cStr)
//         else printf ("false".cStr)
// 
// impl Print (ref char)
//     printne s = printf ("%s".cStr) s
// 
// impl Print string
//     printne s =
//         extern printf : (ref char) (ref char) -> unit
//         printf "%s".c_string s.c_string

// TODO: impls with 'given' clauses
// impl Print 't given Cast 't string
//     printne t = printne (t as string)


impl Cast string (ref char)
    cast s = s.c_string

// TODO: 'mut'
// impl Cast int string
//     cast i =
//         if i == 0 then return "0"
//         len = mut 0
//         alloc_size = 20
//         buf = mut malloc (alloc_size + 1)
//         buf#alloc_size := '\0'
// 
//         x = mut i
//         isNeg = i < 0 and ((x *= -1); true)
// 
//         while x != 0 do
//             len += 1
//             buf#(alloc_size - len) := '0' + cast (x % 10)
//             x /= 10
// 
//         if isNeg then
//             len += 1
//             buf#(alloc_size - len) := '-'
// 
//         offset = cast buf + (alloc_size - len)
//         string (cast offset) len


// TODO: mut
// parse (s: string) -> Maybe int =
//     i = mut 0
//     sum = mut 0
//     isNeg =
//         if s.len == 0 or s.cStr#0 == '-' then false
//         else ((i += 1); true)
// 
//     while s.cStr#i != '\0' do
//         c = s.cStr#i
//         if c >= '0' and c <= '9' then
//             sum *= 10
//             sum += cast (c - '0')
//             i += 1
//             None
//         else
//             return None
// 
//     Some (if isNeg then -1 * sum else sum)

// TODO: impls with 'given' clauses
// impl Eq (ref 't) given Eq 't
//     (==) l r = @l == @r


//For-loops work over any range that is Iterable
trait Iterable i -> it
    into_iter: i -> it

trait Iterator i -> elem
    has_next: i -> bool
    cur_elem: i -> elem
    advance: i -> i

// TODO: impls with 'given' clauses
// impl Iterable 'i 'i 'e given Iterator 'i
//     into_iter i = i

// TODO: unary 'not'
// //Iterating through an InFile iterates through each line
// impl Iterator InFile string
//     has_next f = not feofb f
//     cur_elem f = InFile.next_line f
//     advance f = f


// impl Cast (ref char) string
//     cast cStr = string cStr (cast (strlen cStr))
// 
// impl Eq string
//     (==) l r =
//         if l.len != r.len then
//             return false
// 
//         for i in 0 .. l.len do
//             if l.cStr#i != r.cStr#i then
//                 return false
//         true
// 
// impl Is string
//     (is) l r = l.cStr is r.cStr
// 
// 
// impl Append string
//     (++) s1 s2 =
//         if s1.len == 0int then return s2
//         if s2.len == 0int then return s1
// 
//         len = s1.len + s2.len
//         buf = mut malloc (len+1int)
// 
//         memcpy buf (s1.cStr) s1.len
// 
//         buf_offset = cast (cast buf + s1.len)
//         memcpy buf_offset (s2.cStr) (s2.len+1int) //copy terminating null too
// 
//         string buf len
// 
// impl Extract string int char
//     (#) s index = s.cStr#index
// 
// 
// impl Insert string int char
//     insert str index char =
//         str.cStr#index := char
// 
// impl Cast string InFile
//     cast fName = InFile (fopen fName.cStr "r".cStr)
// 
// 
// impl Cast string OutFile
//     cast fName = OutFile (fopen fName.cStr "w".cStr)
// 
// 
// module InFile
//     next_line (f:InFile) -> string =
//         if feofb f then return ""
//         eof = cast 255
// 
//         len = mut 0int
//         cap = mut 64int
//         cstr = mut malloc cap
// 
//         while
//             c = fgetchar f
// 
//             if c == eof then break
// 
//             //Flag feof if eof occurs after terminating newline
//             if c == '\n' then
//                 peek = fgetchar f
//                 if peek != eof then ungetc (cast peek) f
//                 break
// 
//             if len+1int >= cap then
//                 cap *= 2int
//                 cstr := realloc cstr cap
// 
//             cstr#len := c
//             len += 1int
//             true
//         do ()
// 
//         cstr#len := '\0'
//         string cstr len
// 
// 
// //print a message then return user input
// input msg -> string =
//     len = mut 0int
//     cstr = mut cast 0
// 
//     printne msg
// 
//     while
//         c = getchar ()
//         if len % 32int == 0int then
//             cstr := realloc cstr (len+32int)
// 
//         cstr#len := c
//         len += 1int
//         c != '\n'
//     do ()
// 
//     len -= 1int
//     cstr#len := '\0'
//     string cstr len
