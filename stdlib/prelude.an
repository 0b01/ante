// builtin function
/*
        prelude.an
    Standard functions and datatypes pre-imported
    into every Ante source file.
*/
extern 
    printf: (ref char) ... -> unit
    puts: (ref char) -> i32
    putchar: char -> unit
    getchar: unit -> char
    exit: i32 -> never_returns
    malloc: usz -> ref a
    realloc: (ref a) usz -> ref a
    free: (ref a) -> unit
    memcpy: (ref a) (ref b) i32 -> ref a //dest
    system: (ref char) -> i32
    strlen: (ref char) -> i32

type Maybe t =
   | Some t
   | None

type Result t e =
   | Ok t
   | Error e

impl Eq (Maybe e) given Eq e with
    (==) l r =
        match l, r with
        | Some lv, Some rv -> lv == rv
        | None, None -> true
        | _ -> false

first (a, _) = a
second (_, b) = b
third (_, _, c) = c
fourth (_, _, _, d) = d
fifth (_, _, _, _, e) = e

/// A type conversion from a to b
trait Cast a b with
    cast: a -> b

impl Cast a a with
    cast a = a

impl Cast (Maybe m) string given Cast m string with
    cast maybe =
        match maybe with
        | Some val -> "Some (" ++ cast val ++ ")"
        | None -> "None"


/// Represents a failable type cast from a to b
trait TryCast a b with
    try_cast: a -> Maybe b

impl TryCast a b given Cast a b with
    try_cast a = Some (cast a)


// Huge block of builtin numeric operators incoming
trait Add n with (+): n n -> n
impl Add a given Int a with (+) _ _ = builtin "AddInt"
impl Add float with (+) (_: float) (_: float) -> float = builtin "AddFloat"

trait Sub n with (-): n n -> n
impl Sub a given Int a with (-) _ _ = builtin "SubInt"
impl Sub float with (-) (_: float) (_: float) -> float = builtin "SubFloat"

trait Mul n with (*): n n -> n
impl Mul a given Int a with (*) _ _ = builtin "MulInt"
impl Mul float with (*) (_: float) (_: float) -> float = builtin "MulFloat"

trait Div n with (/): n n -> n
impl Div a given Int a with (/) _ _ = builtin "DivInt"
impl Div float with (/) (_: float) (_: float) -> float = builtin "DivFloat"

trait Mod n with (%): n n -> n
impl Mod a given Int a with (%) _ _ = builtin "ModInt"
impl Mod float with (%) (_: float) (_: float) -> float = builtin "ModFloat"

trait Eq t with (==): t t -> bool
impl Eq a given Int a with (==) _ _ = builtin "EqInt"
impl Eq float with (==) (_: float) (_: float) -> bool = builtin "EqFloat"

(not) a = if a then false else true
(!=) l r = not (l == r)

type Ordering = | Less | Equal | Greater

impl Eq Ordering with
    (==) (a: Ordering) (b: Ordering) -> bool =
        match a, b with
        | Less, Less -> true
        | Equal, Equal -> true
        | Greater, Greater -> true
        | _ -> false

trait Cmp a with
    compare: a a -> Ordering

(<) a b = compare a b == Less
(>) a b = compare a b == Greater
(<=) a b = compare a b != Greater
(>=) a b = compare a b != Less

impl Cmp a given Int a with
    compare _ _ =
        if builtin "LessInt" then Less
        else if builtin "GreaterInt" then Greater
        else Equal

impl Cmp float with
    compare (_: float) (_: float) -> Ordering =
        if builtin "LessFloat" then Less
        else if builtin "GreaterFloat" then Greater
        else Equal

trait Append t with
    (++): t t -> t

trait Extract collection index -> elem with
    (#): collection index -> elem

// TODO: 'mut' and special-case extract versus append
// trait Insert collection index elem
//     (#): (mut collection) index elem -> unit

trait In elem col with
    (in): elem col -> bool

// trait Deref ptr -> elem
//     (@): ptr -> elem

// TODO: Do we need a separate trait for unary '-'?
// trait Neg t
//     (-): t -> t


trait Print t with
    printne: t -> unit

print x =
    printne x
    putchar '\n'

impl Print i8  with printne x = printf ("%hhd".c_string) x
impl Print i16 with printne x = printf ("%hd".c_string) x
impl Print i32 with printne x = printf ("%d".c_string) x
impl Print i64 with printne x = printf ("%ld".c_string) x
impl Print isz with printne x = printf ("%zi".c_string) x
impl Print u8  with printne x = printf ("%hhu".c_string) x
impl Print u16 with printne x = printf ("%hu".c_string) x
impl Print u32 with printne x = printf ("%u".c_string) x
impl Print u64 with printne x = printf ("%lu".c_string) x
impl Print usz with printne x = printf ("%zu".c_string) x
impl Print char with printne x = printf ("%c".c_string) x
impl Print float with printne x = printf ("%.14f".c_string) x
impl Print string with printne s = printf "%s".c_string s.c_string
impl Print (ref char) with printne s = printf ("%s".c_string) s

impl Print bool with
    printne b =
        if b then printf ("true".c_string)
        else printf ("false".c_string)

// TODO: This impl would conflict with others
// impl Print t given Cast t string
//     printne t = printne (t as string)


impl Cast string (ref char) with
    cast s = s.c_string

// TODO: loops
// impl Cast int string
//     cast i =
//         if i == 0 then return "0"
//         len = mut 0
//         alloc_size = 20
//         buf = mut malloc (alloc_size + 1)
//         buf#alloc_size := '\0'
// 
//         x = mut i
//         isNeg = i < 0 and ((x *= -1); true)
// 
//         while x != 0 do
//             len += 1
//             buf#(alloc_size - len) := '0' + cast (x % 10)
//             x /= 10
// 
//         if isNeg then
//             len += 1
//             buf#(alloc_size - len) := '-'
// 
//         offset = cast buf + (alloc_size - len)
//         string (cast offset) len


// TODO: mut
// parse (s: string) -> Maybe int =
//     i = mut 0
//     sum = mut 0
//     isNeg =
//         if s.len == 0 or s.c_string#0 == '-' then false
//         else ((i += 1); true)
// 
//     while s.c_string#i != '\0' do
//         c = s.c_string#i
//         if c >= '0' and c <= '9' then
//             sum *= 10
//             sum += cast (c - '0')
//             i += 1
//             None
//         else
//             return None
// 
//     Some (if isNeg then -1 * sum else sum)

// impl Eq (ref t) given Eq t with
//     (==) l r = @l == @r


//For-loops work over any range that is Iterable
// trait Iterable i -> it elem given Iterator it elem with
//     into_iter: i -> it
// 
trait Iterator it -> elem with
    next: it -> Maybe (elem, it)
// 
// impl Iterable i i e given Iterator i e with
//     into_iter i = i

// //print a message then return user input
// input msg -> string =
//     len = mut 0int
//     cstr = mut cast 0
// 
//     printne msg
// 
//     while
//         c = getchar ()
//         if len % 32int == 0int then
//             cstr := realloc cstr (len+32int)
// 
//         cstr#len := c
//         len += 1int
//         c != '\n'
//     do ()
// 
//     len -= 1int
//     cstr#len := '\0'
//     string cstr len
