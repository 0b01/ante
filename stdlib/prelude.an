// builtin function
/*
        prelude.an
    Standard functions and datatypes pre-imported
    into every Ante source file.
*/

//C functions
extern 
    // varargs is not supported by the cranelift backend
    // printf: Ptr char - ... -> unit
    puts: Ptr char -> i32
    putchar: char -> unit
    getchar: unit -> char
    exit: i32 -> never_returns
    malloc: usz -> Ptr a
    realloc: Ptr a - usz -> Ptr a
    free: Ptr a -> i32
    memcpy: Ptr a - Ptr b - i32 -> Ptr a //dest
    system: Ptr char -> i32
    strlen: Ptr char -> i32

//C stdio
type File = f: Ptr unit
type FilePos = f: Ptr unit

type InFile = f:File
type OutFile = f:File

extern
    fopen: Ptr char - Ptr char -> File
    fclose: File -> unit

    fputs: Ptr char - OutFile -> i32
    fputc: i32 - OutFile -> i32
    fgetc: InFile -> i32
    fgets: Ptr char - i32 - InFile -> Ptr char
    ungetc: i32 - InFile -> i32

    fgetpos: File - FilePos -> unit
    ftell: File -> i32
    fsetpos: File - FilePos -> unit
    fseek: File - i32 - i32 -> i32

    feof: InFile -> i32
    ferror: File -> i32

//Convenience function for using fgetc, and feof with better types
// TODO: builtin casting between primitives
// fgetchar f = fgetc f as char
// feofb f = feof f as bool

type Maybe t =
   | Some t
   | None

type Result t e =
   | Ok t
   | Error e

impl Eq (Maybe e) given Eq e with
    (==) l r =
        match l, r
        | Some lv, Some rv -> lv == rv
        | None, None -> true
        | _ -> false

first (a, _) = a
second (_, b) = b
third (_, _, c) = c
fourth (_, _, _, d) = d
fifth (_, _, _, _, e) = e

/// A type conversion from a to b
trait Cast a b with
    cast: a -> b

impl Cast a a with
    cast a = a

impl Cast (Ptr a) usz with
    cast ptr = transmute ptr

impl Cast usz (Ptr a) with
    cast address = transmute address

impl Cast (Maybe m) string given Cast m string with
    cast maybe =
        match maybe
        | Some val -> "Some (" ++ cast val ++ ")"
        | None -> "None"

// Incomplete list of int -> int casts. TODO: Add more as appropriate
impl Cast u64 char with cast _ = builtin "truncate"

impl Cast i32 i64 with cast _ = builtin "sign_extend"

/// Represents a failable type cast from a to b
trait TryCast a b with
    try_cast: a -> Maybe b

impl TryCast a b given Cast a b with
    try_cast a = Some (cast a)


// Huge block of builtin numeric operators incoming
trait Add n with (+): n - n -> n
impl Add a given Int a with (+) _ _ = builtin "AddInt"
impl Add float with (+) (_: float) (_: float) : float = builtin "AddFloat"
impl Add char with (+) (_: char) (_: char) : char = builtin "AddInt"

trait Sub n with (-): n - n -> n
impl Sub a given Int a with (-) _ _ = builtin "SubInt"
impl Sub float with (-) (_: float) (_: float) : float = builtin "SubFloat"
impl Sub char with (-) (_: char) (_: char) : char = builtin "SubInt"

trait Mul n with (*): n - n -> n
impl Mul a given Int a with (*) _ _ = builtin "MulInt"
impl Mul float with (*) (_: float) (_: float) : float = builtin "MulFloat"

trait Div n with (/): n - n -> n
impl Div a given Int a with (/) _ _ = builtin "DivInt"
impl Div float with (/) (_: float) (_: float) : float = builtin "DivFloat"

trait Mod n with (%): n - n -> n
impl Mod a given Int a with (%) _ _ = builtin "ModInt"
impl Mod float with (%) (_: float) (_: float) : float = builtin "ModFloat"

trait Eq t with (==): t - t -> bool
impl Eq a given Int a with (==) _ _ = builtin "EqInt"
impl Eq float with (==) (_: float) (_: float) : bool = builtin "EqFloat"

impl Eq char with (==) (_: char) (_: char) : bool = builtin "EqChar"
impl Eq bool with (==) (_: bool) (_: bool) : bool = builtin "EqBool"

(not) a = if a then false else true
(!=) l r = not (l == r)

type Ordering = | Less | Equal | Greater

impl Eq Ordering with
    (==) (a: Ordering) (b: Ordering) : bool =
        match a, b
        | Less, Less -> true
        | Equal, Equal -> true
        | Greater, Greater -> true
        | _ -> false

trait Cmp a with
    compare: a - a -> Ordering

(<) a b = compare a b == Less
(>) a b = compare a b == Greater
(<=) a b = compare a b != Greater
(>=) a b = compare a b != Less

impl Cmp a given Int a with
    compare _ _ =
        if builtin "LessInt" then Less
        else if builtin "GreaterInt" then Greater
        else Equal

impl Cmp float with
    compare (_: float) (_: float) : Ordering =
        if builtin "LessFloat" then Less
        else if builtin "GreaterFloat" then Greater
        else Equal

impl TryCast i64 u64 with
    try_cast x =
        if x < 0 then None
        else Some (transmute x)

impl TryCast u64 i64 with
    try_cast x =
        if x > 9_223_372_036_854_775_807 then None
        else Some (transmute x)

trait Append t with
    (++): t - t -> t

trait Extract collection index -> elem with
    (#): collection - index -> elem

impl Extract (Ptr t) usz t with
    (#) ptr index = deref_ptr <| offset ptr index

offset (_ptr: Ptr t) (_index: usz) : Ptr t =
    builtin "offset"

deref (_: ref t) : t =
    builtin "deref"

deref_ptr (p: Ptr t) : t =
    deref <| transmute p

null = cast 0usz : Ptr a

transmute (_: a) : b =
    builtin "transmute"

// TODO: 'mut' and special-case extract versus append
// trait Insert collection index elem
//     (#): mut collection - index - elem -> unit

trait In elem col with
    (in): elem - col -> bool

// trait Deref ptr -> elem
//     deref: ptr -> elem

// TODO: Do we need a separate trait for unary '-'?
// trait Neg t
//     (-): t -> t


trait Print t with
    printne: t -> unit

print x =
    printne x
    putchar '\n'

impl Print u8  with printne x = print_unsigned (cast x)
impl Print u16 with printne x = print_unsigned (cast x)
impl Print u32 with printne x = print_unsigned (cast x)
impl Print u64 with printne x = print_unsigned x
impl Print usz with printne x = print_unsigned (cast x)

impl Print i8 with
    printne x = print_signed (cast x) -128 "-128"

impl Print i16 with
    printne x = print_signed (cast x) -32_768 "-32_768"

impl Print i32 with
    printne x = print_signed (cast x) -2_147_483_648 "-2_147_483_648"

impl Print i64 with
    printne x = print_signed x -9_223_372_036_854_775_808 "-9_223_372_036_854_775_808"

// TODO: This is broken for 32 bit platforms.
impl Print isz with
    printne x =
        print_signed (cast x) -9_223_372_036_854_775_808 "-9_223_372_036_854_775_808"


impl Print char with printne x = putchar x

impl Print float with printne _ = panic "float printing is currently disabled"

impl Print string with printne s = print_c_string (s.c_string)
impl Print (Ptr char) with printne s = print_c_string s

unwrap (m: Maybe t) : t =
    match m
    | Some x -> x
    | None -> panic "Tried to unwrap a None value"

// Naive replacement for printf which isn't supported by the cranelift backend
print_unsigned (x: u64) : unit =
    if x >= 10 then print_unsigned (x / 10)
    digit = cast (x % 10)
    putchar (digit + '0')

print_signed (x: i64) (min: i64) (min_string: string) : unit =
    if x < 0 then
        if x == min then
            printne min_string
        else
            putchar '-'
            print_unsigned <| unwrap <| try_cast (0-x)
    else
        print_unsigned <| unwrap <| try_cast x

print_c_string (s: Ptr char) : unit =
    go s i =
        c = s#i
        if c != '\0' then
            putchar c
            go s (i + 1)

    go s 0

impl Print bool with
    printne b =
        if b then printne "true"
        else printne "false"

// TODO: This impl would conflict with others
// impl Print t given Cast t string
//     printne t = printne (t as string)


impl Cast string (Ptr char) with
    cast s = s.c_string

// TODO: loops
// impl Cast int string
//     cast i =
//         if i == 0 then return "0"
//         len = mut 0
//         alloc_size = 20
//         buf = mut malloc (alloc_size + 1)
//         buf#alloc_size := '\0'
// 
//         x = mut i
//         isNeg = i < 0 and ((x *= -1); true)
// 
//         while x != 0 do
//             len += 1
//             buf#(alloc_size - len) := '0' + cast (x % 10)
//             x /= 10
// 
//         if isNeg then
//             len += 1
//             buf#(alloc_size - len) := '-'
// 
//         offset = cast buf + (alloc_size - len)
//         string (cast offset) len


// TODO: mut
// parse (s: string) -> Maybe int =
//     i = mut 0
//     sum = mut 0
//     isNeg =
//         if s.len == 0 or s.c_string#0 == '-' then false
//         else ((i += 1); true)
// 
//     while s.c_string#i != '\0' do
//         c = s.c_string#i
//         if c >= '0' and c <= '9' then
//             sum *= 10
//             sum += cast (c - '0')
//             i += 1
//             None
//         else
//             return None
// 
//     Some (if isNeg then -1 * sum else sum)

impl Eq (ref t) given Eq t with
    (==) l r = deref l == deref r

impl Eq (Ptr t) with
    (==) l r = (cast l : usz) == cast r


trait Iterator it -> elem with
    next: it -> Maybe (it, elem)

iter iterable f =
    match next iterable
    | None -> ()
    | Some (rest, elem) ->
        f elem
        iter rest

type Range t = start: t, end: t

impl Iterator (Range t) t given Int t with
    next range =
        if range.start >= range.end
        then None
        else
            next = Range (range.start + 1) range.end
            Some (next, range.start)

// Iterating through an InFile iterates through each line
// impl Iterator InFile string
//     has_next f = not feofb f
//     cur_elem f = InFile.next_line f
//     advance f = f

// TODO: manually construct a string from parts
// impl Cast (ref char) string with
//     cast c_string = string c_string (cast (strlen c_string))

// impl Eq string
//     (==) l r =
//         if l.len != r.len then
//             return false
// 
//         for i in 0 .. l.len do
//             if l.c_string#i != r.c_string#i then
//                 return false
//         true

// TODO: manually construct a string from parts
// impl Append string with
//     (++) s1 s2 =
//         if s1.len == 0 then return s2
//         if s2.len == 0 then return s1
// 
//         len = s1.len + s2.len
//         buf = mut malloc (len + 1)
// 
//         memcpy buf (s1.c_string) (s1.len)
// 
//         buf_offset = cast (cast buf + s1.len)
//         memcpy buf_offset (s2.c_string) (s2.len + 1) //copy terminating null too
// 
//         string buf len

panic msg =
    print msg
    exit 1

impl Extract string usz char with
    (#) s index = s.c_string#index


type Type t = | MkType

size_of (_: Type t) : usz = builtin "size_of"


// impl Insert string int char
//     insert str index char =
//         str.c_string#index := char

impl Cast string InFile with
    cast fName = InFile (fopen fName.c_string "r".c_string)


impl Cast string OutFile with
    cast fName = OutFile (fopen fName.c_string "w".c_string)


// module InFile
//     next_line (f:InFile) -> string =
//         if feofb f then return ""
//         eof = cast 255
// 
//         len = mut 0int
//         cap = mut 64int
//         cstr = mut malloc cap
// 
//         while
//             c = fgetchar f
// 
//             if c == eof then break
// 
//             //Flag feof if eof occurs after terminating newline
//             if c == '\n' then
//                 peek = fgetchar f
//                 if peek != eof then ungetc (cast peek) f
//                 break
// 
//             if len+1int >= cap then
//                 cap *= 2int
//                 cstr := realloc cstr cap
// 
//             cstr#len := c
//             len += 1int
//             true
//         do ()
// 
//         cstr#len := '\0'
//         string cstr len
// 
// 
// //print a message then return user input
// input msg -> string =
//     len = mut 0int
//     cstr = mut cast 0
// 
//     printne msg
// 
//     while
//         c = getchar ()
//         if len % 32int == 0int then
//             cstr := realloc cstr (len+32int)
// 
//         cstr#len := c
//         len += 1int
//         c != '\n'
//     do ()
// 
//     len -= 1int
//     cstr#len := '\0'
//     string cstr len
