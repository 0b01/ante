
type Vec 't = 't* _data, usz len cap

ext Vec 't
    fun init :=
        Vec<'t>('t* malloc(4 * Ante.sizeof 't), 0usz, 4usz)

    fun init: Range r -> Vec i32
        fill (Vec<i32>()) r

    fun is_empty: Vec v =
        v.len == 0

    //Fill Vec with items from the Range
    fun fill: mut Vec i32 v, Range r -> Vec i32
        for i in r do
            v.push i
        v

    //reserve numElements in Vec v, elements will be uninitialized
    fun reserve: mut Vec 't v, usz numElems
        if v.len + numElems > v.cap then
            let size = (v.cap + numElems) * Ante.sizeof 't
            let ptr = realloc (void* v._data) size

            if ptr is void* 0 then
                printf "Error in reserving %u elements for Vec\n" numElems
                return ()

            v._data = 't* ptr
            v.cap += numElems

    fun push: mut Vec 't v, 't elem
        if v.len >= v.cap then
            v.reserve v.cap

        v._data#v.len = elem
        v.len += 1

    fun pop: mut Vec v
        v.len -= 1

    fun remove: mut Vec v, i32 idx
        if idx > 0 then
            if idx == v.len - 1 then
                v.len -= 1

            elif idx < v.len - 1 then
                for i in idx .. i32(v.len)-1 do
                    v._data#i = v._data#(i+1)

                v.len -= 1


type VecIter 't = 't* view, usz idx len

ext Vec : Iterable
    fun into_iter: Vec v =
        VecIter(v._data, 0usz, v.len)

ext VecIter : Iterator
    fun has_next: VecIter v =
        v.idx < v.len

    fun unwrap: VecIter 't v -> 't
        v.view#v.idx

    fun next: VecIter 't v -> VecIter 't
        VecIter(v.view, v.idx + 1, v.len)


fun printne: Vec 't v
    printne "{ "

    var i = 0
    while i < v.len do
        printne (v._data#i)
        if i + 1 != v.len then
            printf ", "

        i += 1

    printne " }"

//define the extract operator
fun (#): Vec 't v, i32 i -> 't
    v._data#i

//define the insert operator
fun (#): mut Vec 't v, i32 i, 't x
    v._data#i = x
